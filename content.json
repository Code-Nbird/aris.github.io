{"meta":{"title":"aaaris's blog","subtitle":"aaaris' blog","description":"aaaris is talking here.","author":"aaaris","url":"http://aaaris.github.io","root":"/"},"pages":[],"posts":[{"title":"Linux系统编程 第八章","slug":"Linux系统编程 第八章","date":"2022-10-24T12:55:39.017Z","updated":"2022-10-24T12:56:34.285Z","comments":true,"path":"2022/10/24/Linux系统编程 第八章/","link":"","permalink":"http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E5%85%AB%E7%AB%A0/","excerpt":"","text":"[TOC] Linux系统编程第八章 内存管理8.1 进程地址空间Linux 内核为每个进程维护一个特殊的虚拟地址，从 0 开始。 8.1.1 页和页面调度页大小包括 4K (32 bit)，8K (64 bit)。 每个页面有两种状态： 有效——与物理页或者一些二级存储介质相关联 无效——未分配或使用 8.1.1.1 共享和写时复制虚存中的多个页面可能被映射到同个物理页面。 当一个进程试图写共享页： 内核允许 产生异常，内核进行写时拷贝。 8.1.2 存储器区域内核将某些相同特征（例如读写权限）的页组织成块——段。 每个进程可见的段： 文本段：只读数据——代码、字符串 堆栈段：执行栈 数据段：（heap）动态存储空间，可写。 BSS 段：未被初始化的全局变量 映射文件：C 可链接库，映像文件等。 8.2 动态内存分配malloc() 获取动态内存： 12#include &lt;stdlib.h&gt;void *malloc (size_t size); C 会自动把返回值由 void 指针转变为需要的类型，C++ 不提供这种自动转换。 例子 xmalloc() ： 123456789101112/* like malloc(), but terminates on failure */void *xmalloc (size_t size)&#123; void *p; p = malloc (size); if (!p) &#123; perror (&quot;xmalloc&quot;); exit (EXIT_FAILURE); &#125; return p;&#125; 8.2.1 数组分配元素大小确定，个数不确定，C 提供 calloc() 函数解决这个问题： 12#include &lt;stdlib.h&gt;void *calloc (size_t nr, size_t size); 例子： 1234567891011int *x, *y;x = malloc (50 * sizeof (int));if (!x) &#123; perror (&quot;malloc&quot;); return -1;&#125;y = calloc (50, sizeof (int));if (!y) &#123; perror (&quot;calloc&quot;); return -1;&#125; 以上得到的内存大小是一样的，但 calloc 会用二进制0 进行初始化。 自定义接口： 1234567891011/* like malloc( ), but zeros memory and terminates on failure */void *xmalloc0 (size_t size)&#123; void *p; p = calloc (1, size); if (!p) &#123; perror (&quot;xmalloc0&quot;); exit (EXIT_FAILURE); &#125; return p;&#125; 8.2.2 调整已分配内存大小12#include &lt;stdlib.h&gt;void *realloc (void *ptr, size_t size); 当已有空间无法增加到 size 时，就会另外申请 size 内存并有拷贝操作。 如果 size 为零，效果就会和 ptr 上调用 free() 相同 8.2.3 动态内存的释放动态内存分配，必须被显示释放。 12#include &lt;stdlib.h&gt;void free (void *ptr); ptr 必须是分配函数的返回值，不能用 free() 来释放申请到的部分内存。 memory leak use-after-free 8.2.4 对齐自然对齐：一个变量的地址是它大小的倍数。 8.2.4.1 预对齐内存的分配一般，编译器和 C 库会自动处理对齐问题。 对于页面等更大的边界， POSIX 提供 posix_memalign() 函数进行动态对齐。 12345/* one or the other -- either suffices */#define _XOPEN_SOURCE 600#define _GNU_SOURCE#include &lt;stdlib.h&gt;int posix_memalign (void **memptr, size_t alignment, size_t size); BSD 和 SunOS 提供 valloc() 接口 123#include &lt;malloc.h&gt;void * valloc (size_t size);void * memalign (size_t boundary, size_t size); 优先选择 posix_memalign() 8.2.4.2 其他对齐问题非标准类型的对齐——处理指针和强转时产生错误。 8.3 数据段的管理123#include &lt;unistd.h&gt;int brk (void *end);void * sbrk (intptr_t increment); brk() 会设置数据段的末端地址为 end，sbrk() 将数据段的末端增加 increment 字节并返回更新后的字节。 8.4 匿名存储器映射buddy memory allocation scheme 算法： 划分大小为 2 的幂的块，返回最小符合块。 释放则标记为未使用。 如果相邻分区空闲，则进行合并。 堆顶空闲，使用 brk() 归还内存。 GLIBC —— arena 算法： 维护释放的内存，后续分配使用 使用匿名内存映射管理大分配。 匿名内存映射类似文件映射，但没有对应的文件。 8.4.1 创建匿名存储器映射例子，mmap() 中进行 MAP_ANONYMOUS 设置： 1234567891011void *p;p = mmap (NULL, /* do not care where */ 512 * 1024, /* 512 KB */ PROT_READ | PROT_WRITE, /* read/write */ MAP_ANONYMOUS | MAP_PRIVATE, /* anonymous, private */ -1, /* fd (ignored) */ 0); /* offset (ignored) */if (p == MAP_FAILED) perror (&quot;mmap&quot;);else/* ’p’ points at 512 KB of anonymous memory... */ 调用 munmap() 释放一个匿名映射： 123456int ret;/* all done with ’p’, so give back the 512 KBmapping */ret = munmap (p, 512 * 1024);if (ret) perror (&quot;munmap&quot;); 8.4.2 映射到 &#x2F;dev&#x2F;zero对于没有 MAP_ANONYMOUS 标志的系统，使用 &#x2F;dev&#x2F;zeror 实现了类似的解决方案。 1234567891011121314151617181920212223242526void *p;int fd;/* open /dev/zero for reading and writing */fd = open (&quot;/dev/zero&quot;, O_RDWR);if (fd &lt; 0) &#123; perror (&quot;open&quot;); return -1;&#125;/* map [0,page size) of /dev/zero */p = mmap (NULL, /* do not care where */ getpagesize ( ), /* map one page */ PROT_READ | PROT_WRITE, /* map read/write */ MAP_PRIVATE, /* private mapping */ fd, /* map /dev/zero */ 0); /* no offset */if (p == MAP_FAILED) &#123; perror (&quot;mmap&quot;); if (close (fd)) perror (&quot;close&quot;); return -1;&#125;/* close /dev/zero, no longer needed */if (close (fd)) perror (”close”);/* ’p’ points at one page of memory, use it... */ 8.5 高级存储器分配mallopt() 调用可以用于改变一些内核参数。 M_CHECK_ACTION M_MMAP_MAX 最大存储器映射 M_MMAP_THRESHOLD 使用匿名映射和数据段之间的阈值 M_MXFAST fast bin 的最大大小 M_TOP_PAD 调整数据段使用的填充字节数 需要在调用内存分配函数之前使用 mallopt() 8.5.1 使用 malloc_usable_size() 和 malloc_trim() 进行调优malloc_usable_size() 用来查询已分配块拥有的可用字节数。 12#include &lt;malloc.h&gt;size_t malloc_usable_size (void *ptr); malloc_trim() 允许程序强制 glibc 归还所有的可释放的动态内存给内核： 12#include &lt;malloc.h&gt;int malloc_trim (size_t padding); 它们是不可移植的，且会暴露底层细节。 8.6 调试内存分配程序可以设置 MALLOC_CHECK_ 环境变量来开启存储系统额外的调试功能。 执行如下指令： 1MALLOC_CHECK_=1 ./rudder 8.6.1 获得统计数据Linux 提供 mallinfo() 函数来获得关于动态存储分配系统的统计数据： 12#include &lt;malloc.h&gt;struct mallinfo mallinfo (void); Linux 提供 stats() 函数，将更内存相关的统计数据打印到标准错误输出： 12#include &lt;malloc.h&gt;void malloc_stats (void); 8.7 基于栈的分配使用 alloca() 在栈中实现动态内存分配： 12#include &lt;alloca.h&gt;void * alloca (size_t size);","categories":[],"tags":[]},{"title":"Linux系统编程 第七章","slug":"Linux系统编程 第七章","date":"2022-10-24T12:52:16.828Z","updated":"2022-10-24T12:55:34.099Z","comments":true,"path":"2022/10/24/Linux系统编程 第七章/","link":"","permalink":"http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E4%B8%83%E7%AB%A0/","excerpt":"","text":"[TOC] Linux系统编程第七章 文件与目录管理7.1 文件及其元数据7.1.1 一组 stat 函数123456#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;int stat (const char *path, struct stat *buf);int fstat (int fd, struct stat *buf);int lstat (const char *path, struct stat *buf); 结构 stat 存储了获取的文件信息。 stat() 返回由路径 path 指明的文件信息。 fstat() 返回由 fd 指向的文件信息。 lstat() 类似 stat() 但返回符号链接本身。 例子： 1234567891011121314151617181920#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main (int argc, char *argv[])&#123; struct stat sb; int ret; if (argc &lt; 2) &#123; fprintf (stderr, &quot;˖usage %s &lt;file&gt;\\n&quot;, argv[0]); return 1; &#125; ret = stat (argv[1], &amp;sb); if (ret) &#123; perror (&quot;stat&quot;); return 1; &#125; printf (&quot;%s is %ld bytes\\n&quot;, argv[1], sb.st_size); return 0;&#125; 7.1.2 权限stat() 常用于获取给定文件的权限，使用 chmod() 和 fchmod() 设置权限： 1234#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;int chmod (const char *path, mode_t mode);int fchmod (int fd, mode_t mode); 二者均可设置文件权限为 mode。 调用进程的 euid 必须匹配文件的所有者，或如进程具有 CAP_FOWNER 能力。 例子： 123456789int ret;/** Set ’map.png’ in the current directory to* owner-readable and -writable. This is the* same as ’chmod 600 ./map.png’.*/ret = chmod (&quot;./map.png&quot;, S_IRUSR | S_IWUSR);if (ret) perror (&quot;chmod&quot;); 7.1.3 所有权以下三个系统调用允许用户改变文件的所有者和所属群： 12345#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int chown (const char *path, uid_t owner, gid_t group);int lchown (const char *path, uid_t owner, gid_t group);int fchown (int fd, uid_t owner, gid_t group); chown() 和 lchown() 作用一样，但对于符号链接，lchown() 只改变符号链接文件的所有权。 只有 CAP_CHOWN 能力的进程能改变文件所有者。 文件所有者能改变文件所属组。 例子，用户具备 CAP_CHOWN 能力或用户是文件所有者且在 officers 组中： 12345678910111213141516struct group *gr;int ret;/** getgrnam( ) returns information on a group* given its name.*/gr = getgrnam (&quot;officers&quot;);if (!gr) &#123; /* likely an invalid group */ perror (&quot;getgrnam&quot;); return 1;&#125;/* set manifest.txt’s group to ’officers’ */ret = chown (&quot;manifest.txt&quot;, -1, gr-&gt;gr_gid);if (ret) perror (&quot;chown&quot;); 7.1.4 扩展能力扩展属性与文件系统无关，内核将不同文件系统存储扩展属性的方式从扩展属性接口抽象出来。 7.1.4.1 键和值每个扩展属性对应一个 key，key 采用 namespace.attribute 的形式。 Linux 对键和值没有限制，但文件系统限制了文件关联的所有键和值的总长度。 7.1.4.2 扩展属性命名空间 system 内核特性 （没有用户能访问） security 安全模块（只允许 CAP_SYS_ADMIN 写） trusted 用户空间限制信息（只允许 CAP_SYS_ADMIN 读写） user 普通标准命名空间 7.1.4.3 扩展属性操作定义操作： 获取键值 设置键值 获取键列表 移除属性（键） 每个操作，三种系统调用： 操作路径 操作路径（符号链接本身） 操作 fd 7.2 目录7.2.1 当前工作目录cwd(current work dir) 7.2.1.1 获取当前工作目录getcwd() 会以绝对路径形式获取 cwd： 12#include &lt;unistd.h&gt;char * getcwd (char *buf, size_t size); 例子： 12345678char *cwd;cwd = getcwd (NULL, 0);if (!cwd) &#123; perror (&quot;getcwd&quot;); exit (EXIT_FAILURE);&#125;printf (&quot;cwd = %s\\n&quot;, cwd);free (cwd); Linux 的 C 库也提供函数 get_current_dir_name() ，： 123#define _GNU_SOURCE#include &lt;unistd.h&gt;char * get_current_dir_name (void); 7.2.1.2 更改当前工作目录123#include &lt;unistd.h&gt;int chdir (const char *path);int fchdir (int fd); Unix 没有修改不同进程当前工作目录的机制。 例子： 12345678910111213141516171819202122char *swd;int ret;/* save the current working directory */swd = getcwd (NULL, 0);if (!swd) &#123; perror (&quot;getcwd&quot;); exit (EXIT_FAILURE);&#125;/* change to a different directory */ret = chdir (some_other_dir);if (ret) &#123; perror (&quot;chdir&quot;); exit (EXIT_FAILURE);&#125;/* do some other work in the new directory... *//* return to the saved directory */ret = chdir (swd);if (ret) &#123; perror (&quot;chdir&quot;); exit (EXIT_FAILURE);&#125;free (swd); open打开当前目录，随后调用 fchidir() 的方式开销更小。 7.2.2 创建目录123#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;int mkdir (const char *path, mode_t mode); 在 Linux，新建目录的权限位是（mode &amp; ~ umask &amp; 01777）。 7.2.3 移除目录POSIX 调用 rmdir() 将目录从文件系统层次上移除： 12#include &lt;unistd.h&gt;int rmdir (const char *path); 7.2.4 读取目录内容读取之前，先创建一个 DIR 对象指向的目录流： 123#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;DIR * opendir (const char *name); 目录流比打开目录的文件描述符增加了一些元数据和保存目录内容的缓冲区。 获取目录流的的文件描述符（BSD的扩展）： 1234#define _BSD_SOURCE /* or _SVID_SOURCE */#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;int dirfd (DIR *dir); 7.2.4.1 从目录流读取使用 readdir() 可以获取 dir 指向的下一个目录项： 123#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;struct dirent * readdir (DIR *dir); POSIX 只要求 dirent 结构中的 d_name，若考虑移植性，应只访问 d_name 程序通过连续调用 readdir()，获取目录每个文件，直到目录读完 readdir() 返回 NULL。 7.2.4.2 关闭目录流123#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;int closedir (DIR *dir); 例子，实现在给定目录中搜索指定文件： 1234567891011121314151617181920212223242526/** find_file_in_dir - searches the directory &#x27;path&#x27; for a* file named &#x27;file&#x27;.** Returns 0 if &#x27;file&#x27; exists in &#x27;path&#x27; and a nonzero* value otherwise.*/int find_file_in_dir (const char *path, const char *file)&#123; struct dirent *entry; int ret = 1; DIR *dir; dir = opendir (path); errno = 0; while ((entry = readdir (dir)) != NULL) &#123; if (!strcmp(entry-&gt;d_name, file)) &#123; ret = 0; break; &#125; &#125; if (errno &amp;&amp; !entry) perror (&quot;readdir&quot;); closedir (dir); return ret;&#125; 7.2.4.3 用于读取目录内容的系统调用1234567891011#include &lt;unistd.h&gt;#include &lt;linux/types.h&gt;#include &lt;linux/dirent.h&gt;#include &lt;linux/unistd.h&gt;#include &lt;errno.h&gt;/** Not defined for user space: need to* use the _syscall3( ) macro to access.*/int readdir (unsigned int fd, struct dirent *dirp, unsigned int count);int getdents (unsigned int fd, struct dirent *dirp, unsigned int count); readir() 内部使用，不可移植。 7.3 链接单个 inode 可以由多个名字（同一文件系统）指向。 唯一的限制是用来表示链接树的整数数据类型的范围。 7.3.1 硬链接POSIX 标准使用 link() 为存在文件创建新链接： 12#include &lt;unistd.h&gt;int link (const char *oldpath, const char *newpath); oldpath 和 newpath 均指向同一个文件——无法确知初始链接。 例子： 12345678910int ret;/** create a new directory entry,* &#x27;/home/kidd/privateer&#x27;, that points at* the same inode as &#x27;/home/kidd/pirate&#x27;*/ret = link (&quot;/home/kidd/privateer&quot;, &quot;/home/kidd/pirate&quot;);if (ret) perror (&quot;link&quot;); 7.3.2 符号链接软链接：不增加额外的目录项，而是一种特殊的文件类型——包含指向文件的路径名。 运行时，内核用指向文件路径名代替 symlinks 的路径名（除了”l”开头的系统调用）。 软连接可以指向一切位置（不存在的文件）。区别于硬链接，它可以跨越文件系统。 symlink() 系统调用创建指向 oldpath 的符号链接 newpath。 12#include &lt;unistd.h&gt;int symlink (const char *oldpath, const char *newpath); 12345678910int ret;/** create a symbolic link,* &#x27;/home/kidd/privateer&#x27;, that* points at &#x27;/home/kidd/pirate&#x27;*/ret = symlink (&#x27;/home/kidd/privateer&#x27;, &#x27;/home/kidd/pirate&#x27;);if (ret) perror (&quot;symlink&quot;); 7.3.3 解除链接unlink() 从文件系统移除路径名，如果链接计数清零则会删除文件（不会移除目录）： 12#include &lt;unistd.h&gt;int unlink (const char *pathname); 为了简化对各种类型的删除，C 语言提供函数 remove()： 12#include &lt;stdio.h&gt;int remove (const char *path); 7.4 复制和移动文件7.4.1 复制需要独立实现。 7.4.2 移动POSIX 对于多文件和目录操作都支持： 12#include &lt;stdio.h&gt;int rename (const char *oldpath, const char *newpath); 调用 rename() 将路径名 oldpath 重命名为 newpath。文件内容和 inode 保持不变 oldpath 和 newpath 必须位于同一文件系统。 mv 等工具必须通过一次调用复制和解除链接来完成这个操作。 7.5 设备节点设备节点是应用程序和设备驱动交互的特殊文件。 应用发起请求 &gt;&gt; 内核转交给设备驱动 &gt;&gt; 驱动处理并返回结果 每个设备节点都有两个属性——主设备号和次设备号。 7.5.1 特殊设备节点 空设备 &#x2F;dev&#x2F;null 主 1 次 3，忽略写，读返回 EOF 零设备 &#x2F;dev&#x2F;zero 主 1 次 5，忽略写，读返回 null 满设备 &#x2F;dev&#x2F;full 主 1 次 7，写报错，读返回 null， 7.5.2 随机数生成器内核的随机数生成器位于 &#x2F;dev&#x2F;random 和 &#x2F;dev&#x2F;urandom。 主设备号为1，次设备号分别是 8 和 9。 7.6 带外通信使用 ioctl() 可以进行带外通信： 12#include &lt;sys/ioctl.h&gt;int ioctl (int fd, int request, ...); 例子，使用 CDROMEJECT 请求，弹出光盘： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/cdrom.h&gt;#include &lt;stdio.h&gt;int main (int argc, char *argv[])&#123; int fd, ret; if (argc &lt; 2) &#123; fprintf (stderr, &quot;usage: %s &lt;device to eject&gt;\\n&quot;, argv[0]); return 1; &#125; /* * Opens the CD-ROM device, read-only. O_NONBLOCK * tells the kernel that we want to open the device * even if there is no media present in the drive. */ fd = open (argv[1], O_RDONLY | O_NONBLOCK); if (fd &lt; 0) &#123; perror (&quot;open&quot;); return 1; &#125; /* Send the eject command to the CD-ROM device. */ ret = ioctl (fd, CDROMEJECT, 0); if (ret) &#123; perror (&quot;ioctl&quot;); return 1; &#125; ret = close (fd); if (ret) &#123; perror (&quot;close&quot;); return 1; &#125; return 0;&#125; 7.7 监视文件事件Linux 提供监视文件接口 inotify 监控文件的移动，读写或删除。 7.7.1 初始化 inotify初始化实例指向的文件描述符： 12#include &lt;inotify.h&gt;int inotify_init (void); 7.7.2 监视watch descriptor —— 由 Unix Path 和 监视掩码（监视操作）组成。 inotify 可以监视目录，但不包括递归子目录。 7.7.2.1 增加新监视inotify_add_watch() 在 path 上增加监视事件（mask）。 12#include &lt;inotify.h&gt;int inotify_add_watch (int fd, const char *path, uint32_t mask); 7.7.2.2 监视掩码7.7.3 inotify 事件使用 inotify_event 来描述监视事件。 123456789#include &lt;inotify.h&gt;struct inotify_event &#123; int wd; /* watch descriptor */ uint32_t mask; /* mask of events */ uint32_t cookie; /* unique cookie */ uint32_t len; /* size of ’name’ field */ char name[]; /* null-terminated name */&#125;; 在计算下个inotify_event 结构的偏移是，必须使用 len。 cookie 通常用来连接独立和相关事件。 7.7.3.1 读取 inotify 事件123456789101112131415char buf[BUF_LEN]__attribute__((aligned(4)));ssize_t len, i = 0;/* read BUF_LEN bytes&#x27; worth of events */len = read (fd, buf, BUF_LEN);/* loop over every read event until none remain */while (i &lt; len) &#123; struct inotify_event *event = (struct inotify_event *) &amp;buf[i]; printf (&quot;wd=%d mask=%d cookie=%d len=%d dir=%s\\n&quot;, event-&gt;wd, event-&gt;mask, event-&gt;cookie, event-&gt;len, (event-&gt;mask &amp; IN_ISDIR) ? &quot;yes&quot; : &quot;no&quot;); /* if there is a name, print it */ if (event-&gt;len) printf (&quot;name=%s\\n&quot;, event-&gt;name); /* update the index to the start of the next event */ i += sizeof (struct inotify_event) + event-&gt;len;&#125; 通过 select()，poll()，epoll() 进行 I&#x2F;O 多路传输 inotify 事件。 检查事件，应进行按位测试： 123456if (event-&gt;mask &amp; IN_ACCESS) printf (&quot;The file was read from!\\n&quot;);if (event-&gt;mask &amp; IN_UNMOUNTED) printf (&quot;The file’s backing device was unmounted!\\n&quot;);if (event-&gt;mask &amp; IN_ISDIR) printf (&quot;The file is a directory!\\n&quot;); 7.7.3.2 关联 “移动” 事件cookie 非零时，则包含一个将两个事件连接的唯一值。 7.7.4 高级监视选项IN_DONT_FOLLOW 、IN_MASK_ADD 、IN_ONESHOT、IN_ONLYDIR 7.7.5 删除 inotify 监视调用 inotify_rm_watch() 从 inotify 实例中移除监视： 12#include &lt;inotify.h&gt;int inotify_rm_watch (int fd, uint32_t wd); 应用可以用专门 IN_IGNORED 事件处理函数来强化对事件移除处理。 7.7.6 获取事件队列大小在 inotify 实例文件描述符上执行 ioctl 获取： 1234567unsigned int queue_len;int ret;ret = ioctl (fd, FIONREAD, &amp;queue_len);if (ret &lt; 0) perror (&quot;ioctl&quot;);else printf (&quot;%u bytes pending in queue\\n&quot;, queue_len); 返回的是队列的字节大小，而非队列的时间数（ sizeof 计算获取）。 7.7.7 销毁 inotify 实例123456int ret;/* &#x27;fd&#x27; was obtained via inotify_init( ) */ret = close (fd);if (fd == -1) perror (&quot;close&quot;);","categories":[],"tags":[]},{"title":"Linux系统编程 第六章","slug":"Linux系统编程 第六章","date":"2022-10-24T12:52:03.293Z","updated":"2022-10-24T12:54:36.846Z","comments":true,"path":"2022/10/24/Linux系统编程 第六章/","link":"","permalink":"http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E5%85%AD%E7%AB%A0/","excerpt":"","text":"[TOC] Linux系统编程第六章 高级进程管理6.1 进程调度调度器：把有限的处理器资源分配给进程的内核子系统。 时间片：进程在被强占前所允许的时间称为进程时间片。 Linux 实现了抢占式多任务操作系统——要求一个进程停止，处理器允许另一个。 6.1.1 大 O 计法Linux 调度器的实现算法是 O(1) 算法。 6.1.2 时间片Linux 通过动态分配进程时间片，以平衡交互性能和系统吞吐量。 6.1.3 I&#x2F;O 约束进程 Vs. 处理器约束进程处理器约束进程：持续消耗时间片（科学计算，无限循环） I&#x2F;O 约束进程：总是在等待资源的阻塞状态（GUI应用程序） 6.1.4 抢占调度内核会基于所有耗光时间片的进程新的时间片，确保所有进程都运行。 如果没有就绪进程，内核会”运行“空闲进程（idle process）。 6.1.5 线程Linux 内核把线程简化为共享资源的进程。 Linux 线程编程常用 API ”pthreads“。 6.2 让出处理器sched_yield() 允许进程主动让出处理器，如果没有其他就绪进程，让出进程直接恢复。 12#include &lt;sched.h&gt;int sched_yield (void); 6.2.1 合理使用 消费者&#x2F;生产者模型，消费之等待（常用阻塞机制）。 用户线程锁 内核能比独立进程做出更好的全局调度决策，一般不常用该调用。 6.2.2 让出处理器方法的过去和现状2.6 内核之后，调整了算法，防止”乒乓“的不合理情况发生。 6.3 进程优先级优先级：”nice values”。nice 值意味着对系统友好。nice 值越高，优先级越低，时间片越短。 Linux 调度器基于”高优先级程序先运行“的原则进行调度。 6.3.1 nice()nice() 将在现有优先级上增加 inc，并返回新值。 非 root 进程只能降低优先级（增加 inc）。 12#include &lt;unistd.h&gt;int nice (int inc); 6.3.2 getpriority() 和 setpriority()1234#include &lt;sys/time.h&gt;#include &lt;sys/resource.h&gt;int getpriority (int which, int who);int setpriority (int which, int who, int prio); getpriority() 返回指定进程中的最高优先级，setpriority() 将所有进程的优先级都设为”prio“。 12345678910/* get current process&#x27;s priority */int ret;ret = getpriority (PRIO_PROCESS, 0);printf (&quot;nice value is %d\\n&quot;, ret);/* set all process&#x27;s priority to 10 in current process group */int ret;ret = setpriority (PGIO_PGRP, 0, 10);if (ret == -1)perror (&quot;setpriority&quot;); 6.3.3 I&#x2F;O 优先级缺省情况，I&#x2F;O 调度器使用进程友好度决定 I&#x2F;O 优先级。 因此，设置优先级自动改变 I&#x2F;O 优先级。 6.4 处理器亲和度处理器亲和度表明一个进程停留在同一处理器上的可能性。 软亲和度表明了调度器持续调度进程到同一处理器上的自然倾向。 硬亲和度描述了强制内核保证进程到处理器的绑定。 处理器的缓存独立，因此迁移进程会带来缓存效应。 6.4.1 sched_getaffinity() 和 sched_setaffinity()Linux 提供两个系统调用设定和获取进程的硬亲和度。 12345678910#define _GNU_SOURCE#include &lt;sched.h&gt;typedef struct cpu_set_t;size_t CPU_SETSIZE;void CPU_SET (unsigned long cpu, cpu_set_t *set);void CPU_CLR (unsigned long cpu, cpu_set_t *set);int CPU_ISSET (unsigned long cpu, cpu_set_t *set);void CPU_ZERO (cpu_set_t *set);int sched_setaffinity (pid_t pid, size_t setsize, const cpu_set_t *set);int sched_getaffinity (pid_t pid, size_t setsize, const cpu_set_t *set); 例子： 1234567891011121314cpu_set_t set;int ret, i;CPU_ZERO (&amp;set); /* clear all CPUs */CPU_SET (0, &amp;set); /* allow CPU #0 */CPU_CLR (1, &amp;set); /* forbid CPU #1 */ret = sched_setaffinity (0, sizeof (cpu_set_t), &amp;set);if (ret == -1) perror (&quot;sched_setaffinity&quot;);for (i = 0; i &lt; CPU_SETSIZE; i++) &#123; int cpu; cpu = CPU_ISSET (i, &amp;set); printf (&quot;cpu=%i is %s\\n&quot;, i, cpu ? &quot;set&quot; : &quot;unset&quot;);&#125; 6.5 实时系统如果一个系统受到操作期限的支配（任务具有限定时间），称该系统是”实时“的。 特点：逻辑和时序出现出现偏差会引起严重后果的系统。 6.5.1 软硬实时系统软实时系统：各个任务越快越好，不要求限定时间。 硬实时系统：各任务执行无误且准时。 6.5.2 延时，抖动和截止期限延时：刺激发生到响应运行的时间。 抖动：连续事件中间的时间变化 6.5.3 Linux 的实时支持POISX 标准仅仅描述了一些基于优先级的调度策略。 6.5.4 Linux 调度策略和优先级6.5.4.1 ”先进先出“策略只要没有高优先级进程就绪，FIFO 进程就会持续运行。 6.5.4.2 ”轮转“策略类似 FIFO 类型，引入时间片来处理同优先级进程的规则。 6.5.4.3 普通调度策略默认进程，静态优先级为0。 6.5.4.4 批调度策略只在没有其他就绪进程时，才会运行。 6.5.4.5 设置 Linux 调度策略通过 sched_getscheduler() 和 sched_setcheduler() 操作调度策略。 6.5.5 设置调度参数POSIX 定义的 sched_getparam() 和 sched_setparam() 接口可以获取和设置已有调用策略的相关参数。 123456789#include &lt;sched.h&gt;struct sched_param &#123;/* ... */int sched_priority;/* ... */&#125;;int sched_getparam (pid_t pid, struct sched_param *sp);int sched_setparam (pid_t pid, const struct sched_param *sp); 6.5.5.1 错误码6.5.5.2 确定有效优先级的范围Linux 提供两个系统调用来获取优先级范围： 123#include &lt;sched.h&gt;int sched_get_priority_min (int policy);int sched_get_priority_max (int policy); 例子： 1234567891011121314151617181920212223/** set_highest_priority – set the associated pid’s scheduling* priority to the highest value allowed by its current* scheduling policy. If pid is zero, sets the current* process’s priority.** Returns zero on success.*/int set_highest_priority (pid_t pid)&#123; struct sched_param sp; int policy, max, ret; policy = sched_getscheduler (pid); if (policy == -1) return -1; max = sched_get_priority_max (policy); if (max == -1) return -1; memset (&amp;sp, 0, sizeof (struct sched_param)); sp.sched_priority = max; ret = sched_setparam (pid, &amp;sp); return ret;&#125; 程序一般获取系统的最值，然后按1递增（如max-1,max-2），分配给进程 6.5.6 sched_rr_get_interval()在 Linux 上，它可以获取任意进程的时间片长度。 123456#include &lt;sched.h&gt;struct timespec &#123; time_t tv_sec; /* seconds */ long tv_nsec; /* nanoseconds */&#125;;int sched_rr_get_interval (pid_t pid, struct timespec *tp); 例子： 12345678910struct timespec tp;int ret;/* get the current task’s timeslice length */ret = sched_rr_get_interval (0, &amp;tp);if (ret == -1) &#123; perror (&quot;sched_rr_get_interval&quot;); return 1;&#125;/* convert the seconds and nanoseconds to milliseconds */printf (&quot;Our time quantum is %.2lf milliseconds\\n&quot;, (tp.tv_sec * 1000.0f) + (tp.tv_nsec / 1000000.0f)); 6.5.6.1 错误码6.5.7 关于实时进程的一些提醒 开发时，保证高优先级程序存在。 6.5.8 确定性确定性动作：输入相同，动作在相同的事件产生相同结果。 6.5.8.1 数据故障预测和内存锁分页和交换给实时进程带来了很多不确定性。 实时应用往往“通过锁定”或者“硬连接”来将地址空间中的页提前放入物理内存，阻止被交换。 6.5.8.2 CPU 亲和度和实时进程为每个实时进程保留一个处理器，剩余处理器共享使用。 6.6 资源限制Linux 提供两个操作资源限制的系统调用： 12345678#include &lt;sys/time.h&gt;#include &lt;sys/resource.h&gt;struct rlimit &#123; rlim_t rlim_cur; /* soft limit */ rlim_t rlim_max; /* hard limit */&#125;;int getrlimit (int resource, struct rlimit *rlim);int setrlimit (int resource, const struct rlimit *rlim); 内核对进程强制实行软限制，但可被修改。非特权程序不能提升硬限制。 6.6.1 限制列表 RLIMIT_AS 进程地址空间 RLIMIT_CORE 内存转储文件 RLIMIT_CPU 使用的最长 CPU 时间 RLIMIT_DATA 进程数据段和堆大小 RLIMIT_FSIZE 创建文件大小 RLIMIT_LOCKS 文件锁数量（已移除） RLIMIT_MEMLOCK 非 root 程序锁定内存字节数 RLIMIT_MSGQUEUE 在消息队列中非陪的最多字节 RLIMIT_NICE 进程可以降低 nice 值 RLIMIT_NOFILE 打开的最多文件数 RLIMIT_NPROC 允许的最多进程数 RLMIT_RSS 进程驻留在内存中的最多页数 RLIMIT_RTPRIO 最大实时优先级 RLIMIT_SIGPENDING 消息队列中最多信号数 RLIMIT_STACK 栈最大字节长度 6.6.1.1 默认限制约束变量：初始软限制，初始硬限制和系统管理员。 6.6.2 获取和设置资源限制获取例子： 123456789struct rlimit rlim;int ret;/* get the limit on core sizes */ret = getrlimit (RLIMIT_CORE, &amp;rlim);if (ret == -1) &#123; perror (&quot;getrlimit&quot;); return 1;&#125;printf (&quot;RLIMIT_CORE limits: soft=%ld hard=%ld\\n&quot;, rlim.rlim_cur, rlim.rlim_max); 设置： 12345678910struct rlimit rlim;int ret;rlim.rlim_cur = 32 * 1024 * 1024; /* 32 MB */rlim.rlim_max = RLIM_INFINITY; /* leave it alone */ret = setrlimit (RLIMIT_CORE, &amp;rlim);if (ret == -1) &#123; perror (&quot;setrlimit&quot;); return 1;&#125; 6.6.2.1 错误码","categories":[],"tags":[]},{"title":"Linux系统编程 第五章","slug":"Linux系统编程 第五章","date":"2022-10-24T12:51:44.511Z","updated":"2022-10-24T12:54:02.396Z","comments":true,"path":"2022/10/24/Linux系统编程 第五章/","link":"","permalink":"http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E4%BA%94%E7%AB%A0/","excerpt":"","text":"[TOC] Linux系统编程第五章 进程管理5.1 进程 ID进程由 pid 作为唯一标识。 init 是内核运行的第一个进程，pid 为 1。 5.1.1 分配进程 ID缺省情况，PID 最大限制为 32768（16位，向下兼容）。 内核分配 PID 是以严格的线性函数方式进行，保证同一时间 pid 的唯一性。 5.1.2 进程体系创建新进程的称为父进程，新进程称为子进程，ppid 表示父进程 pid。 每个子进程都继承了父进程的用户和组，子进程通常属于其父进程所在的进程组便于通信。 5.1.3 pid_t定义在 &lt;sys&#x2F;types.h&gt; 中，在 Linux 中，通常是 C 语言的 int 类型。 5.1.4 获得进程 ID 和父进程 IDgetpid() 返回调用进程 ID。 123#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t getpid (void); getppid() 返回调用进程的父进程 ID。 123#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t getppid (void); 5.2 运行新进程exec()：载入内存并执行程序映像（运行一个新程序）。 fork()：创建一个新进程。 5.2.1 exec 系列系统调用12#include &lt;unistd.h&gt;int execl (const char *path, const char *arg, ...); execl() 调用将 path 所指路径的映像载入内存，替换当前进程的映像，arg 是第一个参数，省略号代表可变长度的参数列表，以 NULL 结尾。 例子，如果你想编辑 &#x2F;home&#x2F;kidd&#x2F;hooks.txt： 12345int ret;ret = execl (&quot;/bin/vi&quot;, &quot;vi&quot;, &quot;/home/kidd/hooks.txt&quot;, NULL);if (ret == -1) perror (&quot;execl&quot;); 通常 execl() 不会返回，调用会跳转到新程序入口作为结束。错误时返回 -1，并设置 errno。 execl() 改变了进程的一些属性： 挂起信号丢失。 捕捉信号还原为缺省方式。 内存的锁定（第八章）丢失。 线程属性还原为缺省值。 进程的统计信息复位。 与内存相关数据都会丢失，包括映射文件。 通常打开的文件描述符可以继承，但一般都在 exec 调用前关闭文件。 5.2.1.1 其他 exec 系列系统调用123456#include &lt;unistd.h&gt;int execlp (const char *file, const char *arg, ...);int execle (const char *path, const char *arg, ..., char * const envp[]);int execv (const char *path, char *const argv[]);int execvp (const char *file, char *const argv[]);int execve (const char *filename, char *const argv[], char *const envp[]); 字母 l 和 v 分别表示参数是以 list 或者 vector 方式提供的。 字母 p 表示在用户的 PATH 环境变量中寻找可执行文件。 最后的 e 表示会提供给新进程以新的环境变量。 例子，使用 execvp() 来执行 vi： 12345const char *args[] = &#123; &quot;vi&quot;, &quot;/home/kidd/hooks.txt&quot;, NULL &#125;;int ret;ret = execvp (&quot;vi&quot;, args);if (ret == -1) perror (&quot;execvp&quot;); 5.2.1.2 错误返回值成功调用时，exec 不会返回，失败返回 -1，设置 errno 5.2.2 fork() 系统调用创建一个和当前进程映像一样的进程可以通过 fork() ： 123#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t fork (void); 成功的 fork() 返回0，在父进程中 fork() 返回子进程的 pid；失败返回 -1，设置 errno。 父子进程不同处： 父子进程 pid 不同。 子进程 ppid 设置为父进程 pid。 子进程中资源统计信息清零。 挂起信号清除。 文件锁时非继承的。 ”派生加执行“的方式是很常见的。 5.2.2.1 写时复制如果进程要修改自己的资源”副本“，则进行复制并修改复制后的资源，其他进程仍然共享没修改过的资源。 在使用虚拟内存的情况下， Copy-on-write 是以页为基础进行的。 5.2.2.2 vfork123#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t vfork (void); vfork() 会挂起父程序直到子进程终止或者运行新程序，以避免地址空间的按页复制。 实际上，vfork() 只做了一件事：复制内部的内核数据结构。 5.3 终止进程12#include &lt;stdlib.h&gt;void exit (int status); exit() 会执行一些基本的终止步骤，然后通知内核终止进程。 在终止之前，C 语言函数执行以下工作： 以注册的逆序调用 atexit() 或 on_exit() 注册的函数 清空所有已打开的标准 I&#x2F;O 流。 删除由 tmpfile() 创建的所有临时文件。 随后，exit() 调用 _exit() 让内核处理剩余工作。 12#include &lt;unistd.h&gt;void _exit (int status); vfork() 终止进程是，必须使用 _exit()，而不是 exit()。 5.3.1 其他终止进程的方式 main() 函数返回时，编译器会插入 _exit()。 进程收到终止信号，SIGTERM 和 SIGKILL。 进程被内核惩罚性终止（段错误、内存耗尽）。 5.3.2 atexit()atexit() 会把指定函数注册，在进程正常结束时进行调用。 12#include &lt;stdlib.h&gt;int atexit (void (*function)(void)); 函数存储在栈中，调用顺序和注册顺序相反， 以 LIFO 的方式调用。 注册函数不能调用 exit()，否则会引起递归。 例子： 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void out (void)&#123; printf (&quot;atexit( ) succeeded!\\n&quot;);&#125;int main (void)&#123; if (atexit (out)) fprintf(stderr, &quot;atexit( ) failed!\\n&quot;); return 0;&#125; 5.3.3 on_exit()与 atexti() 一样，只是注册的函数原型不同。 12#include &lt;stdlib.h&gt;int on_exit (void (*function)(int , void *), void *arg); 5.3.4 SIGCHLD当一个进程子程序终止时，内核会向其夫程序发送 SIGCHILD 信号。 进程可通过 signal() 或 sigaction() 系统调用来选择处理该信号。 5.4 等待终止的子进程如果子进程在父进程之前结束，内核将子进程设置为一个特殊状态（僵死进程）。 进程只保留最小的概要信息，等待父进程来查询自己的信息，之后消失。 wait() 返回已终止子进程的 pid，或者 -1 表示出错，调用者会阻塞直到子进程终止。 123#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;pid_t wait (int *stauts); status 通常包含一些子进程的附加信息，POSIX 标准提供宏来解释 status： 123456789#include &lt;sys/wait.h&gt;int WIFEXITED (status);int WIFSIGNALED (status);int WIFSTOPPED (status);int WIFCONTINUED (status);int WEXITSTATUS (status);int WTERMSIG (status);int WSTOPSIG (status);int WCOREDUMP (status); 5.4.1 等待特定进程使用 waitpid() 系统调用成功，返回状态改变的进程的 pid，错误时返回 -1，设置 errno。 123#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;pid_t waitpid (pid_t pid, int *status, int options); 5.4.2 其他等待子进程的方法Linux 提供了 waitid()，该调用有更多的选项，并可以获取更详细的信息。 12#include &lt;sys/wait.h&gt;int waitid (idtype_t idtype, id_t id, siginfo_t *infop, int options); 5.4.3 BSD 中的 wait3() 和 wait4()123456#include &lt;sys/types.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/resource.h&gt;#include &lt;sys/wait.h&gt;pid_t wait3 (int *status, int options, struct rusage *rusage);pid_t wait4 (pid_t pid, int *status, int options, struct rusage *rusage); 数字 3 和 4 实际上是指这两个函数分别有三个和四个参数。 wait3() 等待任何子进程改变状态，wait4() 等待有 pid 指定的子进程改变状态。 rsuage参数提供子进程资源的使用情况。 5.4.4 创建并等待一个新进程system() 用于创建新进程并等待它结束。 123#define _XOPEN_SOURCE /* if we want WEXITSTATUS, etc. */#include &lt;stdlib.h&gt;int system (const char *command); 成功时，返回时是执行命令的返回状态；失败时返回 -1。 使用 system() 来运行一个简单的工具程序或 shell 脚本是很常见的。 利用 fork()、exec 系统调用和 waitpid() 实现一个 system() 的例子： 123456789101112131415161718192021222324252627282930/** my_system - synchronously spawns and waits for the command* &quot;/bin/sh -c &lt;cmd&gt;&quot;.** Returns -1 on error of any sort, or the exit code from the* launched process. Does not block or ignore any signals.*/int my_system (const char *cmd)&#123; int status; pid_t pid; pid = fork ( ); if (pid == -1) return -1; else if (pid == 0) &#123; const char *argv[4]; argv[0] = &quot;sh&quot;; argv[1] = &quot;-c&quot;; argv[2] = cmd; argv[3] = NULL; execv (&quot;/bin/sh&quot;, argv); exit (-1); &#125; if (waitpid (pid, &amp;status, 0) == -1) return -1; else if (WIFEXITED (status)) return WEXITSTATUS (status); return -1;&#125; 5.4.5 僵死程序如果父进程在子进程之前结束了，内核会将遍历其所有子进程，并将 init() 设置为父进程。 5.5 用户和组用户 ID 和组 ID 分别用 C 语言的 uid_t 和 gid_t 两个类型表示。 5.5.1 实际用户（组）ID、有效用户（组）ID 和保存设置的用户（组）ID uid（same as gid） desc 实际用户 ID 运行进程的用户 ID（继承父进程） 有效用户 ID 当前进程使用的用户 ID）（权限验证） 保存设置的用户 ID 进程原先的有效用户 ID 有效 ID 用于验证权限。 实际 ID 和保存设置 ID 的作用是允许非 root 进程在用户 ID 之间切换。 5.5.2 改变实际用户（组）ID 和保存设置的用户（组）IDsetuid() 行为： 如果普通用户调用，则将有效 ID 设置为 uid。 如果由有效用户 ID 为0的进程调用，则将real、saved、effective ID 都设置为 uid。 1234#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int setuid (uid_t uid);int setgid (gid_t gid); 5.5.3 改变有效用户和组 IDLinux 提供两个 POSIX 定义函数来改变当前进程的有效用户 ID 和组 ID 的值： 1234#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int seteuid (uid_t euid);int setegid (gid_t egid); 与 setgid() 区别在于，有效 ID 为 0 的进程调用时，setegid() 只会改变有效用户 ID。 5.5.4 BSD 改变用户 ID 和组 ID 的方式1234#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int setreuid (uid_t ruid, uid_t euid);int setregid (gid_t rgid, gid_t egid); 5.5.5 HP-UX 中改变用户 ID 和组 ID 的方式1234#define _GNU_SOURCE#include &lt;unistd.h&gt;int setresuid (uid_t ruid, uid_t euid, uid_t suid);int setresgid (gid_t rgid, gid_t egid, gid_t sgid); 5.5.6 操作用户 ID 组 ID 的首选方法非 root 使用 seteuid()；root 变三种用 setuid()，临时改变 euid 用 seteuid()。 5.5.7 对保存设置的用户 ID 的支持检查 _POSIX_SAVED_IDS 宏。 5.5.8 获取用户 ID 和组 IDread ID : 1234#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;uid_t getuid (void);gid_t getgid (void) effective ID： 1234#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;uid_t geteuid (void);gid_t getegid (void); 5.6 会话和进程组每个进程都属某个进程组，组内可以传递信号。 每个进程组由 pgid 作为唯一标识，且 pgid 就是组长进程 pid。 新用户登陆产生新会话，登陆 shell 作为会话首进程，会话囊括用户所有活动，并分配控制终端。 会话首进程 PID 等于 会话 ID。 进程组分为一个前台进程组和零个或多个后台进程组。 当用户退出终端，向前台进程组所有进程发送 SIGQUIT 信号。 当网络中断，向前台进程组所有进程发送 SIGHUP 信号。 当用户敲入终止键，向前台进程的所有进程发送 SIGINT 信号。 5.6.1 与会话相关的系统调用如果进程不是某个进程组组长，调用 setsid() 会创建新会话，并创建新进程组。 12#include &lt;unistd.h&gt;pid_t setsid (void); 获取当前进程会话 ID： 123#define _XOPEN_SOURCE 500#include &lt;unistd.h&gt;pid_t getsid (pid_t pid); 5.6.2 与进程相关的系统调用setpgid() 将 pid 进程的进程组 ID 设置为 pgid： 123#define _XOPEN_SOURCE 500#include &lt;unistd.h&gt;int setpgid (pid_t pid, pid_t pgid); 通过会话获取进程的进程组 ID： 123#define _XOPEN_SOURCE 500#include &lt;unistd.h&gt;pid_t getpgid (pid_t pid); 5.6.3 废弃的进程组函数5.7 守护进程守护进程在后台运行，不与控制终端关联。 创建守护进程步骤： 调用 fork()，创建新进程（未来的守护进程）。 父进程调用 exit()（保证守护进程不是组长进程）。 调用 setsid()，创建新会话和新进程组（取消关联终端）。 用 chdir() 改变工作目录为根目录。 关闭所有文件描述符。 将 三个标准文件重定向到 &#x2F;dev&#x2F;null 例子： 123456789101112131415161718192021222324252627282930313233#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/fs.h&gt;int main (void)&#123; pid_t pid; int i; /* create new process */ pid = fork ( ); if (pid == -1) return -1; else if (pid != 0) exit (EXIT_SUCCESS); /* create new session and process group */ if (setsid ( ) == -1) return -1; /* set the working directory to the root directory */ if (chdir (&quot;/&quot;) == -1) return -1; /* close all open files--NR_OPEN is overkill, but works */ for (i = 0; i &lt; NR_OPEN; i++) close (i); /* redirect fd’s 0,1,2 to /dev/null */ open (&quot;/dev/null&quot;, O_RDWR); /* stdin */ dup (0); /* stdout */ dup (0); /* stderror */ /* do its daemon thing... */ return 0;&#125; Unix 系统在 C 库中提供 daemon() 函数来简化以上工作： 12#include &lt;unistd.h&gt;int daemon (int nochdir, int noclose); 5.8 总结","categories":[],"tags":[]},{"title":"Linux系统编程 第四章","slug":"Linux系统编程 第四章","date":"2022-10-24T12:51:23.602Z","updated":"2022-10-24T12:53:11.355Z","comments":true,"path":"2022/10/24/Linux系统编程 第四章/","link":"","permalink":"http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E5%9B%9B%E7%AB%A0/","excerpt":"","text":"[TOC] Linux系统编程第四章 高级文件 I&#x2F;O4.1 散布 &#x2F; 聚集 I&#x2F;O散布聚集 I&#x2F;O 是一种可以在单次系统调用中操作多个缓冲区的 I&#x2F;O 方法。 又称向量 I&#x2F;O，第二章提到的可称作线性 I&#x2F;O。 4.1.1 readv() 和 writev()readv() 从 fd 读取 count 个 segment 到 iov 描述的缓冲区中。 12#include &lt;sys/uio.h&gt;ssize_t readv (int fd, const struct iovec *iov, int count); writev() 从 iov 描述的缓冲区中读取 count 个 segment 的数据并写入 fd 中。 12#include &lt;sys/uio.h&gt;ssize_t writev (int fd, const struct iovec *iov, int count); 每个 iovec 结构体描述一个独立的缓冲区，我们称其为 segment 12345#include &lt;sys/uio.h&gt;strcut iovec &#123; void *iov_base; size_t iov_len;&#125;; 一组 segment 的集合称为 vector。 4.1.1.1 返回值成功时返回读写的字节数，出错时返回 -1，设置 errno。 除了返回任何 read() 和 write() 可能返回的错误之外，标准定义两种额外错误。 EINVAL iov_len &gt; SSIZE_MAX EINVAL count &lt; 0 || count &gt; IOV_MAX &#x3D; 1024 4.1.1.2 writev() 示例123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/uio.h&gt;int main () &#123; struct iovec iov[3]; ssize_t nr; int fd, i; char *buf[] = &#123;&quot;The term buccaneer comes from the word boucan.\\n&quot;, &quot;A boucan is a wooden frame used for cooking meat.\\n&quot;, &quot;Buccaneer is the West Indies name for a pirate.\\n&quot; &#125;; fd = open (&quot;buccaneer.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC); if (fd == -1) &#123; perror (&quot;open&quot;); return 1; &#125; /* fill out three iovec structures */ for (i = 0; i &lt; 3; i++) &#123; iov[i].iov_base = buf[i]; iov[i].iov_len = strlen (buf[i]) + 1; &#125; /* with a single call, write them all out */ nr = writev (fd, iov, 3); if (nr == -1) &#123; perror (&quot;writev&quot;); return 1; &#125; printf (&quot;wrote %d bytes\\n&quot;, nr); if (close (fd)) &#123; perror (&quot;close&quot;); return 1; &#125; return 0; &#125; 4.1.1.3 readv() 示例1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/uio.h&gt;int main ()&#123; char foo[48], bar[51], baz[49]; struct iovec iov[3]; ssize_t nr; int fd, i; fd = open (&quot;buccaneer.txt&quot;, O_RDONLY); if (fd == -1) &#123; perror (&quot;open&quot;); return 1; &#125; /* set up our iovec structures */ iov[0].iov_base = foo; iov[0].iov_len = sizeof (foo); iov[1].iov_base = bar; iov[1].iov_len = sizeof (bar); iov[2].iov_base = baz; iov[2].iov_len = sizeof (baz); /* read into the structures with a single call */ nr = readv (fd, iov, 3); if (nr == -1) &#123; perror (&quot;readv&quot;); return 1; &#125; for (i = 0; i &lt; 3; i++) printf (&quot;%d: %s&quot;, i, (char *) iov[i].iov_base); if (close (fd)) &#123; perror (&quot;close&quot;); return 1; &#125; return 0;&#125; 4.1.1.4 实现简单的用户空间实现： 1234567891011121314151617181920#include &lt;unistd.h&gt;#include &lt;sys/uio.h&gt;ssize_t naive_writev (int fd, const struct iovec*iov, int count)&#123; ssize_t ret = 0; int i; for (i = 0; i &lt; count; i++) &#123; ssize_t nr; nr = write (fd, iov[i].iov_base, iov[i].iov_len); if (nr == -1) &#123; ret = -1; break; &#125; ret += nr; &#125; return ret;&#125; Linux 下readv() 和 writev() 作为系统调用实现，在内部使用散布 &#x2F; 聚集 I&#x2F;O。 实际上，内核里的所有 I&#x2F;O 都是向量 I&#x2F;O；read() 和 write() 是只有一个向量的向量 I&#x2F;O。 4.2 Event Poll 接口poll() 和 select() 调用必须遍历所有被监视的 fds，当 fds 数量增加时，性能就会出现瓶颈。 epoll() 使用三个系统调用解决这个问题： 初始化 epoll 上下文 从上下文中加入或删除需要监视的 fds 执行时间等待。 4.2.1 创建一个新的 epoll 实例使用 epoll_create() 创建一个 epoll 上下文： 12#include &lt;sys/epoll.h&gt;int epoll_create (int size); 调用成功返回一个与 epoll 实例关联的 fd（方便后续调用），size 表示一个大概监听 fds 的数目。 出错时，返回 -1，设置 errno： errno desc EINVAL size &lt;&#x3D; 0 ENFILE 系统达到打开文件数的上限 ENOMEM 内存不足 4.2.2 控制 epollepoll_ctl() 可以向指定的 epoll 上下文中加入或删除文件描述符： 12#include &lt;sys/epoll.h&gt;int epoll_ctl (int epfd, int op, int fd, struct epoll_event *event); epoll event 结构体： 123456789struct epoll_event &#123; __u32 events; /* events */ union &#123; void *ptr; int fd; __u32 u32; __u64 u64; &#125; data;&#125;; 调用成功后，将关联 epoll 实例和 epfd。 参数 op 指定对 fd 要进行的操作，op有效值： op desc EPOLL CTL ADD add EPOLL CTL DEL del EPOLL CTL MOD modify event 参数描述 epoll 更具体的行为，结构体中 events 有效值： events desc EPOLLERR 文件出错（默认） EPOLLET 边沿触发 EPOLLHUP 文件挂起（默认） EPOLLIN 未阻塞，可读 EPOLLONESHOT 只监听一次操作 EPOLLOUT 未阻塞，可写 EPOLLPRI 高优带外可读 event_poll 中的 data 字段由用户使用，通过访问 data.fd 可知触发事件的 fd。 成功返回 0，失败返回 -1，设置 errno： errno desc EBADF bad fd EEXIST epfd 已存在 EINVAL epfd 不是一个epoll实例epfd &#x3D; fdop 无效 ENOENT fd 与 epfd 未关联 ENOMEM 内存不足 EPERM fd 不支持 epoll 4.2.3 等待 Epoll 事件epoll_wait() 等待给定 epoll 实例关联的文件描述符上的事件： 123#include &lt;sys/epoll.h&gt;int epoll_wait (int epfd, struct epoll_event *events, int maxevents, int timeout); arg desc epfd epoll 实例 epfd events 触发事件 maxevents 最多触发事件个数 timeout 时限 成功返回事件数目，出错返回 -1，并设置 errno errno desc EBADF epfd 无效 EFAULT 无权限操作 events 指向的内存 EINTR 信号中断 EINVAL epfd 无效，或 maxevents 大于小于0 4.2.4 边沿触发时间和水平触发事件状态：可读 边沿触发：状态改变发生。（即使已经可读，仍等到有东西写入后返回） 水平触发：状态发生时触发。（可读就返回） 4.3 存储映射将文件映射到内存中，通过内存操作文件。 4.3.1 mmap()请求内核将 fd 从 offset 开始的 len 个字节数据映射到内存中。 123#include &lt;sys/mman.h&gt;void * mmap (void *addr, size_t len, int prot, int flags int fd, off_t offset); arg desc addr 内存映射文件最佳地址 prot 访问权限 flags 映射类型和行为 映射后，文件描述符引用计数会增加。 4.3.1.1 页大小mmap() 调用操作页，addr 和 offset 必须按页大小对齐。 页大小可以通过三种方式获取： &lt;unistd.h&gt; 的 sysconf (_SC_PAGESIZE)（best choice） &lt;unistd.h 的 getpagesize()（Linux 支持，移植性差） &lt;asm&#x2F;pages.h&gt; 中 的宏定义 PAGE_SIZE（编译时确定，移植性差） 4.3.1.2 返回值和错误码成功返回映射区地址；失败时，返回 MAP_FAILED，设置 errno。 4.3.1.3 相关信号 signal desc SIGBUS 访问映射区无效。如文件映射后截短 SIGSEGV 映射区只读不可写。 4.3.2 munmap()Linux 提供 munmap() 来取消 mmap() 的映射。 munmap() 移除从 addr 开始的进程地址，len 字节长的所有内存映射。 12#include &lt;sys/mman.h&gt;int munmap (void *addr, size_t len); 成功返回 0；失败返回 -1，设置 errno。 4.3.3 存储映射例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;int main (int argc, char *argv[])&#123; struct stat sb; off_t len; char *p; int fd; if (argc &lt; 2) &#123; fprintf (stderr, &quot;usage: %s &lt;file&gt;\\n&quot;, argv[0]); return 1; &#125; fd = open (argv[1], O_RDONLY); if (fd == -1) &#123; perror (&quot;open&quot;); return 1; &#125; if (fstat (fd, &amp;sb) == -1) &#123; perror (&quot;fstat&quot;); return 1; &#125; if (!S_ISREG (sb.st_mode)) &#123; fprintf (stderr, &quot;%s is not a file\\n&quot;, argv[1]); return 1; &#125; p = mmap (0, sb.st_size, PROT_READ, MAP_SHARED, fd, 0); if (p == MAP_FAILED) &#123; perror (&quot;mmap&quot;); return 1; &#125; if (close (fd) == -1) &#123; perror (&quot;close&quot;); return 1; &#125; for (len = 0; len &lt; sb.st_size; len++) putchar (p[len]); if (munmap (p, sb.st_size) == -1) &#123; perror (&quot;munmap&quot;); return 1; &#125; return 0;&#125; 4.3.4 mmap() 的优点 避免用户缓冲区带来的多余的数据拷贝。 直接操作内存，开销小。 多进程映射同一对象到内存中时，数据共享。 用指针定位，无需 lseek()。 4.3.5 mmap() 的缺陷 由于映射页对齐带来的内存页空间浪费。 对于 32 位进程地址空间，大片连续的空内存少。 创建和维护映射以及相关内核数据结构有一定开销。 处理大文件、页对齐文件，mmap() 优势明显。 4.3.6 调整映射的大小Linux （特有）提供 mremap() 来调整映射大小。 mremap() 将 [addr, addr + old_size) 的大小调整为 new_size。 根据大小和设置的 flags {0, MREMAP_MAYMOVE}，内核可以同时移动映射区。 12345#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;void * mremap (void *addr, size_t old_size, size_t new_size, unsigned long flags); 4.3.6.1 返回值和错误码成功返回新区域的指针，失败返回 MAP_FAILED，设置 errno。 glibc 常用 mremap() 实现高效 realloc()，来调整 malloc() 分配的内存。 4.3.7 改变映射内存区域的权限POSIX 定义了 mprotect()，允许程序改变内存区的权限： 12#include &lt;sys/mman.h&gt;int mprotect (const void *addr, size_t len, int prot); prot 值是非累积的。 如果一块可读区域将 mprotect 的 prot值设置为 PROT_WRITE，则调用后为只写。 4.3.7.1 返回值和错误码成功返回 0；失败返回 -1，设置 errno。 4.3.8 使用映射机制同步文件POSIX 提供一个使用存储映射机制并与 fsync() 等价的系统调用： 12#include &lt;sys/mman.h&gt;int msync (void *addr, size_t len, int flags); 调用 msync() 将映射内存修改回写到磁盘中，从而同步映射和被映射文件。 与 write() 不同，内存映射写入由进程直接修改内核页缓存，不经过内核。（待补充） 4.3.8.1 返回值和错误码调用成功返回 0；失败返回 -1，设置 errno。 4.3.9 映射提示为了更好利用映射区域，Linux 提供 madvise() 系统调用，指示内核如何进行操作。 12#include &lt;sys/mman.h&gt;int madvise (void *addr, size_t len, int advice); 程序可以通过 madvise() 来影响预读窗口的大小（设置连续访问或随机访问）。 4.3.9.1 返回值和错误码成功返回 0，失败返回 -1 设置 errno。 4.4 普通文件 I&#x2F;O 提示4.4.1 posix_fadvise()12#include &lt;fcntl.h&gt;int posix_fadvise (int fd, off_t offset, off_t len, int advise); 调用 posix_fadvise() 会给出内核在文件位置范围内操作提示。 如果 len &#x3D; 0，则提示作用于区间 [offset, length of file]。 一般 len 和 offset 都置 0，从而使提示作用到整个文件。 示例——要求内核随机、无序的访问 fd 代表的文件： 1234int ret;ret = posix_fadvise (fd, 0, 0, POSIX_FADV_RANDOM);if (ret == -1) perror (”posix_fadvise”); 4.4.1.1 返回值和错误码调用成功返回 0，失败返回 -1，设置 errno 4.4.2 readahead() 系统调用12#include &lt;fcntl.h&gt;ssize_t readahead (int fd, off64_t offset, size_t count); readahead() 调用将读入 fd 的 [offset, offset + count) 区域到页缓存中。 4.4.2.1 返回值和错误码成功返回 0，失败返回 -1，设置 errno 4.4.3 ”经济实用“的操作提示 读取文件的大部分内容，设置 POSIX_FADV_WILLNEED 要求内核预读文件。 读写了大量数据后，设置 POSIX_FADV_DONTNEED 要求内核丢弃缓冲内容。 进程试图读整个文件时，设置 POSIX_FADV_SEQUENTIAL 要求内核大量预读。 进程试图随机访问文件，设置 POSIX_FADV_RANDOM 告诉内核不进行预读。 4.5 同步，同步及异步操作 synchronous 和 asynchronous 指 I&#x2F;O 操作在返回前是否等待某些事件的返回。 synchronized 和 asynchronized 准确指定了某个事件必须发生（例如写回）。 一个 synchronized 操作要比 synchronous 操作的限制更多也更安全。 4.5.1 异步 I&#x2F;OLinux 实现了 aio，aio 库提供了一系列函数来实现异步 I&#x2F;O 提交以及在完成时收到提示。 12345678910111213141516171819#include &lt;aio.h&gt;/* asynchronous I/O control block */struct aiocb &#123; int aio_filedes; /* file descriptor */ int aio_lio_opcode; /* operation to perform */ int aio_reqprio; /* request priority offset */ volatile void *aio_buf; /* pointer to buffer */ size_t aio_nbytes; /* length of operation */ struct sigevent aio_sigevent; /* signal number and value */ /* internal, private members follow... */&#125;;int aio_read (struct aiocb *aiocbp);int aio_write (struct aiocb *aiocbp);int aio_error (const struct aiocb *aiocbp);int aio_return (struct aiocb *aiocbp);int aio_cancel (int fd, struct aiocb *aiocbp);int aio_fsync (int op, struct aiocb *aiocbp);int aio_suspend (const struct aiocb * const cblist[], int n, const struct timespec *timeout); 4.5.1.1 基于线程的异步 I&#x2F;OLinux 只支持使用 O_DIRECT 标志打开的文件上的 aio。对于普通文件，需要自己实现异步。 以下是使用线程方法，所要完成的任务： 创建一个线程池来处理所有的 I&#x2F;O。 实现将 I&#x2F;O 操作加入工作队列的一系列函数。 使这些函数返回唯一的 I&#x2F;O 描述符，来区分相关的 I&#x2F;O 操作。每个工作线程响应队列首的 I&#x2F;O 请求，提交到内核，等待他们完成。 完成后，把操作的结果加入到一个结果队列中。 实现一些列从结果队列中获取状态信息的函数，使用最初返回的 I&#x2F;O 描述符区分每个操作。 以上与 aio 相关函数行为相近，但增加了线程管理开销。 4.6 I&#x2F;O 调度器和 I&#x2F;O 性能I&#x2F;O 调度器：通过管理请求的顺序和次数，使得磁盘寻道次数和移动距离最小化。 4.6.1 磁盘寻址CHS 寻址：柱面 （cylinders）（r），磁头（heads）（z）和扇区（section）（θ） LBA 寻址：硬盘驱动转换块号（物理块）到正确的 CHS 地址。 文件系统操作单元是逻辑块，逻辑块映射到一个或多个硬盘物理块。 4.6.2 调度器的功能I&#x2F;O 调度器实现两个基本操作：合并（两个或多个相邻请求）和排序（块号递增排序）。 4.6.3 改进读请求由于存在读延迟问题，简单地插入处理请求会使排位靠后的读请求出现”饿死“，极大影响性能。 4.6.3.1 Deadline I&#x2F;O 调度器加入 FIFO 队列区分读写请求，并为读请求赋予更小的过期事件。 4.6.3.2 Anticipatory I&#x2F;O 调度器在 Deadline I&#x2F;O 的基础上增加预测机制： ​ 调度后等待 6ms ，若又产生了对磁盘同部分的读请求，则响应。 4.6.3.3. CFQ I&#x2F;O 调度器为每个进程的队列分配时间片，使用轮转方式处理队列请求，直到时间片耗尽或所有请求处理完毕。 如果所有请求处理完了，调度器会空转一段时间，等待新请求。如果预测成功，则处理新请求；否则处理下个进程的队列请求。 CFQ 调度器适合高负载情况，并且是第一选择。 4.6.3.4 Noop I&#x2F;O 调度器最简单的调度器，一般用在无需对请求排队的特殊设备中。 4.6.4 选择和配置你的 I&#x2F;O 调度器例如，设置设备 hda 的 I&#x2F;Q 调度程序为 CFQ 1#echo cfq &gt; /sys/block/hda/queue/scheduler 4.6.5 优化 I&#x2F;O 性能4.6.5.1 用户空间 I&#x2F;O 调度如果应用会产生大量读写请求，最好在提交前进行排序，避免性能损耗。 可处理的排序方式： 完整路径 简单，效率低。原理是同目录下文件在磁盘中相邻分布概率大。 inode 编号 比路径有效就，容易获取和排序，原理是 inode序号通常和物理块挂钩。 文件的物理块 获取文件文件真实的物理块号，接近最优结果。缺点是需要 root 权限。 4.7 结论","categories":[],"tags":[]},{"title":"Linux系统编程 第三章","slug":"Linux系统编程 第三章","date":"2022-10-24T12:50:01.248Z","updated":"2022-10-24T12:51:20.988Z","comments":true,"path":"2022/10/24/Linux系统编程 第三章/","link":"","permalink":"http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E4%B8%89%E7%AB%A0/","excerpt":"","text":"[TOC] Linux系统编程第三章 缓冲输入输出所有的磁盘操作都是基于块进行的。 块操作效率随着系统调用次数的增多而急剧下降。 当请求以块大小整数倍对齐地址时，I&#x2F;O 效率时最理想的。 3.1 用户——缓冲 I&#x2F;O轻量级 I&#x2F;O 请求通常使用用户缓冲 I&#x2F;O 。 用户缓冲 I&#x2F;O 在用户空间完成，它可以在程序中设定，也可以调用标准库透明地执行。 3.1.1 块大小实际应用中，块大小一般是512字节，1024字节，2048字节，或4096字节。 使用用户缓冲 I&#x2F;O，使得程序能操作更小的单位并方便一次写出或读出。 3.1.2 标准 I&#x2F;OC 标准库中提供了标准 I&#x2F;O 库 stdio.h，其中实现了一个跨平台用户缓冲的解决方案。 3.1.3 文件指针FILE 类型，流的概念 3.2 打开文件12#include &lt;stdio.h&gt;FIFE* fopen(const char * path, const char * mode); 成功时，返回一个合法的 FILE 指针。失败时，返回 NULL，设置 errno。 3.2.1 模式rwab + 3.2.2 通过文件描述符打开文件12#include &lt;stdio.h&gt;FILE * fdopen (int fd, const char *mode); mode必须和原来打开文件描述符的模式匹配，且关闭流也会关闭相应的文件描述符。 成功时，返回一个合法的 FILE 指针。失败时，返回 NULL，设置 errno。 3.3 关闭流12#include &lt;stdio.h&gt;int fclose (FILE *stream); 所有被缓冲但没写出的数据会先被写出。 成功时，返回 0。失败时返回 EOF 并设置 errno。 3.3.1 关闭所有的流123#define _GNU_SOURCE#include &lt;stdio.h&gt;int fcloseall(void); 关闭之前,所有的流会被写出。 3.4 从流中读取数据3.4.1 单字节读取12#include &lt;stdio.h&gt;int fgetc(FILE *stream); 读取下一个字符并把该无符号字符强转为 int 返回，报错时返回 EOF。 3.4.2 把字符回放到流中12#include &lt;stdio.h&gt;int ungetc (int c, FILE *stream); 每次调用把 c 强转为一个无符号字符并回放流中。成功时，返回 c；失败时返回 EOF。 3.4.3 按行的读取12#include &lt;stdio.h&gt;char * fgets (char *str, int size, FILE *stream); 从流中读取 size - 1 个字节的数据，遇到 EOF 或 ‘\\n’ 结束读入，并把数组存入 str 中。 ‘\\n’ 会被存入 str 中。 3.4.4 读取任意字符串读取 n-1 个字符到 str中，在任意分隔符 d 处停止读取。 123456789char *s;int c = 0;s = str; while (--n &gt; 0 &amp;&amp; (c = fgetc (stream)) != EOF &amp;&amp; (*s ++ = c) != d) ;if (c == d) *--s = &#x27;\\0&#x27;;else *s = &#x27;\\0&#x27;; 3.4.5 读取二进制文件123#include &lt;stdio.h&gt;size_t fread (void *buf, size_t size, size_t nr, FILE *stream); 从输入流中读取 nr 个数据，每个数据有 size 个字节，并将数据放到 buf 所指向的缓冲区。 返回读入元素的个数，如果返回数小于 nr 说明读取失败或文件结束。 3.5 从流中写数据3.5.1 对齐的讨论3.5.2 写入单个字符与 fgetc() 相对应 fputc() 12#include &lt;stdio.h&gt;int fputc (int c, FILE *stream); 3.5.3 写入字符串12#include &lt;stdio.h&gt;int fputs (const char *str, FILE *stream); fputs() 的调用将 str 指向的字符串的所有非分隔符部分写入 stream 指向的流中。 成功时，fputs() 返回一个非负整数。失败时，返回 EOF。 3.5.4 写入二进制数据与 fread() 对应 fwrite() 12345#include &lt;stdio.h&gt;size_t fwrite (void *buf, size_t size, size_t nr, FILE *stream); 3.5.5 缓冲 I&#x2F;O 示例程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;int main (void) &#123; FILE *in, *out; struct pirate &#123; char name[100]; /* real name */ unsigned long booty; /* in pounds sterling */ unsigned int beard_len; /* in inches */ &#125; p, blackbeard = &#123; &quot;Edward Teach&quot;, 950, 48 &#125;; out = fopen (&quot;data&quot;, &quot;w&quot;); if (!out) &#123; perror (&quot;fopen&quot;); return 1; &#125; if (!fwrite (&amp;blackbeard, sizeof(struct pirate), 1, out)) &#123; perror (&quot;fwrite&quot;); return 1; &#125; if (fclose (out)) &#123; perror (&quot;fclose&quot;); return 1; &#125; in = fopen (&quot;data&quot;, &quot;r&quot;); if (!in) &#123; perror (&quot;fopen&quot;); return 1; &#125; if (!fread (&amp;p, sizeof(struct pirate), 1, in)) &#123; perror (&quot;fwrite&quot;); return 1; &#125; if (fclose (in)) &#123; perror (&quot;fclose&quot;); return 1; &#125; printf (&quot;name=\\&quot;%s\\&quot; booty=%lu beard_len=%u\\n&quot;, p.name, p.booty, p.beard_len); return 0;&#125; 由于变量长度、对齐等不同，不同程序——即使是不同机器上的同一程序——不一定能正确地读取 fwrite() 写入的数据。 3.6 定位流fseek() 函数，标准 I&#x2F;O 最常用的定位函数，操纵流指向文件中由 offset 和 whence 指定的位置。 12#include &lt;stdio.h&gt;int fseek (FILE *stream, long offset, int whence); whence 等价于 lseek() 中的 origin。 fseek() 不返回更新后的位置，返回 0 或 -1 表示成功与否。 fsetpos() 函数，将流的位置设置到 pos 处。 它和将 whence 设置为 SEEK_SET 时的 fseek() 功能一致。 12#include &lt;stdio.h&gt;int fsetpos (FILE *stream, fpos_t *pos); rewind() 函数将位置重置到流的初始位置，并清空错误标记。 12#include &lt;stdio.h&gt;void rewind (FILE *stream); 3.6.1 获得当前流位置ftell() 函数返回当前流的位置。错误时，返回 -1，并设置 errno。 12#include &lt;stdio.h&gt;long ftell (FILE *stream); 选择性的，还有 fgetpos() 函数，用 pos 获取当前流的位置，成功时返回 0。 12#include &lt;stdio.h&gt;int fgetpos (FILE *stream, fpos_t *pos) 3.7 清洗一个流fflush() 函数用来将用户缓冲区写入内核缓冲区，并保证数据都通过 write() 写出。 12#include &lt;stdio.h&gt;int fflush (FILE *stream); 成功时，返回 0 ，失败时，返回 EOF，并设置 errno。 如果需要的话，在调用 fflush() 之后调用 fsync()： ​ 先保证用户缓冲区被写入内核，然后保证内核缓冲区被写入到磁盘中。 3.8 错误和文件结束一些标准的 I&#x2F;O 接口无法区分错误和 EOF 机制，为此提供 ferror() 和 feof()。 ferror() 测试是否在流上设置了错误标志： 12#include &lt;stdio.h&gt;int ferror (FILE *stream); feof() 测试文件结尾标志是否被设置： 12#include &lt;stdio.h&gt;int feof (FILE *stream); clearerr() 清空流错误标志和文件结尾标志： 12#include &lt;stdio.h&gt;void clearerr (FILE *stream); 3.9 获得关联的文件描述符为了获得流的文件描述符，可以使用 fileno() 12#include &lt;stdio.h&gt;int fileno (FILE *stream); 成功时，返回 fd，失败时，它返回 -1。 最好在执行获取文件描述符之前对流进行 flush。 最好永远不要混用 I&#x2F;O 操作。 3.10 控制缓冲 不缓冲 数据直接提交内核 行缓冲 以行为单位执行，每当遇到换行符就提交到内核。（标准输出默认为行缓冲） 块缓冲 适用于文件，默认与文件相关的流都是块缓冲。在标准 I&#x2F;O 中，称为全缓冲。 标准 I&#x2F;O 提供一个用来控制使用缓冲类型的函数： 12345#include &lt;stdio.h&gt;int setvbuf (FILE *stream, char *buf, int mode, size_t size);/* _IONBF 无缓冲 *//* _IOLBF 行缓冲 *//* _IOFBF 块缓冲 */ 除了 _IONBF 情况下 buf 和 size 被忽略，buf 可以被用为指定缓冲区。若 buf 为空，缓冲区则由 glibc 自动分配。 setvbuf() 函数必须在打开流后，执行操作前被调用。 应注意，在流关闭时供其使用的缓冲区必须存在。 3.11 线程安全标准 I&#x2F;O 函数本质上是线程安全的，在单独一个函数调用的上下文中，其操作时原子的。 3.11.1 手动文件加锁flockfile() 会等待流被解锁，然后获得锁，增加锁计数，成为流的所有者线程，然后返回： 12#include &lt;stdio.h&gt;void flockfile (FILE *stream); funlockfile() 减少与流相关的锁的计数： 12#include &lt;stdio.h&gt;void funlockfile (FILE *stream); 如果锁计数器达到了0，当前线程放弃流的所有权，另一个线程现在能获得锁。 ftrylockfile() 是 flockfile() 的非阻塞版本： 12#include &lt;stdio.h&gt;int ftrylockfile (FILE *stream); 如果流加了锁，返回非零值，否则进行相关操作且返回 0。 3.11.2 不加锁流操作12345678910111213#define _GNU_SOURCE#include &lt;stdio.h&gt;int fgetc_unlocked (FILE *stream);char *fgets_unlocked (char *str, int size, FILE *stream);size_t fread_unlocked (void *buf, size_t size, size_t nr, FILE *stream);int fputc_unlocked (int c, FILE *stream);int fputs_unlocked (const char *str, FILE *stream);size_t fwrite_unlocked (void *buf, size_t size, size_t nr, FILE *stream);int fflush_unlocked (FILE *stream);int feof_unlocked (FILE *stream);int ferror_unlocked (FILE *stream);int fileno_unlocked (FILE *stream);void clearerr_unlocked (FILE *stream); 3.12 对标准 I&#x2F;O的批评 fgets() 有时不能满足要求 gets() 太不安全 双副本的性能影响。 3.13 结论","categories":[],"tags":[]},{"title":"Linux系统编程 第二章","slug":"Linux系统编程 第二章","date":"2022-10-24T12:46:05.767Z","updated":"2022-10-24T12:47:48.616Z","comments":true,"path":"2022/10/24/Linux系统编程 第二章/","link":"","permalink":"http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/","excerpt":"","text":"[TOC] Linux系统编程第二章 文件 I&#x2F;O内核为每个进程维护 file table，该表由一些称作 file descriptors 的非负整数进行索引。 子进程默认会获得一份父进程的文件表拷贝。 每个进程按照惯例会至少有三个打开的文件描述符：0，1 和 2，即 stdin、stdout、stderr。 一切皆文件，任何能读写的东西都可以用文件描述符进行访问。 2.1 打开文件2.1.1 open() 系统调用123456#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(const char* name, int flags);int open(const char *name, int flags, mode_t mode); 2.1.1.1 open() 的 flags 参数必须包含以下之一 O_RDONLY | O_WRONLY | O_RDWR 2.1.2 新文件所有者文件所有者的用户 id 就是创建该文件的进程的有效用户 id 大多数 Linux 系统会采纳系统 V 的做法（新文件得到创建进程的组 ID），而保留 BSD 做法（新文件得到上级目录 id） 2.1.3 新文件权限当文件创建时，mode 参数提供新建文件的权限。 实际上，最终写入磁盘的权限位由 mode 参数与 umask 进行按位与后确定。 umask 022 将使 mode 0666 变为 0644(0666 &amp; ~022) 2.1.4 creat() 函数12345#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int creat (const char *name, mode_t mode); 大部分 Linux 架构上，creat() 是一个系统调用： 12345int creat (const char *name, int mode)&#123; return open (name, O_WRONLY | O_CREAT | O_TRUNC, mode);&#125; 2.1.5 返回值和错误码 成功 错误 返回 文件描述符 -1 errno &#x2F; 设置 2.2 用 read() 读取文件123#include &lt;unistd.h&gt;ssize_t read (int fd, void *buf, size_t len); 该系统调用从 fd 指向的文件的当前偏移量至多读 len 个字节到 buf 中。 2.2.1 返回值成功时，将返回写入 buf 中的字节数。出错时返回 -1，并设置 errno。 2.2.2 读入所有的字节123456789101112ssize_t ret;while (len != 0 &amp;&amp; (ret = read (fd, buf, len)) != 0) &#123; if (ret == -1) &#123; if (errno == EINTR) continue; perror(&quot;read&quot;); break; &#125; len -= ret; buf += ret;&#125; 2.2.3 非阻塞读如果给出的文件描述符在非阻塞模式下打开且没有可读数据，read() 调用会返回 -1，且设置 errno 为 EAGAIN open() 中给定 O_NONBLOCK，在非阻塞模式下打开文件 2.2.4 其他错误码2.2.5 read() 大小限制ssize_t 类型是有符号的 size_t 类型（负值用来表示错误）。 size_t 的最大值为 SIZE_MAX；size_t 的最大值为 SSIZE_MAX。 在 32 位系统上，对应的 C 类型一般分别是 unsigned int 和 int。 2.3 用 write() 来写123#include &lt;unistd.h&gt;ssize_t write (int fd, const void *buf, size_t count); 该系统调用从文件描述符 fd 引用文件的当前位置开始，将 buf 中至多 count 个字节写入文件中。 成功时，返回写入字节数，并更新文件位置。错误时，返回 -1，设置 errno。 2.3.1 部分写对于普通文件，除非发生错误，否则 write() 将保证写入所有的请求。 对于其他类型——例如套接字——可以使用循环来保证写入完全。 代码参考 read() 2.3.2 追加模式当 fd 在追加模式打开（通过指定 O_APPEND 参数），写操作从当前文件末尾开始。 追加模式避免了多进程同时写的竞争问题。 2.3.3 非阻塞写当 fd 在非阻塞模式打开（通过指定 O_NONBLOCK 参数），写操作产生阻塞时， write() 系统调用返回 -1，并设置 errno 值为 EAGAIN。 2.3.4 其他错误码2.3.5 write() 大小限制count &lt;&#x3D; SSIZE_MAX 2.3.6 write() 的行为异步 I&#x2F;O：write() -&gt; Linux 内核检查 -&gt; 数据拷贝至缓冲区 -&gt; 内核收集缓冲区并排序，写入磁盘（回写） 为保证数据适时写入，内核创立了一种缓存最大时效机制。 用户可以通过 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_expire_centiseconds 来配置该值。 2.4 同步 I&#x2F;O2.4.1 fsync() 和 fdatasync()123#include &lt;unistd.h&gt;int fsync (int fd); 该调用回写数据以及建立的时间戳和 inode 中的其他属性等元数据。 fd 必须是以写方式打开的。 12#include &lt;unistd.h&gt;int fdatasync(int fd); 工作与 fsync() 类似，区别在于它仅写入数据，不保证元数据同步到磁盘上。 2.4.2 返回值和错误码 errno 描述 EBADF fd 非法 EINVAL fd 对象不支持同步 EIO 底层 I&#x2F;O 错误 2.4.3 sync()123#include &lt;unistd.h&gt;void sync(void); 调用总是成功返回，并确保所有的缓冲——包括数据和元数据——都能写入磁盘*。（磁盘可能撒谎） 对于Linux 来讲，sync() 一定要等到所有的缓冲区都写入才返回。 因此，调用一次 sync() 就够了。 2.4.4 O_SYNC 标志O_SYNC 标志在 open() 中使用，使所有在文件上的 I&#x2F;O 操作同步。（针对写操作，读操作总是同步的） O_SYNC 看起来就像在每个 write() 操作后都隐式执行 fsync()，但 Linux 内核实现的 O_SYNC 会更有效一点。 O_SYNC 会使写操作总耗时增加一到两个数量级。 一般情况下，使用 fsync() 或者 fdatasync() 开销更少。 2.4.5 O_DSYNC 和 O_RSYNCO_DSYNC ：指定在每次写操作后只有普通数据同步。 O_RSYNC ：要求读请求像写请求那样进行同步，配合 O_DSYNC 或 O_SYNC 一起使用 2.5 直接 I&#x2F;O在 open() 中使用 O_DIRECT 标志会使内核最小化 I&#x2F;O 管理的影响。 当使用直接 I&#x2F;O 时，请求长度，缓冲区对齐，和文件偏移必须是设备扇区大小的整数倍。 2.6 关闭文件123#include &lt;unistd.h&gt;int close (int fd); close() 调用解除 fd 关联，并分离进程和文件的关联。 成功返回 0，错误时返回 -1 并设置 errno。 如果文件已经在磁盘上解除链接，但之前仍保持打开，那么它在 close() 之前不会被真的删除。 因此，对 close() 的调用可能会使某个已解除链接的文件最终从磁盘上被删除。 2.6.1 错误码EBADF\\EIO 2.7 用 lseek() 查找1234#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;off_t lseek(int fd, off_t pos, int origin); lseek() 能给 fd 引用的文件位置设定指定值。 调用成功返回新文件位置，错位返回 -1 并设置 errno。 2.7.1 文件末尾之后进行查找读操作：返回 EOF 写操作：在新旧长度之间进行零填充（空洞） 空洞不占用任何物理上的磁盘空间。 带空洞的文件叫做“稀疏文件“。 2.7.2 错误码2.7.3 限制Linux 定义 off_t 为字长，内核将偏移量存储为 C 的 long long 类型。 32 位机器上查找可能产生 EOVERFLOW 错误。 2.8 定位读写Linux 提供 pread() 和 pwrite() 来替代 lseek()。 12345#define _XOPEN_SOURCE 500#include &lt;unistd.h&gt;ssize_t pread (int fd, void *buf, size_t count, off_t pos); 12345#define _XOPEN_SOURCE 500#include &lt;unistd.h&gt;ssize_t pwrite (int fd, const void *buf, size_t count, off_t pos); 在调用完成时，他们不会修改文件位置。 如此，避免了任何在使用 lseek() 时可能出现的潜在竞争（线程）。 2.8.1 错误码2.9截短文件1234#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int ftruncate (int fd, off_t len); 1234#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int truncate (const char *path, off_t len); 两个系统调用都将文件截短到 len 指定的长度。 成功返回 0，错误返回 -1，并设置 errno。 他们也将文件”截短“到比原长度更长，扩展出的字节将全部填充为零。 2.10 I&#x2F;O 多路复用I&#x2F;O 多路复用允许应用在多个文件描述符上同时阻塞，并在其中某个可以读写时收到通知。 Linux 提供三种 I&#x2F;O 多路复用方案：select, poll 和 epoll。 2.10.1 select()1234567891011121314#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);FD_CLR(int fd, fd_set *set); /* oops, remove &#x27;fd&#x27; from the set */FD_ISSET(int fd, fd_set *set); /* &#x27;fd&#x27; is readable without blocking! */FD_SET(int fd, fd_set *set); /* &#x27;add &#x27;fd&#x27; to the set */FD_ZERO(fd_set *set); /* remove all fd from the set */ 指定的集合可能为 NULL，相应的，select() 则不对此类时间进行监视。 如果没有文件描述符处于 I&#x2F;O 就绪状态，select() 调用将在 tv_sec 秒 tv_usec 微秒后返回，每次调用前都必须重新初始化（还有集合中的文件描述符）。 2.10.2 返回值和错误码成功时，返回三个集合中 I&#x2F;O 就绪的文件描述符的数目；错误时返回-1，设置 errno 。 2.10.2.1 select() 示例程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#define TIMEOUT 5 /* select timeout in seconds */#define BUF_LEN 1024 /* read buffer in bytes */int main (void) &#123; strcut timeval v; fd_set readfds; int ret; /* Wait on stdin for input. */ FD_ZERO(&amp;readfds); FD_SET(STDIN_FILENO, &amp;readfds); /* Wait up to five seconds. */ tv.tv_sec = TIMEOUT; tv.tv_usec = 0; /* All right, now block! */ ret = select (STDIN_FILENO + 1, &amp;readfds, NULL, NULL, &amp;tv); if (ret == -1) &#123; perror (&quot;select&quot;); return 1; &#125; else if (!ret) &#123; printf (&quot;%d seconds elapsed.\\n&quot;, TIMEOUT); return 0; &#125; /* * Is our file descriptor ready to read? * (It must be, as it was the only fd that * we provided and the call returned * nonzero, but we will humor ourselves.) */ if (FD_ISSET(STDIN_FILENO, &amp;readfds)) &#123; char buf[BUF_LEN + 1]; int len; /* guaranteed to not block */ len = read (STDIN_FILENO, buf, BUF_LEN); if (len == -1) &#123; perror (&quot;read&quot;); return 1; &#125; if (len) &#123; buf[len] = &#x27;\\0&#x27;; printf (&quot;read: %s\\n&quot;, buf); &#125; return 0; &#125; fprintf (stderr, &quot;This should not happen!\\n&quot;); return 1;&#125; 2.10.2.2 用 select() 实现可移植的sleep()1234567struct timeval tv;tv.tv_sec = 0;tv.tv_userc = 500;/* sleep for 500 microseconds */select (0, NULL, NULL, NULL, &amp;tv); select() 作为一种可移植的微秒级的睡眠机制。 2.10.2.3 pselect()1234567891011121314#define _XOPEN_SOURCE 600#include &lt;sys/select.h&gt;int pselect (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timespec *timeout, const sigset_t *sigmask);FD_CLR(int fd, fd_set *set);FD_ISSET(int fd, fd_set *set);FD_SET(int fd, fd_set *set);FD_ZERO(fd_set *set); pselect() 和 select() 三点不同 timeout 参数采用 timespec 结构，包含秒和纳秒。 timeout 参数后续不用重新初始化 增加 sigmask 参数，当该参数设置为零时，pselect() 的行为等同于 select()。 sigmask 参数用来解决信号和等待文件描述符之间的竞争条件。 2.10.3 poll()123#include &lt;sys/poll.h&gt;int poll (struct pollfd *fds, unsigned int nfds, int timeout); 2.10.3.1 返回值和错误码成功时返回具有非零 revent 字段的文件描述符个数。 失败时返回 -1，errno 被设置。 2.10.3.2 poll() 的例子1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#define TIMEOUT 5 /* poll timeout, in seconds */int main (void)&#123; struct pollfd fds[2]; int ret; /* watch stdin for input */ fds[0].fd = STDIN_FILENO; fds[0].events = POLLIN; /* watch stdout for ability to write (almost always true) */ fds[1].fd = STDOUT_FILENO; fds[1].events = POLLLOUT; /* All set, block! */ ret = poll (fds, 2, TIMEOUT * 1000); if (ret == -1) &#123; perror (&quot;poll&quot;); return 1; &#125; if (!ret) &#123; printf (&quot;%d seconds elapsed.\\n&quot;, TIMEOUT); return 0; &#125; if (fds[0].revents &amp; POLLIN) printf (&quot;stdin is readable\\n&quot;); if (fds[1].revents &amp; POLLOUT) printf (&quot;stdout is writeable\\n&quot;); return 0;&#125; 无须重新构建 pollfd 结构体，必要时内核会把 revents 字段清空。 2.10.3.3 ppoll()Linux 提供了一个 poll() 的近似调用—— ppoll()，timeout 参数和 sigmask 参数参考 pselect()。 1234567#define _GNU_SOURCE#include &lt;sys/poll.h&gt;int ppoll (struct pollfd *fds, nfds_t nfds, const struct timespec *timeout, const sigset_t *sigmask); 2.10.4 poll() 与 select() poll() 在参数的处理更为方便。 (不用重新创建 timeout、fds，fds 处理效率高，不用计算n） select() 的可移植性更强。 epoll() 接口更好，一个 Linux 特有的 I&#x2F;O 多路复用解决方案 2.11 内核内幕2.11.1 虚拟文件系统virtual file switch 是一种 Linux 内核的文件操作的抽象机制。 它允许内核在无需了解文件系统类型的情况下，使用文件系统函数和操作文件系统数据。 VFS 工作于 inode, superblock 和目录条目之上。 read() 系统调用 -&gt; 内核确认 fd 对象类型 -&gt; 内核调用该文件系统的 read() 2.11.2 页缓存页缓存是一种在内存中保存最近在磁盘文件系统上访问过的数据的方式。 Linux 页缓存大小是动态的。一个动态变化的缓存允许 Linux 使用所有的系统内存，并缓存尽可能多的数据。 页缓存是内核寻找文件系统数据的第一目的地。 2.11.3 页回写回写由一些叫做 pdflush 的内核线程操作，且具有并行性。 缓冲区在内核中使用 buffer_head 结构来表示，保存在页缓存中。 2.12 结论","categories":[],"tags":[]},{"title":"Linux系统编程 第一章","slug":"Linux系统编程 第一章","date":"2022-10-24T12:44:45.562Z","updated":"2022-10-24T12:57:29.497Z","comments":true,"path":"2022/10/24/Linux系统编程 第一章/","link":"","permalink":"http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E4%B8%80%E7%AB%A0/","excerpt":"","text":"[TOC] Linux系统编程第 1 章 简介和主要概念1.1 系统编程从传统角度讲，所有的 Unix 编程都是系统级别编程。 1.1.1 系统调用系统调用（syscalls）是为了从操作系统获得服务或者资源而从用户空间向内核发起的函数调用。 1.1.2 调用系统调用基于系统安全和稳定的考虑，用户空间程序禁止直接执行内核的代码或者操作内核数据。 在 i386 上，用户空间程序执行参数为 0x80 的中断指令 int，这个指令触发系统将当前运行环境换到内核的保护区域，内核执行终端处理函数的区域。 1.1.3 C库C库由 GNU libc 提供，简称为 glibc。 除了标准的C库，glibc 还提供了系统调用封装，线程支持和基本应用工具。 1.1.4 C编译器在 Linux 中，标准的C编译器是 gcc GCC——GNU C Compiler 1.2 API 和 ABI1.2.1 APIAPI定义了软件模块之间在源代码层交互的接口。 它通过提供一组标准接口的方式进行抽象：一个程序片段调用另一个程序片段。 API通过C标准来定义且通过C库实现 1.2.2 ABIABI定义的是，在特定的架构上两个或多个软件模块之间的二进制接口。 它定义了一个应用如何和自己交互，如何和内核以及库进行交互。 ABI主要关注的问题有：调用约定、字节序、寄存器使用、系统调用、链接、库行为和二进制格式 1.3 标准POSIX 和 SUS 定义了类 Unix 操作系统接口上的 C API，它们有为各种兼容的类 Unix 系统定义了系统编程 1.3.1 POSIX 和 SUS 的历史1.3.2 C语言标准1999年 ISO C99 1.3.3 Linux 和标准Linux 基本规范（LSB） 扩展了 POSIX 和 SUS，添加了自己的标准。 1.3.4 本书和标准本书仅设计在2.6内核、gcc 4.2编译器和C库（2.5）的 Linux 系统上的进行系统编程的相关知识。 1.4 Linux编程概念1.4.1 文件和文件系统Linux 遵循一切皆是文件的理念。 一个打开的文件通过唯一的文件描述符进行引用，该描述符是打开文件的元数据至其本身的映射。 在 Linux 内核中，这个描述符称为文件描述符，用一个整数表示。 文件描述符在用户程序中共享，允许用户程序用文件描述符直接访问文件。 1.4.2 普通文件一个普通文件包括含以线性字节数组方式组织的数据——字节流。 文件的读写操作，开始于特定字节，指文件位置或者文件偏移量。 文件中间写入字节将覆盖位置偏移量上的值，因此不能以在中间写入内容的方式来扩展文件。 文件的大小通过字节计算，称为文件长度。 截断：通过删除文件结尾部分而截段为稍小的文件。 内核没有对并发文件访问强加限制。 文件通过 inode（信息节点）进行访问，本身不与文件名称关联。 inode 是 Unix 文件系统在磁盘上实际物理对象，也是 Linux 内核中的数据结构的概念实体 1.4.3 目录与链接目录将易读的名字和 inode 编号进行映射，目录本身也有关联的 inode 以形成目录层次。 名字与 inode 的配对称为链接。 目录&gt;&gt;映射集合 链接&gt;&gt;映射 路径解析：用户请求-&gt;内核遍历目录项-&gt;获取下一项 inode 编号-&gt;找到对应 inode 1.4.4 硬链接将不同名字映射到同一个 inode 信息节点的多个连接称为硬链接 inode 包含一个 link count 来跟踪文件系统中指向该文件的硬连接数目。 当 link count 归0后，inode 和它关联的数据才真正删除。 1.4.5 符号链接符号链接（symlink）拥有自己的inode和包含被链接文件完整路径名的数据块。 与硬链接相比，符号链接解析需要更多开销（解析两个文件）。 1.4.6 特殊文件Linux 支持四种类型的特殊文件： 块设备文件（字节数组） 字符设备文件（字节线性队列） 命名管道（通常叫 FIFOs）(进程间通信 IPC 机制) Unix 域套接字( IPC 机制) 1.4.7 文件系统和名字空间Linux 提供全局统一的文件和目录的名字空间。 每个文件系统都要挂载在名字空间中特定的位置，这个位置称为挂载点。 文件系统的根目录可以通过挂载点访问。 1.4.8 进程Linux 内核支持抢占式多任务和虚拟内存，它给进程提供了虚拟处理器和内存的虚拟视图。 通过虚拟内存和分页调度，内核允许多个进程共存在系统上，每个进程操作都有自己的地址空间。 1.4.9 线程线程是进程中的活动单位，包括栈、处理器状态、目标代码的当前位置。 在用户空间，Linux 根据 POSIX1003.1c 实现线程(pthread) 1.4.10 进程体系在 Linux 中，进程树以第一个进程（init）为根，新进程通过 fork() 系统调用创建。 进程终止，内核将在内存中保存进程的部分内容，允许父进程查询该进程终止的状态。 已终止，但父进程尚未获知其状态的进程，称为僵尸进程（zombie） 1.4.11 用户和组在 Linux 内核中，uid是用户的唯一标识。用户名和对应 id 存储在 &#x2F;etc&#x2F;passwd 中。 登陆过程中，login(1)程序处理用户名和密码。若无误，login(1) 将根据 &#x2F;etc&#x2F;passwd 为用户生成 login shell uid 0 是 root 的用户 id。 1.4.12 权限每一个文件都一个所有者，所属组以及权限位集。 文件所有者和权限信息存储在文件的inode中 1.4.13 信号信号是一种单向异步通知机制，用于通知进程发生某种事件，如段错误或者用户输入 Ctrl + C Linux 内核实现了大约30个信号，如 SIGHUP 用于表示终端挂起 1.4.14 进程间通讯Linux 支持的进程间通讯机制包括有 管道 命名管道 信号量 消息队列 共享内存 快速用户空间互斥体 1.4.15 头文件1.4.16 错误处理在系统编程中，错误通常通过函数的返回值表示，并通过特殊的变量 errno 描述。 glibc 对库函数和系统调用的 errno 提供透明支持。 在多线程中，每一个程序都保留了自己的 errno，因此是线程安全的。 1.5 开始系统编程","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-10-24T11:50:50.888Z","updated":"2022-10-24T11:50:50.888Z","comments":true,"path":"2022/10/24/hello-world/","link":"","permalink":"http://aaaris.github.io/2022/10/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}