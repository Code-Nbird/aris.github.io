{"meta":{"title":"aaaris's blog","subtitle":"aaaris' blog","description":"aaaris is talking here.","author":"aaaris","url":"http://aaaris.github.io","root":"/"},"pages":[],"posts":[{"title":"Linux系统编程 第二章","slug":"Linux系统编程 第二章","date":"2022-10-24T12:46:05.767Z","updated":"2022-10-24T12:47:48.616Z","comments":true,"path":"2022/10/24/Linux系统编程 第二章/","link":"","permalink":"http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/","excerpt":"","text":"[TOC] Linux系统编程第二章 文件 I&#x2F;O内核为每个进程维护 file table，该表由一些称作 file descriptors 的非负整数进行索引。 子进程默认会获得一份父进程的文件表拷贝。 每个进程按照惯例会至少有三个打开的文件描述符：0，1 和 2，即 stdin、stdout、stderr。 一切皆文件，任何能读写的东西都可以用文件描述符进行访问。 2.1 打开文件2.1.1 open() 系统调用123456#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(const char* name, int flags);int open(const char *name, int flags, mode_t mode); 2.1.1.1 open() 的 flags 参数必须包含以下之一 O_RDONLY | O_WRONLY | O_RDWR 2.1.2 新文件所有者文件所有者的用户 id 就是创建该文件的进程的有效用户 id 大多数 Linux 系统会采纳系统 V 的做法（新文件得到创建进程的组 ID），而保留 BSD 做法（新文件得到上级目录 id） 2.1.3 新文件权限当文件创建时，mode 参数提供新建文件的权限。 实际上，最终写入磁盘的权限位由 mode 参数与 umask 进行按位与后确定。 umask 022 将使 mode 0666 变为 0644(0666 &amp; ~022) 2.1.4 creat() 函数12345#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int creat (const char *name, mode_t mode); 大部分 Linux 架构上，creat() 是一个系统调用： 12345int creat (const char *name, int mode)&#123; return open (name, O_WRONLY | O_CREAT | O_TRUNC, mode);&#125; 2.1.5 返回值和错误码 成功 错误 返回 文件描述符 -1 errno &#x2F; 设置 2.2 用 read() 读取文件123#include &lt;unistd.h&gt;ssize_t read (int fd, void *buf, size_t len); 该系统调用从 fd 指向的文件的当前偏移量至多读 len 个字节到 buf 中。 2.2.1 返回值成功时，将返回写入 buf 中的字节数。出错时返回 -1，并设置 errno。 2.2.2 读入所有的字节123456789101112ssize_t ret;while (len != 0 &amp;&amp; (ret = read (fd, buf, len)) != 0) &#123; if (ret == -1) &#123; if (errno == EINTR) continue; perror(&quot;read&quot;); break; &#125; len -= ret; buf += ret;&#125; 2.2.3 非阻塞读如果给出的文件描述符在非阻塞模式下打开且没有可读数据，read() 调用会返回 -1，且设置 errno 为 EAGAIN open() 中给定 O_NONBLOCK，在非阻塞模式下打开文件 2.2.4 其他错误码2.2.5 read() 大小限制ssize_t 类型是有符号的 size_t 类型（负值用来表示错误）。 size_t 的最大值为 SIZE_MAX；size_t 的最大值为 SSIZE_MAX。 在 32 位系统上，对应的 C 类型一般分别是 unsigned int 和 int。 2.3 用 write() 来写123#include &lt;unistd.h&gt;ssize_t write (int fd, const void *buf, size_t count); 该系统调用从文件描述符 fd 引用文件的当前位置开始，将 buf 中至多 count 个字节写入文件中。 成功时，返回写入字节数，并更新文件位置。错误时，返回 -1，设置 errno。 2.3.1 部分写对于普通文件，除非发生错误，否则 write() 将保证写入所有的请求。 对于其他类型——例如套接字——可以使用循环来保证写入完全。 代码参考 read() 2.3.2 追加模式当 fd 在追加模式打开（通过指定 O_APPEND 参数），写操作从当前文件末尾开始。 追加模式避免了多进程同时写的竞争问题。 2.3.3 非阻塞写当 fd 在非阻塞模式打开（通过指定 O_NONBLOCK 参数），写操作产生阻塞时， write() 系统调用返回 -1，并设置 errno 值为 EAGAIN。 2.3.4 其他错误码2.3.5 write() 大小限制count &lt;&#x3D; SSIZE_MAX 2.3.6 write() 的行为异步 I&#x2F;O：write() -&gt; Linux 内核检查 -&gt; 数据拷贝至缓冲区 -&gt; 内核收集缓冲区并排序，写入磁盘（回写） 为保证数据适时写入，内核创立了一种缓存最大时效机制。 用户可以通过 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_expire_centiseconds 来配置该值。 2.4 同步 I&#x2F;O2.4.1 fsync() 和 fdatasync()123#include &lt;unistd.h&gt;int fsync (int fd); 该调用回写数据以及建立的时间戳和 inode 中的其他属性等元数据。 fd 必须是以写方式打开的。 12#include &lt;unistd.h&gt;int fdatasync(int fd); 工作与 fsync() 类似，区别在于它仅写入数据，不保证元数据同步到磁盘上。 2.4.2 返回值和错误码 errno 描述 EBADF fd 非法 EINVAL fd 对象不支持同步 EIO 底层 I&#x2F;O 错误 2.4.3 sync()123#include &lt;unistd.h&gt;void sync(void); 调用总是成功返回，并确保所有的缓冲——包括数据和元数据——都能写入磁盘*。（磁盘可能撒谎） 对于Linux 来讲，sync() 一定要等到所有的缓冲区都写入才返回。 因此，调用一次 sync() 就够了。 2.4.4 O_SYNC 标志O_SYNC 标志在 open() 中使用，使所有在文件上的 I&#x2F;O 操作同步。（针对写操作，读操作总是同步的） O_SYNC 看起来就像在每个 write() 操作后都隐式执行 fsync()，但 Linux 内核实现的 O_SYNC 会更有效一点。 O_SYNC 会使写操作总耗时增加一到两个数量级。 一般情况下，使用 fsync() 或者 fdatasync() 开销更少。 2.4.5 O_DSYNC 和 O_RSYNCO_DSYNC ：指定在每次写操作后只有普通数据同步。 O_RSYNC ：要求读请求像写请求那样进行同步，配合 O_DSYNC 或 O_SYNC 一起使用 2.5 直接 I&#x2F;O在 open() 中使用 O_DIRECT 标志会使内核最小化 I&#x2F;O 管理的影响。 当使用直接 I&#x2F;O 时，请求长度，缓冲区对齐，和文件偏移必须是设备扇区大小的整数倍。 2.6 关闭文件123#include &lt;unistd.h&gt;int close (int fd); close() 调用解除 fd 关联，并分离进程和文件的关联。 成功返回 0，错误时返回 -1 并设置 errno。 如果文件已经在磁盘上解除链接，但之前仍保持打开，那么它在 close() 之前不会被真的删除。 因此，对 close() 的调用可能会使某个已解除链接的文件最终从磁盘上被删除。 2.6.1 错误码EBADF\\EIO 2.7 用 lseek() 查找1234#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;off_t lseek(int fd, off_t pos, int origin); lseek() 能给 fd 引用的文件位置设定指定值。 调用成功返回新文件位置，错位返回 -1 并设置 errno。 2.7.1 文件末尾之后进行查找读操作：返回 EOF 写操作：在新旧长度之间进行零填充（空洞） 空洞不占用任何物理上的磁盘空间。 带空洞的文件叫做“稀疏文件“。 2.7.2 错误码2.7.3 限制Linux 定义 off_t 为字长，内核将偏移量存储为 C 的 long long 类型。 32 位机器上查找可能产生 EOVERFLOW 错误。 2.8 定位读写Linux 提供 pread() 和 pwrite() 来替代 lseek()。 12345#define _XOPEN_SOURCE 500#include &lt;unistd.h&gt;ssize_t pread (int fd, void *buf, size_t count, off_t pos); 12345#define _XOPEN_SOURCE 500#include &lt;unistd.h&gt;ssize_t pwrite (int fd, const void *buf, size_t count, off_t pos); 在调用完成时，他们不会修改文件位置。 如此，避免了任何在使用 lseek() 时可能出现的潜在竞争（线程）。 2.8.1 错误码2.9截短文件1234#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int ftruncate (int fd, off_t len); 1234#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int truncate (const char *path, off_t len); 两个系统调用都将文件截短到 len 指定的长度。 成功返回 0，错误返回 -1，并设置 errno。 他们也将文件”截短“到比原长度更长，扩展出的字节将全部填充为零。 2.10 I&#x2F;O 多路复用I&#x2F;O 多路复用允许应用在多个文件描述符上同时阻塞，并在其中某个可以读写时收到通知。 Linux 提供三种 I&#x2F;O 多路复用方案：select, poll 和 epoll。 2.10.1 select()1234567891011121314#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);FD_CLR(int fd, fd_set *set); /* oops, remove &#x27;fd&#x27; from the set */FD_ISSET(int fd, fd_set *set); /* &#x27;fd&#x27; is readable without blocking! */FD_SET(int fd, fd_set *set); /* &#x27;add &#x27;fd&#x27; to the set */FD_ZERO(fd_set *set); /* remove all fd from the set */ 指定的集合可能为 NULL，相应的，select() 则不对此类时间进行监视。 如果没有文件描述符处于 I&#x2F;O 就绪状态，select() 调用将在 tv_sec 秒 tv_usec 微秒后返回，每次调用前都必须重新初始化（还有集合中的文件描述符）。 2.10.2 返回值和错误码成功时，返回三个集合中 I&#x2F;O 就绪的文件描述符的数目；错误时返回-1，设置 errno 。 2.10.2.1 select() 示例程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#define TIMEOUT 5 /* select timeout in seconds */#define BUF_LEN 1024 /* read buffer in bytes */int main (void) &#123; strcut timeval v; fd_set readfds; int ret; /* Wait on stdin for input. */ FD_ZERO(&amp;readfds); FD_SET(STDIN_FILENO, &amp;readfds); /* Wait up to five seconds. */ tv.tv_sec = TIMEOUT; tv.tv_usec = 0; /* All right, now block! */ ret = select (STDIN_FILENO + 1, &amp;readfds, NULL, NULL, &amp;tv); if (ret == -1) &#123; perror (&quot;select&quot;); return 1; &#125; else if (!ret) &#123; printf (&quot;%d seconds elapsed.\\n&quot;, TIMEOUT); return 0; &#125; /* * Is our file descriptor ready to read? * (It must be, as it was the only fd that * we provided and the call returned * nonzero, but we will humor ourselves.) */ if (FD_ISSET(STDIN_FILENO, &amp;readfds)) &#123; char buf[BUF_LEN + 1]; int len; /* guaranteed to not block */ len = read (STDIN_FILENO, buf, BUF_LEN); if (len == -1) &#123; perror (&quot;read&quot;); return 1; &#125; if (len) &#123; buf[len] = &#x27;\\0&#x27;; printf (&quot;read: %s\\n&quot;, buf); &#125; return 0; &#125; fprintf (stderr, &quot;This should not happen!\\n&quot;); return 1;&#125; 2.10.2.2 用 select() 实现可移植的sleep()1234567struct timeval tv;tv.tv_sec = 0;tv.tv_userc = 500;/* sleep for 500 microseconds */select (0, NULL, NULL, NULL, &amp;tv); select() 作为一种可移植的微秒级的睡眠机制。 2.10.2.3 pselect()1234567891011121314#define _XOPEN_SOURCE 600#include &lt;sys/select.h&gt;int pselect (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timespec *timeout, const sigset_t *sigmask);FD_CLR(int fd, fd_set *set);FD_ISSET(int fd, fd_set *set);FD_SET(int fd, fd_set *set);FD_ZERO(fd_set *set); pselect() 和 select() 三点不同 timeout 参数采用 timespec 结构，包含秒和纳秒。 timeout 参数后续不用重新初始化 增加 sigmask 参数，当该参数设置为零时，pselect() 的行为等同于 select()。 sigmask 参数用来解决信号和等待文件描述符之间的竞争条件。 2.10.3 poll()123#include &lt;sys/poll.h&gt;int poll (struct pollfd *fds, unsigned int nfds, int timeout); 2.10.3.1 返回值和错误码成功时返回具有非零 revent 字段的文件描述符个数。 失败时返回 -1，errno 被设置。 2.10.3.2 poll() 的例子1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#define TIMEOUT 5 /* poll timeout, in seconds */int main (void)&#123; struct pollfd fds[2]; int ret; /* watch stdin for input */ fds[0].fd = STDIN_FILENO; fds[0].events = POLLIN; /* watch stdout for ability to write (almost always true) */ fds[1].fd = STDOUT_FILENO; fds[1].events = POLLLOUT; /* All set, block! */ ret = poll (fds, 2, TIMEOUT * 1000); if (ret == -1) &#123; perror (&quot;poll&quot;); return 1; &#125; if (!ret) &#123; printf (&quot;%d seconds elapsed.\\n&quot;, TIMEOUT); return 0; &#125; if (fds[0].revents &amp; POLLIN) printf (&quot;stdin is readable\\n&quot;); if (fds[1].revents &amp; POLLOUT) printf (&quot;stdout is writeable\\n&quot;); return 0;&#125; 无须重新构建 pollfd 结构体，必要时内核会把 revents 字段清空。 2.10.3.3 ppoll()Linux 提供了一个 poll() 的近似调用—— ppoll()，timeout 参数和 sigmask 参数参考 pselect()。 1234567#define _GNU_SOURCE#include &lt;sys/poll.h&gt;int ppoll (struct pollfd *fds, nfds_t nfds, const struct timespec *timeout, const sigset_t *sigmask); 2.10.4 poll() 与 select() poll() 在参数的处理更为方便。 (不用重新创建 timeout、fds，fds 处理效率高，不用计算n） select() 的可移植性更强。 epoll() 接口更好，一个 Linux 特有的 I&#x2F;O 多路复用解决方案 2.11 内核内幕2.11.1 虚拟文件系统virtual file switch 是一种 Linux 内核的文件操作的抽象机制。 它允许内核在无需了解文件系统类型的情况下，使用文件系统函数和操作文件系统数据。 VFS 工作于 inode, superblock 和目录条目之上。 read() 系统调用 -&gt; 内核确认 fd 对象类型 -&gt; 内核调用该文件系统的 read() 2.11.2 页缓存页缓存是一种在内存中保存最近在磁盘文件系统上访问过的数据的方式。 Linux 页缓存大小是动态的。一个动态变化的缓存允许 Linux 使用所有的系统内存，并缓存尽可能多的数据。 页缓存是内核寻找文件系统数据的第一目的地。 2.11.3 页回写回写由一些叫做 pdflush 的内核线程操作，且具有并行性。 缓冲区在内核中使用 buffer_head 结构来表示，保存在页缓存中。 2.12 结论","categories":[],"tags":[]},{"title":"Linux系统编程 第一章","slug":"Linux系统编程 第一章","date":"2022-10-24T12:44:45.562Z","updated":"2022-10-24T12:47:58.967Z","comments":true,"path":"2022/10/24/Linux系统编程 第一章/","link":"","permalink":"http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E4%B8%80%E7%AB%A0/","excerpt":"","text":"[TOC] Linux系统编程第 1 章 简介和主要概念1.1 系统编程从传统角度讲，所有的 Unix 编程都是系统级别编程。 1.1.1 系统调用系统调用（syscalls）是为了从操作系统获得服务或者资源而从用户空间向内核发起的函数调用。 1.1.2 调用系统调用基于系统安全和稳定的考虑，用户空间程序禁止直接执行内核的代码或者操作内核数据。 在 i386 上，用户空间程序执行参数为 0x80 的中断指令 int，这个指令触发系统将当前运行环境换到内核的保护区域，内核执行终端处理函数的区域。 1.1.3 C库C库由 GNU libc 提供，简称为 glibc。 除了标准的C库，glibc 还提供了系统调用封装，线程支持和基本应用工具。 1.1.4 C编译器在 Linux 中，标准的C编译器是 gcc GCC——GNU C Compiler 1.2 API 和 ABI1.2.1 APIAPI定义了软件模块之间在源代码层交互的接口。 它通过提供一组标准接口的方式进行抽象：一个程序片段调用另一个程序片段。 API通过C标准来定义且通过C库实现 1.2.2 ABIABI定义的是，在特定的架构上两个或多个软件模块之间的二进制接口。 它定义了一个应用如何和自己交互，如何和内核以及库进行交互。 ABI主要关注的问题有：调用约定、字节序、寄存器使用、系统调用、链接、库行为和二进制格式 1.3 标准POSIX 和 SUS 定义了类 Unix 操作系统接口上的 C API，它们有为各种兼容的类 Unix 系统定义了系统编程 1.3.1 POSIX 和 SUS 的历史1.3.2 C语言标准1999年 ISO C99 1.3.3 Linux 和标准Linux 基本规范（LSB） 扩展了 POSIX 和 SUS，添加了自己的标准。 1.3.4 本书和标准本书仅设计在2.6内核、gcc 4.2编译器和C库（2.5）的 Linux 系统上的进行系统编程的相关知识。 1.4 Linux编程概念1.4.1 文件和文件系统Linux 遵循一切皆是文件的理念。 一个打开的文件通过唯一的文件描述符进行引用，该描述符是打开文件的元数据至其本身的映射。 在 Linux 内核中，这个描述符称为文件描述符，用一个整数表示。 文件描述符在用户程序中共享，允许用户程序用文件描述符直接访问文件。 1.4.2 普通文件一个普通文件包括含以线性字节数组方式组织的数据——字节流。 文件的读写操作，开始于特定字节，指文件位置或者文件偏移量。 文件中间写入字节将覆盖位置偏移量上的值，因此不能以在中间写入内容的方式来扩展文件。 文件的大小通过字节计算，称为文件长度。 截断：通过删除文件结尾部分而截段为稍小的文件。 内核没有对并发文件访问强加限制。 文件通过 inode（信息节点）进行访问，本身不与文件名称关联。 inode 是 Unix 文件系统在磁盘上实际物理对象，也是 Linux 内核中的数据结构的概念实体 1.4.3 目录与链接目录将易读的名字和 inode 编号进行映射，目录本身也有关联的 inode 以形成目录层次。 名字与 inode 的配对称为链接。 目录&gt;&gt;映射集合 链接&gt;&gt;映射 路径解析：用户请求-&gt;内核遍历目录项-&gt;获取下一项 inode 编号-&gt;找到对应 inode 1.4.4 硬链接将不同名字映射到同一个 inode 信息节点的多个连接称为硬链接 inode 包含一个 link count 来跟踪文件系统中指向该文件的硬连接数目。 当 link count 归0后，inode 和它关联的数据才真正删除。 1.4.5 符号链接符号链接（symlink）拥有自己的inode和包含被链接文件完整路径名的数据块。 与硬链接相比，符号链接解析需要更多开销（解析两个文件）。 1.4.6 特殊文件Linux 支持四种类型的特殊文件： 块设备文件（字节数组） 字符设备文件（字节线性队列） 命名管道（通常叫 FIFOs）(进程间通信 IPC 机制) Unix 域套接字( IPC 机制) 1.4.7 文件系统和名字空间Linux 提供全局统一的文件和目录的名字空间。 每个文件系统都要挂载在名字空间中特定的位置，这个位置称为挂载点。 文件系统的根目录可以通过挂载点访问。 1.4.8 进程Linux 内核支持抢占式多任务和虚拟内存，它给进程提供了虚拟处理器和内存的虚拟视图。 通过虚拟内存和分页调度，内核允许多个进程共存在系统上，每个进程操作都有自己的地址空间。 1.4.9 线程线程是进程中的活动单位，包括栈、处理器状态、目标代码的当前位置。 在用户空间，Linux 根据 POSIX1003.1c 实现线程(pthread) 1.4.10 进程体系在 Linux 中，进程树以第一个进程（init）为根，新进程通过 fork() 系统调用创建。 进程终止，内核将在内存中保存进程的部分内容，允许父进程查询该进程终止的状态。 已终止，但父进程尚未获知其状态的进程，称为僵尸进程（zombie） 1.4.11 用户和组在 Linux 内核中，uid是用户的唯一标识。用户名和对应 id 存储在 &#x2F;etc&#x2F;passwd 中。 登陆过程中，login(1)程序处理用户名和密码。若无误，login(1) 将根据 &#x2F;etc&#x2F;passwd 为用户生成 login shell uid 0 是 root 的用户 id。 1.4.12 权限每一个文件都一个所有者，所属组以及权限位集。 文件所有者和权限信息存储在文件的inode中 1.4.13 信号信号是一种单向异步通知机制，用于通知进程发生某种事件，如段错误或者用户输入 Ctrl + C Linux 内核实现了大约30个信号，如 SIGHUP 用于表示终端挂起 1.4.14 进程间通讯Linux 支持的进程间通讯机制包括有 管道 命名管道 信号量 消息队列 共享内存 快速用户空间互斥体 1.4.15 头文件1.4.16 错误处理在系统编程中，错误通常通过函数的返回值表示，并通过特殊的变量 errno 描述。 glibc 对库函数和系统调用的 errno 提供透明支持。 在多线程中，每一个程序都保留了自己的 errno，因此是线程安全的。 1.5 开始系统编程第二章 文件 I&#x2F;O内核为每个进程维护 file table，该表由一些称作 file descriptors 的非负整数进行索引。 子进程默认会获得一份父进程的文件表拷贝。 每个进程按照惯例会至少有三个打开的文件描述符：0，1 和 2，即 stdin、stdout、stderr。 一切皆文件，任何能读写的东西都可以用文件描述符进行访问。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-10-24T11:50:50.888Z","updated":"2022-10-24T11:50:50.888Z","comments":true,"path":"2022/10/24/hello-world/","link":"","permalink":"http://aaaris.github.io/2022/10/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}