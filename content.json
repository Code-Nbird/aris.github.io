{"meta":{"title":"aaaris's blog","subtitle":"aaaris' blog","description":"aaaris is talking here.","author":"aaaris","url":"http://aaaris.github.io","root":"/"},"pages":[{"title":"link","date":"2022-11-02T10:55:05.000Z","updated":"2022-11-02T10:55:25.194Z","comments":true,"path":"link/index.html","permalink":"http://aaaris.github.io/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-11-02T10:54:11.000Z","updated":"2022-11-02T10:54:26.969Z","comments":true,"path":"tags/index.html","permalink":"http://aaaris.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-11-02T10:54:41.000Z","updated":"2022-11-02T10:54:55.178Z","comments":true,"path":"categories/index.html","permalink":"http://aaaris.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Hugo + GitHub Action 自动部署博客","slug":"Hugo + GitHub Action 自动部署博客","date":"2024-03-14T03:53:10.367Z","updated":"2024-03-14T08:40:30.879Z","comments":true,"path":"2024/03/14/Hugo + GitHub Action 自动部署博客/","link":"","permalink":"http://aaaris.github.io/2024/03/14/Hugo%20+%20GitHub%20Action%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Hugo + GitHub Action 自动部署博客 先前我进行部署博客是使用如下的脚本进行部署： 12345@echo offgit config --global http.proxy http://proxy_addrgit config --global https.proxy https://proxy_addrcd blog_git_local_pathhexo clean&amp;&amp;hexo g&amp;&amp;hexo d 虽谈不上方便，但对于我这样的懒人来说也有不少成本，偶然了解到 Hugo，网上一搜果然发现一些搭建自动部署博客的帖子。","categories":[{"name":"工具","slug":"工具","permalink":"http://aaaris.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"TCPIP网络编程 第四部分","slug":"TCPIP 网络编程/TCPIP 网络编程 第四部分","date":"2022-11-12T10:22:01.065Z","updated":"2022-11-12T11:50:49.476Z","comments":true,"path":"2022/11/12/TCPIP 网络编程/TCPIP 网络编程 第四部分/","link":"","permalink":"http://aaaris.github.io/2022/11/12/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/","excerpt":"","text":"TCP/IP 网络编程 Part 04 结束网络编程 第二十四章 制作 HTTP 服务器 24.1 HTTP 概要 24.1.1 理解 Web 服务器 Web 服务器端的定义： “基于 HTTP 协议，将网页对应文件传输给客户端的服务器端。” 24.1.2 HTTP 下面详细讨论 HTTP 协议： 无状态的 Stateless 协议 服务器端响应客户端请求后立即断开连接，即使同一客户端再次发送请求，服务器端会以相同的方式处理新请求。 为了弥补 HTTP 无法保持连接的缺点，Web 编程中通常会使用 Cookie 和 Session 技术。 请求消息（Request Message）的结构 请求消息可以分为请求行、消息头、消息体等 3 个部分。 请求行含有请求方式信息，消息头包含浏览器信息、用户认证信息等附加信息，消息体中装有客户端向服务器传输的数据。 响应消息（Response Message）的结构 响应消息由状态行、头消息、消息体等三个部分构成。 状态行中含有关于请求的状态消息，消息头中含有传输的数据类型和长度等消息，消息体发送客户端请求的文件数据。 24.2 实现简单的 Web 服务器端 24.2.2 实现基于 Linux 的多线程 Web 服务器端 webserv_linux.c 运行结果： 24.3 习题 第二十五章 进阶内容 25.1 网络编程学习的其他内容 25.1.1 成为网络程序员的前提是成为程序员 25.1.2 编写这些程序时的参考书 25.1.3 后续学习内容 学习系统编程。。。 25.2 网络编程的相关书籍介绍 25.2.1 系统编程相关书籍 《UNIX 环境高级编程》 25.2.2 协议相关书籍 《TCP/IP 详解》（卷1~卷3） 《TCP/IP 协议族》","categories":[{"name":"阅读","slug":"阅读","permalink":"http://aaaris.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"TCPIP网络编程 第二部分","slug":"TCPIP 网络编程/TCPIP 网络编程 第二部分","date":"2022-11-09T15:04:02.308Z","updated":"2022-11-12T10:22:46.639Z","comments":true,"path":"2022/11/09/TCPIP 网络编程/TCPIP 网络编程 第二部分/","link":"","permalink":"http://aaaris.github.io/2022/11/09/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/","excerpt":"","text":"TCP/IP 网络编程 Part 02 基于 Linux 的编程 第十五章 套接字和标准 I/O 15.1 标准 I/O 函数的优点 15.1.1 标准 I/O 函数的两个优点 标准 I/O 函数具有良好的移植性。 标准 I/O 函数可以利用缓冲提高性能（用户缓冲）。 15.1.2 标准 I/O 函数和系统函数之间的性能对比 syscpy.c stdcpy.c 15.1.3 标准 I/O 函数的几个缺点 不容易进行双向通信。（以 r+\\w+\\a+ 模式打开） 有时可能频繁调用 fflush 函数。（切换读写状态应调用 fflush） 需要以 FILE 结构体指针的形式返回文件描述符。（需要将 fd 转化为 FILE 指针） 15.2 使用标准 I/O 函数 15.2.1 利用 fdopen 函数转换为 FILE 结构体指针 fdopen 函数将创建套接字时返回的 fd 转换为标准 I/O 函数中使用的 FILE 结构体指针。 12#include &lt;stdio.h&gt;FILE *fdopen(int fileds, const char *mode); desto.c 15.2.2 利用 fileno 函数转换为文件描述符 12#include &lt;stdio.h&gt;int fileno(FILE* stream); todes.c 15.3 基于套接字的标准 I/O 函数使用 加下来将第四章 echo_server.c 和 echo_client.c 改为基于标准 I/O 函数的数据交换形式。 echo_stdserv.c echo_stdclnt.c 15.4 习题 第十六章 关于 I/O 流分离的其他内容 16.1 分离 I/O 流 16.1.1 两次 I/O 流分离 第一种：“TCP I/O 过程分离”，使用 fork 函数以区分输入和输出使用的文件描述符。（第十章） 第二种：“fdopen 分别创建读写模式 FILE 指针”，分离了输入输出工具。（第十五章） 16.1.2 分离 “流” 的好处 第十五章流分离的目的： 为了将 FILE 指针按读模式和写模式区分。 可以通过区分读写模式降低实现难度。 通过区分 I/O 缓冲提高缓冲性能。 16.1.3 “流” 分离带来的 EOF 问题 症结：第十五章中对任一模式指针调用fclose() 函数完全终止了套接字，而不是半关闭。 示例验证： sep_serv.c sep_clnt.c 16.2 文件描述符的复制和半关闭 16.2.1 终止“流”时无法半关闭的原因 解决方案： 16.2.2 复制文件描述符 此处的复制是在同一进程内完成描述符的复制。 16.2.3 dup &amp; dup2 123#include &lt;unistd.h&gt;int dup(int fildes);int dup2(int fildes, int fildes2); dup.c 16.2.4 复制文件描述后“流”的分离 修改 sep_serv.c 使其能正常工作 : sep_serv2.c “无论复制出多少文件描述符，均应调用 shutdown 函数发送 EOF 并进入半关闭状态。” 16.3 习题 第十七章 优于 select 的 epoll 17.1 epoll 理解及应用 17.1.1 基于 select 的 I/O 复用技术速度慢的原因 不合理设计： 调用 select 函数后常见的针对所有文件描述符的循环语句。 每次调用 select 函数时都需要向该函数传递监视对象消息。 弥补方式： “仅向操作系统传递 1 次监视对象，监视范围或内容发生变化时只通知发生变化的事项。” Linux：epoll Windows: IOCP 17.1.2 select 也有优点 在以下情况，即使在 Linux 平台上 select 也不失为首选： 服务端接入者少。 程序应具有兼容性。 17.1.3 实现 epoll 时必要的函数和结构体 epoll 实现必须的三个函数： epoll_create ：创建保存 epoll 文件描述符的空间。 epoll_ctl ：向空间注册并注销文件描述符。 epoll_wait ：与 select 函数类似，等待文件描述符发生变化。 17.1.4 epoll_create Linux 2.6.8 之后的内核将完全忽略传入 epoll_create 函数的 size 参数，由内核根据情况调整 epoll 例程的大小。 12#include &lt;sys/epoll.h&gt;int epoll_create(int size); 17.1.5 epoll_ctl 12#include &lt;sys/epoll.h&gt;int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event); event 结构体中可以保存的事件类型： 17.1.6 epoll_wait epoll_wait 函数返回发生事件的文件描述符数，同时在第二个参数指向的缓冲中保存发生事件的文件描述符集合。 123#include &lt;sys/epoll.h&gt;int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 17.1.7 基于 epoll 的回声服务器端 echo_epollserv.c 17.2 条件触发和边缘触发 17.2.1 条件触发和边缘触发的区别在于发生事件的时间点 条件触发的特点（输入流可读就通知）： ”条件触发方式中，只要输入缓冲有数据就会一直通知该事件。“ 边缘触发的特点（输入流被写入了才进行通知）： “边缘触发方式中，输入缓冲收到数据时仅注册 1 次该事件。即使输入缓冲中还留有数据，也不会再进行注册。” 17.2.2 掌握条件触发的事件特性 修改之前的echo_epollserv.c，以条件触发方式工作： echo_EPLTserv.c select 模型是条件触发。 17.2.3 边缘触发的服务器端实现中必知的两点 说明： 通过 error 变量验证错误原因 为了完成非阻塞 I/O ，更改套接字特性。 Linux 提供 fctnl 更改或者读取文件属性： 12#include &lt;fcntl.h&gt;int fcntl(int filedes, int cmd, ...); 使用如下语句将文件改为非阻塞模式： 12int flag = fcntl (fd, F_GETFL, 0);fcntl(fd, f_SETFL, flag | O_NONBLOCK); 17.2.4 实现边缘触发的 echo 服务器端 由于边缘触发在接收数据时只注册一次事件，所以一旦发生了输入事件，我们就应该读取输入缓冲的所有数据，因此需要使用 errno 验证输入缓冲是否为空。此外，为防止 read &amp; write 函数长时间阻塞导致服务器停顿，我们改用非阻塞模式。 echo_EPETserv.c 17.2.5 条件触发和边缘触发孰优孰劣 “边缘触发可以分离接收数据和处理数据的时间点！” 即使输入缓冲收到数据，服务器端也能灵活决定读取和处理数据的时间，且承受压力减轻。 17.3 习题 chat_serv.c chat_clnt.c 第十八章 多线程服务器的实现 18.1 理解线程的概念 18.1.1 引入线程的背景 多进程模型的缺点： 创建进程带来的开销。 为了完成进程间数据交换，需要特殊的 IPC 技术。 同时运行多个程序进行大量的”上下文切换“（最大的开销） 引入线程——轻量级进程，以降低以上缺点的影响： 线程的创建和上下文切换比进程的创建和上下文切换更快。 线程间交换数据时无需特殊技术。 18.1.2 线程和进程的差异 线程为了保持多条代码执行流而隔开栈区域，共享数据区和堆。 18.2 线程创建和运行 18.2.1 线程的创建和执行流程 线程具有单独的执行流，因此需要单独定义线程的 main 函数，还需要请求操作系统在单独的执行流中执行该函数： 12345#include &lt;pthread.h&gt; int pthread_create( pthread_t * restrict thread, const pthread_attr_t * restrict attr, void * (* start_routine)(void *), void * restrict arg); 使用示例：thread1.c main返回后整个进程将被销毁： 为防止运行线程被销毁，控制线程执行流，可以使用以下函数，进入等待状态，直到对应 ID 的线程终止： 12#include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void ** status); 示例：thread2.c 18.2.2 可在临界区调用的函数 多个线程同时执行临界区内部分代码时，可能会引发问题。 根据临界区是否引发问题，函数可以分为两类： 线程安全函数 非线程安全函数 在编译时通过添加 -D_REENTRANT 选项，可以自动将标准函数调用改为其线程安全形式的调用。（如 gethostbyname 改为 gethostbyname_r） 18.2.3 工作（Worker）线程模型 工作线程模型示例：创建两个线程，其中一个计算 1 到 5 的和，另一个线程计算 6 到 10 的和，main 函数只负责输出运算结果。 thread3.c 结果虽然正确，但是示例本身在线程中对共享的数据全局变量 sum存在问题，此处存在临界区相关问题，下述示例增加了发生错误的可能性，容易验证产生的错误。 thread4.c 示例中创建 100 个线程，其中一半对全局变量 num 执行加一，剩下一半执行减一操作，理论结果应为 0但运行结果不是 0。 18.3 线程存在的问题和临界区 18.3.1 多个线程访问同一变量是问题 此处的”访问“指的是值的更改，实际上任何内存空间——被同时访问——都有可能发生问题。 下面解释”同时访问“的含义：值的增加需要 CPU 运算完成(99 + 1），随后还要进行值的写回保存(100)。但如果在线程1保存结果(100)之前，线程2通过切换得到了 CPU 资源，如此线程2对线程1运算前的值(99)进行了再运算(99 + 1)并保存(100)后；线程1再次获得 CPU 资源再保存值(100)就会产生问题。 18.3.2 临界区位置 “函数内同时运行多个线程时引起问题的多条语句构成的代码块。” 如 thread4.c 示例中： 两条不同的语句由不同线程同时执行时，也有可能构成临界区。 18.4 线程同步 18.4.1 同步的两面性 需要同步的情况： 同时访问同一内存空间时发生的情况。 需要指定访问同一内存空间的线程执行顺序的情况。（例如线程A写入数据，线程B取走） 18.4.2 互斥量 理解互斥量： A：”请问里面有人吗？“ B：“是的，有人。” 将临界区类比洗手间，洗手间无法容纳多人（类比线程），线程同步中采用锁机制，互斥量就是一把优秀的锁。 下面介绍创建和摧毁互斥量的函数： 123#include &lt;pthread.h&gt;int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t * attr);int pthread_mutex_destroy(pthread_mutex_t *mutex); 以下时利用互斥量上锁或者解锁临界区使用的函数： 1234#include &lt;pthread.h&gt;int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex); 创建互斥量的前提下，可以通过如下结构保护临界区： 如果忘了调用 pthread_mutex_unlock 函数，那么其他使用 pthread_mutex_lock的线程就进行阻塞等待解锁。如此情况，称为死锁。 利用互斥量，修改thread4.c 示例的问题：mutex.c 使用锁时，应”最大限度减少互斥量 lock、unlock 函数的调用次数。” 18.4.3 信号量 信号量与互斥量极为相似，下文阐述利用“二进制信号量”完成“控制线程顺序”为中心的同步方法。 下面给出信号量创建和销毁方法： 123#include &lt;semaphore.h&gt;int sem_init(sem_t *sem, int pshared, unsigned int value);int sem_destroy(sem_t *sem); 接下来介绍信号量中相当于互斥量 lock、unlock的函数。 1234#include &lt;semaphore.h&gt;int sem_post(sem_t *sem);int sem_wait(sem_t *sem); 调用 sem_wait() 函数进入临界区的线程A，其他线程或者自己调用 sem_post 函数前，不允许其他线程进入临界区。 下面介绍关于个控制访问顺序的同步，场景如下： “线程 A 从用户输入得到值后存入全局变量 num ，此时线程 B 将取走该值并累加。该过程共进行 5 次，完成后输出总和并退出程序。” semaphore.c 18.5 线程的销毁和多线程并发服务器端的实现 调用 pthread_join 函数的线程，在目标线程终止前，将进入阻塞。通常使用如下函数引导线程销毁线程创建的内存空间： 12#include &lt;pthread.h&gt;int pthread_detach(pthread_t thread); 18.5.1 多线程并发服务器端的实现 chat_server.c chat_clnt.c 18.6 习题 echo_server.c","categories":[{"name":"阅读","slug":"阅读","permalink":"http://aaaris.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"TCPIP网络编程 第一部分(下)","slug":"TCPIP 网络编程/TCPIP 网络编程 第一部分（下）","date":"2022-11-06T12:50:08.635Z","updated":"2022-11-09T15:01:44.079Z","comments":true,"path":"2022/11/06/TCPIP 网络编程/TCPIP 网络编程 第一部分（下）/","link":"","permalink":"http://aaaris.github.io/2022/11/06/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"TCP/IP 网络编程 Part 01 开始网络编程（下） 第八章 域名及网络地址 8.1 域名系统 DNS 是对 IP 地址和域名进行相互转换的系统，其核心是 DNS 服务器。 8.1.1 什么是域名 一种容易记、易表述的字符串的 IP 地址表示形式。 8.1.2 DNS 服务器 域名是赋予服务端的虚拟地址，而非实际地址，通过向 DNS 服务器请求转换，将域名变为 IP 地址。 若计算机内置 DNS 服务器无法解析，则会询问其他 DNS 服务器，逐级向上传递信息，直到根 DNS 服务器——确定询问的目标服务器，一路向下传递解析请求，得到 IP 地址后原路返回： DNS 就是这样层次化管理的一种分布式数据库系统。 8.2 IP 地址和域名之间的转换 8.2.1 程序中有必要使用域名吗？ 当应用程序有连接到远程服务器的需求时，程序内部如果写入 IP 地址，在后续发生变更时，则需要用户更新应用程序。而一旦注册域名可能永久不变，利用域名编写程序更好一些。 于是，这就要求程序中有 IP 地址和域名之间的转换函数。 8.2.2 利用域名获取 IP 地址 调用 gethostbyname 函数可以通过传递字符串形式的域名获取 IP 地址： 12#include &lt;netdb.h&gt;struct hostent * gethostbyname(const char *hostname); gethostbyname.c h_addr_list 中元素实际保存的是 in_addr 结构体变量地址值而非字符串： 为什么是 char* 而不是 in_addr* : 考虑到通用性， hostent 结构体应也可以保存 IPv6 地址信息： IPv4 &gt;&gt;&gt; in_addr IPv6 &gt;&gt;&gt; in6_addr 该函数实在 void 指针标准化之前定义的。 8.2.3 利用 IP 地址获取域名 12#include &lt;netdb.h&gt;struct hostent* gethostbyaddr(const char *addr, socklen_t len, int family); gethostbyaddr.c 8.3 基于 Windows 的实现 8.4 习题 第九章 套接字的多种可选项 9.1 套接字可选项和 I/O 缓冲大小 9.1.1 套接字多种可选项 实际工作中逐一掌握即可，本书只介绍一部分重要的可选项。 9.1.2 getsockopt &amp; setsockopt 可选项的读取和设置通过如下两个函数完成： 12#include &lt;sys/socket.h&gt;int getsockopt(int sock, int level, int optname, void *optval, socklen_t *optlen); 12#include &lt;sys/socket.h&gt;int setsockopt(int sock, int level, int optname, const void*optval, socklen_t optlen); sock_type.c “套接字类型只能在创建时决定，以后不能再更改。” 9.1.3 SO_SNDBUF &amp; SO_RCVBUF SO_RCVBUF ：输入缓冲大小相关选项。 SO_SNDBUF ：输出缓冲大小相关选项。 示例程序，获取缓冲区大小：get_buf.c 个人电脑上运行的： 示例程序，更改缓冲大小：set_buf.c 个人电脑上运行的，程序将两种缓冲区都设置为 3M 大小： setsockopt() 仅仅是传递设置请求，为保证协议正常进行，系统设置拥有下限大小。 9.2 SO_REUSEADDR 9.2.1 发生地址分配错误（Binding Error） 理解 Time-wait 状态： 这是之前已实现过多次的 echo 服务器端，可以结合第四章 echo 客户端运行： reuseadr_eserver.c 通过如下方式终止程序，即让客户端通知服务端终止程序： “在客户端控制台输入 Q 信息，或通过 CTRL + C 终止程序。” 输入 Q 信息后，客户端调用 close 函数，向服务端发送 FIN 信息并经过四次握手。输入 CTRL + C 终止程序，有操作系统关闭文件及套接字，相当于调用 close 函数，也向服务器发送 FIN 信息。 以上操作，不会出现异常情况，重新运行服务器端也没有问题，但考虑以下方式终止程序： “服务器端和客户端已建立连接的状态下，向服务器端控制台输入 CTRL + C，即强制关闭服务器端。” 以上操作是为了模拟服务器端向客户端发送 FIN 消息的场景。如上方式终止程序后，重启服务器端将产生问题：如果使用同一端口号运行服务器端，将输出 “bind() error” 消息，且无法再次运行。（约3分钟后才能重新运行） 原因在于：先传输 FIN 消息一端，在接收到对方发送的 FIN 消息后（第三次挥手后）会处于 TIME-wait 状态，持续两个周期，以防止发送的 ACK 报文发生丢包情况。 9.2.1 Time-wait 状态 套接字经过四次握手过程后并未立即消除，而是要经过一段时间的 Time-wait 状态。只有先断开连接（先发送 FIN 消息）的主机才经过 Time-wait 状态。 如果客户端先断开连接，客户端套接字也会经过 Time-wait 过程，只不过因为客户端套接字端口是在 connect 函数运行时，由系统动态分配。重新运行客户端不会分配到还在使用的端口，因此无需考虑。 假设没有 Time-wait 状态，主机 A 最后发送的 ACK 报文发生丢失的情况，主机 B 试图重新发送 FIN 报文，但是主机 A 套接字已消除，永远无法接收。那么主机 B 永远无法收到主机 A 最后发送的 ACK 报文。相反，如果 A 处于 Time-wait 状态，则会向主机 B 重传 ACK 报文，这样两个主机的套接字都可以正常清除。 9.2.2 地址再分配 在主机 A 的四次握手过程中，如果最后的 ACK报文数据丢失，则主机 B 会将 FIN 报文进行重传，而重启 Time-wait 计时器。如果网络状态不理想，Time-wait 状态将持续。 解决方案：在套接字的可选项中更改 SO_REUSEADDR 的状态，可将 Time-wait 状态下的套接字端口号重新分配给新的套接字。（去掉 reuseadr_eserver.c 中代码的注释即可） 9.3 TCP_NODELAY 9.3.1 Nagle 算法 Nagle 算法被设计出来为了防止因数据包过多而发生网络过载： “只有收到前一数据的 ACK 消息时，Nagle 算法才发送下一数据。” 9.3.2 禁用 Nagle 算法 “Nagle 算法使用与否在网络流量上差别不大，使用 Nagle 算法的传输速度更慢。” 最典型的是“传输大文件”，文件数据很容易就填满缓冲，不等待 ACK 而连续传输，可以提高传输速度。 只需将套接字可选项 TCP_NODELAY 改为 1 即可禁用 Nagle 算法： 12int opt_val = 1;setsockopt(sock, IPPPROTO_TCP, TCP_NODELAY, (void *)&amp;opt_val, sizeof(opt_val)); 9.4 基于 Windows 的实现 9.5 习题 第十章 多进程服务器端 10.1 进程概念及应用 10.1.1 两种类型的服务器端 按序向第一个客户端到第一百个客户端提供服务： “第一个连接请求的受理时间为 0 秒，第 50 个连接请求的受理时间为 50 秒，第 100 个连接请求的受理时间为 100 秒！但只要受理，服务只需 1 秒钟。” 并发受理所有客户端请求： “所有连接请求的受理时间不超过 1 秒，但平均服务时间为 2 ~ 3 秒。” 10.1.2 并发服务端的实现方法： 即使可能延长服务时间，也有必要改进服务端，使其同时向所有发起请求的客户端提供服务，以提高平均满意度。 下面列出的是具有代表性的并发服务端实现模型方法： 多进程服务器：通过创建多个进程提供服务。 多路复用服务器：通过捆绑并同一管理 I/O 对象提供服务。 多线程服务器：通过生成与客户端等量的线程提供服务。 先讲解第一种：多进程服务器。 10.1.3 理解进程（Process） 进程定义如下： “占用内存空间的正在运行的程序” 10.1.4 进程 ID 操作系统分配给每个进程的唯一标识（大于 2 的整数）。 10.1.5 通过调用 fork 函数创建进程 12#include &lt;unistd.h&gt;pid_t fork(void); fork 函数将创建调用的进程副本，复制正在运行的、调用 fork 函数的进程。 两个进程都将执行 fork 函数调用后的语句，之后的程序执行流根据 fork 的返回值加以区分： 父进程：fork 函数返回子进程 ID。 子进程：fork 函数返回 0。 fork.c 10.2 进程和僵尸进程 10.2.1 僵尸进程 进程执行完 main 函数后未被正常销毁，将变成僵尸进程。 10.2.2 产生僵尸进程的原因 子进程终止的返回值（exit或者 main ）会传递给操作系统，而操作系统不会销毁子进程，直到将值传递给产生父进程。处于这种状态下的进程就是僵尸进程。 父进程主动发起请求时，操作系统才会传递该值，然后才进行僵尸进程的回收。 zombie.c 10.2.3 销毁僵尸进程1：利用 wait 函数 父进程可以使用 wait 函数主动请求获取子进程的返回值。 12#inclue &lt;sys/wait.h&gt;pid_t wait(int * statloc); wait.c 调用 wait 函数时，如果没有已终止的子进程，那么程序将阻塞直到由子进程终止。 10.2.4 销毁僵尸进程2：使用 waitpid 函数 相比 wait 函数可以防止阻塞。 12#include &lt;sys/wait.h&gt;pid_t waitpid(pid_t pid, int *statloc, int options); 传递 WNOHANG 参数，若没有终止的子进程将返回0，以防止阻塞： waitpid.c 10.3 信号处理 10.3.1 向操作系统求助 利用信号处理机制，收到操作系统发送的子进程终止命令信号（SIGCHLD）后，父进程再停下来处理子进程终止。 10.3.2 关于 JAVA 的题外话：保持开放思维 JAVA 为了保持平台移植性，在语言层面支持进程和线程的创建。 10.3.3 信号和 signal 函数 使用 signal 函数进行信号注册。 12#include &lt;signal.h&gt;void (*signal(int signo, void(*func)(int)))(int); 使用 alarm 函数在设定时间后长生 SIGALRM 信号。 12#include &lt;unistd.h&gt;unsigned int alarm(unsigned int seconds); signal.c 产生信号时，为了调用信号处理器，将唤醒由于调用 sleep 函数而进入阻塞状态的进程。 10.3.4 利用 sigaction 函数进行信号处理 sigaction 函数类似于 signal 函数，而且完全可以替代后者，也更加稳定。 123#include &lt;signal.h&gt;int sigaction(int signo, const struct sigaction * act, struct sigaction * oldact); sigaction.c 10.3.5 利用信号处理技术消灭僵尸进程 利用 sigaction 函数为子进程终止时产生的 SIGCHLD 信号注册处理函数： remove_zombie.c 10.4 基于多任务的并发服务器 10.4.1 基于进程的并发服务器模型 每当客户端请求服务时，回声服务器端都创建子进程以提供服务，由如下阶段： 第一阶段：echo 服务端（父进程）通过调用 accept 函数受理连接请求。 第二阶段：此时获取的套接字文件描述符创建并传递给子进程。 第三阶段：子进程利用传递来的文件描述符提供服务。 10.4.2 实现并发服务器 echo_mpserv.c 10.4.3 通过 fork 函数复制文件描述符 只有两个文件描述符都终止后，才能销毁套接字。 10.5 分割 TCP 的 I/O 程序 10.5.1 分割 I/O 程序的优点 分割 I/O 能简化程序的实现：父进程中只需编写接收数据的代码，子进程中只需编写发送数据的代码。 分割 I/O 能提高频繁交换数据的程序性能： 10.5.2 echo 客户端的 I/O 程序分割 echo_mpclient.c 10.6 习题 第十一章 进程间通信 11.1 进程间通信的基本概念 进程间通信意味着两个不同进程间可以交换数据，为了完成这一点，操作系统中应提供两个进程可以同时访问的内存空间。 11.1.1 对进程间通信的基本理解 只要有两个进程可以同时访问的内存空间，就可以通过此空间交换数据。 “如果我有 1 个面包，变量 bread 的值就变为 1。如果吃掉这个面包，bread 值又变回 0。因此，你可以通过变量 bread 值判断我的状态。” 进程具有独立的内存结构，且父子进程是共享内存空间的，因此需要借助其他手段进行进程间通信。 11.1.2 通过管道实现进程间通信 管道并非属于进程的资源，而是和套接字一样，属于操作系统。故两个进程可以通过操作系统提供的内存空间进行通信。 使用 pipe 函数创建管道： 12#include &lt;unistd.h&gt;int pipe(int filedes[2]); 父进程可以调用 fork 函数将入口或出口的一个文件描述符传递给子进程，实现父子进程进行数据交换。 pipe1.c 上述通信方法重点在于，子进程仅用于输入路径，父进程仅用于输出路径： 11.1.3 通过管道进行进程间双向通信 pipe2.c 使用一个管道进行双向通信，程序需要预测并控制运行流程，考虑在不同的系统中，这十分困难。 于是，我们可以使用两个管道避免程序流程的预测或控制： pipe3.c 11.2 运用进程间通信 11.2.1 保存消息的 echo 服务器端 扩展第十章 echo_mpser.c，添加将传输的字符串按顺序保存到文件中的功能： echo_storeserv.c 运行结果不过多赘述。 11.2.2 如果想构建更大型的程序 需要技术，初学者8太行，后面学的模型更容易，但在学习线程前学习进程是必要的。 11.3 习题 第十二章 I/O 复用 12.1 基于 I/O 复用的服务器端 12.1.1 多进程服务器端的缺点和解决方法 缺点：进程创建需要大量的运算和内存空间，进程间通信也需要复杂的方法（IPC）。 解决方案：I/O 复用 12.1.2 理解复用 “为了提供物理设备的效率，用最少的物理要素传递最多数据时使用的技术。” 12.1.3 复用技术在服务器端的应用 I/O 复用服务器端的进程需要确认举手（收到数据）的套接字，并通过举手的套接字接收数据。 12.2 理解 select 函数并实现服务器端 12.2.1 select 函数的功能和调用顺序 使用 select 函数可已将多个文件描述符集中到一起统一监视，监视项目如下： 是否存在套接字接收数据？ 无需阻塞传输数据的套接字有哪些？ 哪些套接字发生了异常？ 12.2.2 设置文件描述符 select 使用 fd_set 数据将多个文件描述符集中到一起，分成不同的监视项，并提供宏完成注册或更改操作。 12.2.3 设置检查（监视）范围及超时 1234567#include &lt;sys/select.h&gt;#include &lt;sys/time.h&gt;int select(int maxfd, fd_set *readset, fd_set * writeset, fd_set * exceptset, const struct timeval * timeout); 通过 maxfd 传递监视对象文件描述符的数量，timeout 超时返回防止阻塞。 12.2.4 调用 select 函数后查看结果 值仍为 1 的位置上的文件描述符发生了变化。 12.2.5 select 函数调用示例 select.c 12.2.6 实现 I/O 复用服务端 echo_selectserv.c 12.3 基于 Windows 的实现 12.4 习题 第十三章 多种 I/O 函数 13.1 send &amp; recv 函数 13.1.1 Linux 中的 send 和 recv 12#include &lt;sys/socket.h&gt;ssize_t send(int sockfd, const void* buf, size_t nbytes, int flags); 12#include &lt;sys/socket.h&gt;ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags); send 函数和 recv 函数最后一个参数时收发数据时的可选项： 下面选取表中一部分介绍： 13.1.2 MSG_OOB ：发送紧急消息 MSG_OOB 用于创建特殊发送方法和通道已发送紧急消息： oob_send.c oob_recv.c Out-of-band: “通过完全不同的通信路径传输的数据。” TCP 不另外提供单独的通信路径高速传输数据，只利用 TCP 的紧急模式（Urgent mode）进行一字节传输。 13.1.3 紧急模式工作原理 MSG_OOB 的意义在于督促数据接收对象尽快处理数据，且 TCP “保持传输顺序” 的传输特性依然成立。 13.1.4 检查输入缓冲 同时设置 MSG_PEEK 选项和 MSG_DONTWAIT 选项，已验证输入缓冲中是否存在接收的数据。 peek_send.c peek_recv.c 13.2 readv &amp; writev 函数 13.2.1 使用 readv &amp; writev 函数 “对数据进行整合传输及发送的函数” 通过 writev 函数可以将分散保存在多个缓冲中的数据一并发送，通过 readv 函数可以由多个缓冲分别接收。 12#include &lt;sys/uio.h&gt;ssize_t writev(int fileds, const struct iovec *iov, int iovcnt); writev.c readv 函数和 writev 函数正好相反： 12#include &lt;sys/uio.h&gt;ssize_t readv(int fileds,const struct iovec *iov, int iovcnt); readv.c 13.2.2 合理使用 readv &amp; writev 函数 减少函数调用函数的次数就能提高性能，而 writev 函数在不采用 Nagle 算法时更有价值。 13.3 基于 Windows 的实现 13.4 习题 第十四章 多播与广播 14.1 多播 多播方式的数据传输是基于 UDP 完成的，区别在于，多播可以同时向多个主机传递数据。 14.1.1 多播的数据传输方式及流量方面的优点 多播的数据传输特点整理： 多播服务器端针对特定多播组，只发送 1 次数据。 即使只发送 1 次数据，但该组内的所有客户端都会接收数据。 多播组数可在 IP 地址范围内任意增加。 加入特定组即可接收发往该多播组的数据。 多播组是 D 类 IP 地址，“加入多播组”可以理解为通过程序完成如下声明： “在 D 类 IP 地址宏，我希望接收发往目标 239.234.218.234 的多播数据。” 多播需要借助路由器复制单个多播数据包并传递到多个主机： 多播优点在于只向路由器传递 1 个数据包，由路由器负责复制文件并传递到主机。 多播主要用于“多媒体数据的实时传输“。 14.1.2 路由（Routing）和 TTL（Time to Live，生存时间），以及加入组的方法 TTL 是决定”数据包传递距离“的主要因素，用整数表示，每经过 1 个路由器就减 1，到 0 就销毁。 TTL 过大会影响网络流量，过小会无法传递到目标。 TTL 设置方法： 1234567int send_sock;int time_live = 64;....send_sock = socket(PF_INET, SOCK_DGRAM, 0);setsockopt(send_sock, IPPROTO_IP, IP_MULTICAST_TTL, (void*) &amp;time_live,sizeof(time_live));.... 加入多播组： 12345678910int recv_sock;struct ip_mreq join_adr; ....recv_sock = socket(PF_INET, SOCK_DGRAM, 0);....join_adr.imr_multiaddr.s_addr = &quot;多播组地址信息&quot;;join_adr.imr_interface.s_addr = &quot;加入多播组的主机地址信息&quot;;setsockopt(recv_sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (void*) &amp;join_adr,sizeof(join_adr));.... 14.1.3 实现多播 Sender 和 Receiver 多播中用 Sender 和 Receiver 代替服务器端和客户端。 示例场景如下： Sender：向 AAA 组广播文件中保存的新闻信息。 Receiver: 接收传递到 AAA 组的新闻信息。 news_sender.c news_receiver.c 由于多播是属于官博的范畴，如果延迟运行 Receiver，则无法接收之前传输的多播数据。 14.2 广播 广播是向同一网络中的所有主机传输数据的方法，基于 UDP 完成。 广播分为两种： 直接广播：除了网络地址外，其余主机地址全设置为1（例192.12.34.255） 本地广播：限定 IP 地址 255.255.255.255 广播的 Sender 和 Receiver 实现除了使用的 IP 地址之外与 UDP 示例相同。 但 UDP 默认生成的套接字会阻止广播，使用如下代码修改： 1234567int send_sock;int bcase = 1; // 将 SO_BROADCAST 选项信息改为 1。....send_sock = socket(PF_INET, SOCK_DGRAM, 0);....setsockopt(send_sock, SOL_SOCKET, SO_BROADCAST, (void*)&amp;bcast, sizeof(bcaset));.... 14.2.1 实现广播数据的 Sender 和 Receiver news_sender_brd.c news_receiver_brd.c 14.3 基于 Windows 的实现 14.4 习题","categories":[{"name":"阅读","slug":"阅读","permalink":"http://aaaris.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"TCPIP网络编程 第一部分(上)","slug":"TCPIP 网络编程/TCPIP 网络编程 第一部分（上）","date":"2022-11-04T04:21:12.880Z","updated":"2022-11-06T12:46:49.717Z","comments":true,"path":"2022/11/04/TCPIP 网络编程/TCPIP 网络编程 第一部分（上）/","link":"","permalink":"http://aaaris.github.io/2022/11/04/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/TCPIP%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"TCP/IP 网络编程 前言 本书面向基于套接字的网络编程学习者，包含 Linux 和 Windows 两种操作系统平台的网络编程学习方法。 本书结构 第一部分介绍网络编程基础知识，包含计算机网络相关内容。 第二部分讲述 Linux 操作系统提供的相关系统函数。 第三部分讲述 Windows 操作系统提供的相关函数。 第四部分是为之前学习内容的总结。 个人博客读书笔记有所侧重 Linux 相关内容，故讲不对第三部分进行记录。 Part 01 开始网络编程（上） 第一章 理解网络编程和套接字 1.1 理解网络编程和套接字 网络编程——套接字编程就是使两台联网的计算机相互交换数据。 物理连接——网线 软件设备——套接字 1.1.1 构建接电话套接字 先讨论TCP套接字，TCP套接字可以比喻成电话机，具有拨打和接听功能。 以下先讨论接听电话的套接字创建： 调用socket函数（安装电话机）创建套接字： 问：“接电话需要准备什么？” 答：”当然是电话机！“ 12#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol); 调用 bind 函数（分配电话号码）给套接字分配地址信息（IP 地址和端口号）： 问：”请问您的电话号码是多少？“ 答：“我的电话号码是123-1234。” 12#include &lt;sys/socket.h&gt;int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen); 调用 listen 函数（连接电话线）转为可接受请求状态 问：”已假设电话机后是否只需连接电话线？“ 答：”对，只需要连接就能接听电话。“ 12#include &lt;sys/socket.h&gt;int listen(int sockfd, itn backlog); 调用 accepct 函数（拿起话筒）受理连接请求。 问：”电话铃响了， 我该怎么办？“ 答：”接听啊！“ 12#include &lt;sys/socket.h&gt;int accept (int sockfd, struct sockaddr * addr, socklen_t *addrlen); 1.1.2 编写 ”Hello world!“ 服务器端 hello_server.c 1.1.3 构建打电话套接字 客户端： 调用socket创建套接字 调用 connect 函数向服务器端发送连接请求 hello_client.c 1.1.4 在 Linux 平台下运行 运行结果： 1234567$ gcc hello_server.c -o hserver$ ./hserver 9190$ gcc hello_client.c -o hclient$ ./hclient 127.0.0.1 9190Message from server: Hello World!$ 服务器无法立刻重新运行，除非更改输入的端口号。 1.2 基于 Linux 的文件操作 与 Linux 不同，Windows 区分 socket 和文件。 1.2.1 底层文件访问和文件描述符 文件描述符是为了方便称呼操作系统创建的文件或套接字而赋予的数。 1.2.2 打开文件 12345#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(const char *path, int flag); 1.2.3 关闭文件 12#include &lt;unistd.h&gt;int close(int fd); 1.2.4 讲数据写入文件 12#include &lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t nbytes); low_open.c 运行结果： 123456$ gcc low_open.c -o lopen$ ./lopenfile descriptor: 3$ cat data.txtLet&#x27;s go!$ 1.2.5 读取文件中的数据 12#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t nbytes); low_read.c 运行结果： 12345$ gcc low_read.c -o lread$ ./readfile descriptor 3file dat: Let&#x27;s go!$ 1.2.6 文件描述符与套接字 fd_seri.c 运行结果： 123456$ gcc fd_seri.c -o fds$ ./fdsfile descriptor 1: 3file descriptor 2: 4file descriptor 3: 5$ 1.3 基于 Windows 平台的实现 1.4 基于 Windows 的套接字相关函数的示例 1.5 习题 第二章 套接字类型与协议设置 2.1 套接字协议机器数据传输特性 2.1.1 关于协议 协议是对话中使用的通信规则，“计算机间对话必备通信规则” 2.1.2 创建套接字（Protocol） 2.1.3 协议族（Protocol Family） 套接字通信协议的分类信息，最终协议信息通过第三个参数传递。 2.1.4 套接字类型（Type） 指的是套接字的数据传输方式。 2.1.5 套接字类型1：面向连接的套接字（SOCK_STREAM） 类比工人通过传送带传递糖果。 可靠的、按序传递的、基于字节的面向连接的数据传输方式的套接字。 2.1.6 套接字类型2：面向消息的套接字（SOCK_DGRAM） 类别摩托车快递的包裹传输方式： 不可靠的、不按序传递的、以数据的高速传输为目的的套接字。 2.1.7 协议的最终选择 数据传输方式相同，但协议不同。此时需要通过第三个参数具体指定协议信息。 “IPv4协议族中面向连接的套接字”&gt;&gt;&gt;“只有 IPPROTO_TCP 协议” “IPv4协议族中面向消息的套接字”&gt;&gt;&gt;“只有 IPPROTO_UDP 协议” 2.1.8 面向连接的套接字：TCP 套接字示例 hello_server.c &gt;&gt;&gt; tcp_server.c：无变化！ hello_client.c &gt;&gt;&gt; tcp_client.c: 更改 read 函数调用方式！ 在客户端中分别多次调用 read 函数以接收服务端发送的全部数据。 tcp_client.c 运行结果： 2.2 Windows 平台下的实现及验证 2.3 习题 第三章 地址族和数据序列 3.1 分配给套接字的 IP 地址和端口号 3.1.1 网络地址 为了使计算机连接到网络并收发数据，必须想起分配 IP 地址。 IPv4 (Internet Protocol version 4) 4字节地址族 IPv6 (Internet Protocol version 6) 16字节地址族 数据传输：主机发送数据 &gt;&gt;&gt; 对应网络路由器/交换机 &gt;&gt;&gt; 目标主机 3.1.2 网络地址分类和主机地址边界 A 类地址首字节：0~127 B 类地址首字节：128~191 C 类地址首字节：192~223 3.1.3 用于区分套接字的端口号 不同数据源利用端口号发送不同数据到同一台主机： 端口号就是同一操作系统内为区分不同套接字设置的。 3.2 地址信息的表示 3.2.1 表示 IPv4 地址的结构体 记忆线索：地址族、IP地址、端口号 1234567struct sockaddr_in &#123; sa_family_t sin_family; //地址族（Address Family） uint16_t sin_port; //16位 TCP/UDP 端口号 struct in_addr sin_addr;//32位 IP 地址 char sin_zero[8]; //不使用&#125;; POSIX 标准，定义的数据类型： 3.2.2 结构体 sockaddr_in 的成员分析 sin_family：每种协议族使用的地址族不同。 sin_port：保存 16 位端口号，重点在于，它以网络字节序保存（大端存储）。 sin_addr：保存 32 位 IP 地址信息，且也以网络字节序存储。 sin_zero：为使结构体 sockaddr_in 的大小和 sockaddr 结构体保持一致而插入的成员，必须填充为0。 结构体 sockaddr： 1234struct sockaddr &#123; sa_family_t sin_family; char sa_data[14];&#125;; 为支持其他地址族，sa_data 设计为14字节长度，剩余部分应填充为0，不便于填写。 一般我们按指定要求填写 sockaddr_in 结构体，生成符合 bind 函数要求的字节流。最后转换为 sockaddr 类型的结构体变量，在传递给 bind 函数即可。 3.3 网络字节序与地址变换 3.3.1 字节序（Order）与网络字节序 网络字节序：大端存储模式（数据的低字节保存在内存的高地址） Unix CPU：小端存储模式（数据的低字节保存在内存的低地址） 为避免字节序问题产生，在网络传输中统一约定采用网络字节序——大端序。 3.3.2 字节序转换 1234unsigned short htons(unsigned short);unsigned short ntohs(unsigned short);unsigned long htosl(unsigned long);unsigned long ntohl(unsigned long); 细节： htons 中 h 表示 host 主机字节序。 htons 中 n 表示 network 网络字节序。 htons 中 s 表示 short 类型 （2 个字节）数据。 为保证代码移植性，无论你的电脑 CPU 采用大端还是小端序，最好代码中都加入字节序转换函数。 endian_conv.c 运行结果（小端序 CPU 运行）： 如果大端序 CPU 中运行，则变量值不会改变。 Intel 和 AMD 系列的 CPU 都采用小端序标准。 补充说明：除了向 sockaddr_in 结构体填充数据外，其他情况不用考虑字节序问题。 3.4 网络地址的初始化和分配 3.4.1 将字符串信息转换为网络字节序的整数型 inet_addr 函数将字符串形式的 IP 地址转换为 32位整数型大端序数据。 12#include &lt;arpa.inet.h&gt;in_addr_t inet_addr(const char* string); inet_addr.c 运行结果，inet_addr 还可以检验无效的 IP 地址： inet_aton 函数和 inet_addr 函数功能相同，此外还将结果保存到 in_addr 结构体中。 12#include &lt;arpa/inet.h&gt;int inet_aton(const char *string, struct in_addr *addr); inet_aton.c inet_ntoa 函数则是将网络字节序整数型 IP 地址转换位字符串形式。 12#include &lt;arpa/inet.h&gt;char *inet_ntoa(struct in_addr addr); 返回的字符串是函数内部申请的内存空间，调用函数后应立即将字符串信息复制到其他内存空间中。再次调用函数可能会覆盖之前的信息。 inet_ntoa.c 3.4.2 网络地址初始化 1234567struct sockaddr_in addr;char *serv_ip = &quot;211.217.168.13&quot;; //声明 IP 地址字符串char *serv_port = &quot;9190&quot;; //声明端口号字符串memset(&amp;addr, 0, sizeof(addr)); //结构体变量 addr 所有成员变量初始化为0addr.sin_family = AF_INET; //指定地址族addr.sin_addr.s_addr = inet_addr(serv_ip); //基于字符串的 IP 地址初始化addr.sin_port = htons(atoi(serv_port)); //基于字符串的端口号初始化 3.4.3 客户端地址信息初始化 服务器端初始化网络地址是为了接收数据请求，而客户端是为了创建连接请求。 故服务器端使用 bind 函数完成准备工作，客户端使用 connnet 函数完成准备工作。 3.4.4 INADDR_ANY addr.sin_addr.s_addr = htonl(INADDR_ANY); INADDR_ANY 用于分配服务器端的 IP 地址，可以自动获取运行服务端的计算机 IP 地址。 同一计算机可以分配多个 IP 地址，由计算机中 NIC 数量确定。 若只有一个 NIC，则直接使用 INADDR_ANY。 3.4.5 第一章的 hello_server.c、hello_client.c 运行过程 ./hserver 9190 命令向 main 函数传递 9190 作为端口号，又通过 INADDR_ANY 指定 IP 地址。 ./hclient 127.0.0.1 9190 与上一个命令相比，还传递了 IP 地址信息。 3.4.6 向套接字分配网络地址 bind 函数负责将初始化的地址信息分配给套接字。 12#include &lt;sys/socket.h&gt;int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen); 3.5 基于 Windows 的实现 3.6 习题 第四章 基于 TCP 的服务器端/客户端（1） 4.1 理解 TCP 和 UDP 4.1.1 TCP/IP 协议栈 4.1.2 链路层 链路层是物流链接领域标准化的结果，定义 LAN、WAN、MAN等网络标准。 4.1.3 IP 层 IP 层解决的是传输路径的选择问题，但无法应对数据错误、丢失情况（面向消息、不可靠的）。 4.1.4 TCP/ UDP 层 又称传输层，以 IP 层提供的路径信息完成实际的数据传输，决定传输方式。 IP 层只关注单个数据包的传输过程，不关系丢失或者传输顺序的问题，但加入 TCP 协议后，对话如下： 4.1.5 应用层 程序编程无需考虑细节，利用套接字这个工具编写程序即可。 server 端和 client 端之间的数据传输规则就是应用层协议，网络编程大部分内容就是设计并实现应用层协议。 4.2 实现基于 TCP 的服务器端/客户端 4.2.1 TCP 服务器端的默认函数调用顺序 4.2.2 进入等待连接请求状态 使用 listen 函数进入等待连接请求状态，之后客户端才能调用 connect 函数。 12#include &lt;sys/socket.h&gt;int listen(int sock, int backlog); 调用 listen 函数生成连接请求等待队列，且由服务器端套接字管理。 4.2.3 受理客户端连接请求 调用 accept 函数进入可接收数据状态，创建一个新的套接字，并连接到发起请求的客户端。 12#include &lt;sys/socket.h&gt;int accept(int sock, struct sockaddr *addr, socklen_t *addrlen); 4.2.4 回顾 Hello World 服务端 4.2.5 TCP 客户端的默认函数调用顺序 调用 connect 函数向服务器端发起连接请求： 12#include &lt;sys/socket.h&gt;int connect(int sock, struct sockaddr *servaddr, socklen_t addrlen); 发生如下情况才会返回： 服务器端接收连接请求。 发生断网等异常情况而中断连接请求。 “接收连接”并不代表服务器端调用了 accept 函数，而是服务器端将请求记录到等待队列。 补充：调用 connect 函数时，内核为客户端套接字自动分配 IP（主机）和端口（随机）。 4.2.6 回顾 Hello World 客户端 4.2.7 基于 TCP 的服务端/客户端函数调用关系 accept 函数进入阻塞，直到等待请求队列不为空。 4.3 实现迭代服务器端/客户端 4.3.1 实现迭代服务器端 插入循环：受理后续客户端连接请求。（单线程） 4.3.2 迭代回声服务器端/客户端 server 同一时刻只处理单 client 请求，提供 echo 服务。 server 一次向 5 个 client 提供服务并退出。 client 接收用户输入字符串并发送到 server。 server 接收字符串数据并传回 client，即 echo。 server 和 client 的 echo 服务一直执行到客户端输入 Q 为止。 echo_server.c echo_client.c 存在的问题：如果数据太大，分包发送会存在接收数据不全的问题。 4.4 基于 Windows 的实现 4.5 习题 第五章 基于 TCP 的服务器端/客户端（2） 5.1 echo 客户端的完美实现 5.1.1 echo服务器端没有问题，只有回声客户端有问题？ 12345678910while(1)&#123; fputs(&quot;Input message(Q to quit): &quot;, stdout); fgets(message, BUF_SIZE, stdin); .... write(sock, message, strlen(message)); str_len = read(sock, message, BUF_SIZE -1); message[str_len] = 0; printf(&quot;Message from server: %s&quot;, message);&#125; read 函数接收数据的单位应该做出调整。 改动： 12345678910str_len = write(sock, message, strlen(message));recv_len = 0;while(recv_len &lt; str_len)&#123; recv_cnt = read(sock, &amp;message[recv_len], BUF_SIZE -1); if (recv_cnt == -1) error_handling(&quot;read() error!&quot;); recv_len += recv_cnt;&#125;message[recv_len] = 0; 5.1.2 如果问题不在于 echo 客户端：定义用户层协议 定义协议以表示数据边界，或提前告知收发数据的大小。 要求实现计算服务器，体验协议的制定： server 从 client 获得多个数字和运算符。 server 收到数字后进行加减乘运算，并返回结果。 运行结果如下： 5.1.3 计算器服务器端/客户端示例 协议设计：控制包大小、利用字节数组传输多类型数据、指针和数据运用。 5.2 TCP 原理 5.2.1 TCP 套接字中的 I/O 缓冲 缓冲特性整理如下： I/O 缓冲在每个 TCP 套接字中单独存在。 I/O 缓冲在创建套接字时自动生成。 即使关闭套接字也会继续传递输出缓冲中遗留的数据。 关闭套接字将丢失输入缓冲中的数据。 TCP 具有滑动窗口协议，保证传输数据不会使缓冲溢出： 套接字 A：”你好，最多可以向我传递 50 字节。“ 套接字 B：”OK！“ 套接字 A：”我腾出了 20 字节的空间，最多可以接收 70 字节。“ 套接字 B：”OK！“ 5.2.2 TCP 内部工作原理1：与对方套接字的连接 三次握手： SEQ: Sequence Number ACK: Acknowledgment Number 首先，请求连接的 A 向 B 传递信息（SYN——收发数据前的同步消息）： [SYN] SEQ: 1000, ACK : - SEQ:“现传递的数据包序号为 1000，如果接收无误，请通知我向您传递 1001 号数据包。” 接下来 B 向 A 传递如下消息（SYN+ACK)： [SYN+ACK] SEQ: 2000, ACK: 1001 SEQ:“现传递的数据包序号为 2000，如果接收无误，请通知我向您传递 2001 号数据包。” ACK:”刚才传输的 SEQ 为 1000 的数据包接收无误，现在请传递 SEQ 为 1001 的数据包“ 最后 A 向 B 传输消息： [ACK] SEQ: 1001, ACK: 2001 “已正确收到传输的 SEQ 为 2000 的数据包，现在可以传输 SEQ 为 2001 的数据包。” TCP 协议在收发数据前向数据包分配序号，并向对方通报确认，以在数据丢失时马上查看并重传丢失的数据包，保证了可靠的数据传输。 不是两次握手的原因: 如果客户端发送了连接请求时出现了丢包情况，并连续发送了两次连接请求。而第一次请求由于网络原因在客户端和服务端释放连接后才抵达，服务端会误以为客户端在断开连接后再次发起新的连接请求，发送 ACK 报文，并一直等待客户端答复，导致资源浪费。 5.2.3 TCP 内部工作原理2：与对方主机的数据交换 一次正常的传输如下： 首先 A 通过 1 个数据包发送 100 个字节数据，数据包的 SEQ 为 1200。B 为了确认，向 A 发送 ACK 1301 消息。 为保证数据包传输无误，且全部正确传递，按照以下公式传递 ACK 消息： $ACK 号 = SEQ号 + 传递的字节数 + 1$ 一次数据包丢失的情况如下： 为避免数据包丢失，TCP 套接字启动计时器等待 ACK 应答，若计时器超时，则重传。 5.2.4 TCP 内部工作原理3： 断开套接字的连接 数据包内的 FIN 表示断开连接。双方各发一次 FIN 信息后断开连接，此过程称为四次握手： 挥手一： A 对 B 发送 FIN 报文，通知 B 将不再发送数据。 挥手二： B 对 A 发送 ACK 报文，通知 A 我收到通知了。 挥手三： B 对 A 发送 FIN、ACK 报文，通知 A 我也将不再发送数据了。 挥手四： A 对 B 发送 ACK 报文，通知 B 我收到了通知了。 存在挥手二、挥手三的原因（比建立连接多一次挥手）： 在接收到挥手一后，仅仅表示 A 不会再对 B 发送数据，但是 B 或有数据还未向 A 发送。等所有数据发送完毕，B 再向 A 发送 FIN 报文，通知 A：所有数据发送完毕，不再发送数据！ 回收三中第二次传递 ACK 报文的原因： B 向 A 发送了 ACK 报文后，未接收到 A 的数据，ACK 号不变，和 FIN 报文一起重新发送。 详情参考 详解TCP四次挥手的过程 - 掘金 (juejin.cn) [三次握手和四次挥手知识总结（超详细）-云社区-华为云 (huaweicloud.com)](https://bbs.huaweicloud.com/blogs/364210#:~:text=第四次挥手 %3A客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack %3D,w%2B1），且把服务端的序列值 %2B1 作为自己 ACK 报文的序号值（seq%3Du%2B1，此时客户端处于 TIME_WAIT（时间等待状态） 。) 5.3 基于 Windows 的实现 5.4 习题 第六章 基于 UDP 的服务器端/客户端 6.1 理解 UDP 6.1.1 UDP 套接字的特点 重视性能 为了提供可靠的数据传输服务，TCP 在 IP 层进行流控制。而流控制是区分 UDP 和 TCP 的最重要的标志。 6.1.2 UDP 内部工作原理 UDP 的作用在于根据端口号将数据包交付给 UDP 套接字。 6.1.3 UDP 的高效使用 需要提供实时服务时，UDP 是首选。 TCP 比 UDP慢（数据量小）通常是由于以下两点： 收发数据前后进行的连接设置及清除过程。 收发数据过程中为保证可靠性而添加的流控制。 6.2 实现基于 UDP 的服务器端/客户端 6.2.1 UDP 中的服务器端和客户端没有连接 UDP 中只有创建套接字的过程和数据交换过程。 6.2.2 UDP 服务器端和客户端均只需 1 个套接字 只需要一个 UDP 套接字就能和多台主机通信。 6.2.3 基于 UDP 的数据 I/O 函数 类比信封，UDP 套接字相当于邮筒，每次传输数据都要添加目的地信息。 UDP 使用 sendto 函数来发送信息： 123#include &lt;sys/socket.h&gt;ssize_t sendto(int sock, void *buff, size_t nbytes, int flags, struct sockaddr *to, socklen_t addrlen); 使用 recvfrom 函数来接收发送信息： 123#include &lt;sys/socket.h&gt;ssize_t recvfrom(int sock, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen); 6.2.3 基于 UDP 的回声服务器端/客户端 uecho_server.c uecho_client.c 6.2.4 UDP 客户端套接字的地址分配 bind 函数在 TCP 和 UDP 程序中都可以调用。 如果调用 sendto 函数时发现尚未分配地址信息，则在首次调用 sendto 函数时自动分配。 6.3 UDP 的数据传输特性和调用 connect 函数 6.3.1 存在数据边界的 UDP 套接字 输入函数的调用次数应和输出函数的调用次数完全一致。 bound_host1.c bound_host2.c 6.3.2 已连接 UDP 套接字和未连接 UDP 套接字 UDP 中 sendto 函数传输数据分为 3 个阶段： 第一阶段： 向 UDP 套接字注册目标 IP 和端口号。 第二阶段： 传输数据。 第三阶段： 删除 UDP 套接字中注册的目标地址信息。 这种未注册目标地址的套接字称为未连接套接字。UDP 套接字默认属于未连接套接字。 但如果要与同一主机进行长时间通信，连接套接字会提高效率。 6.3.3 创建已连接 UDP 套接字 使用 connect 函数创建已连接套接字： 123456sock = socket (PF_INET, SOCK_DGRAM, 0);memset(&amp;adr, 0, sizeof(adr)));adr.sin_family = AF_INET;adr.sin_addr.s_addr = ....adr.sin_port = ....connect(sock, (struct sockaddr*) &amp;adr, sizeof(adr)); 之后就和 TCP 套接字一样，调用 sendto 函数时只需传输数据，因为指定了收发对象。还可以使用 write 、read 函数进行通信。 uecho_con_client.c 6.4 基于 Windows 的实现 6.5 习题 第七章 优雅地断开套接字连接 7.1 基于 TCP 的半关闭 7.1.1 单方面断开带来的问题 调用 close 函数断开连接之后， A 无法接收 B 的数据（无法调用相关函数），使得数据销毁。 为了解决这类问题，”只关闭一部分数据交换中使用的流“（Half-close）的方法应运而生。 只关闭流的一半：可以发送但无法接收，可以接收但无法发送。 7.1.2 套接字和流 建立套接字连接后，两台主机就会拥有单独的输入和输出流。其中一个主机的输入流和另一个主机的输出相连。Linux 的 close 函数将同时断开这两个流，下面讨论的半关闭方式只断开其中的一个流。 7.1.3 针对优雅断开的 shutdown 函数 shutdown 函数用来关闭其中的一个流： 12#include &lt;sys/socket.h&gt;int shutdown (int sock, int howto); howto： SHUT_RD ：断开输入流。 SHUT_WR ：断开输出流。 SHUT_RDWR ：同时断开 I/O 流。 如果断开的输入流缓冲中还有数据，则抹去；如果断开的输出流缓冲还有数据，则传递到目标主机。 7.1.4 为何需要半关闭 考虑以下场景： “一旦客户端连接到服务器端，服务器端将约定的文件传给客户端，客户端收到后发送字符串’Thank you‘给服务端。” 场景中，客户端无法得知接收数据的进度，也不能循环调用输入函数避免引起阻塞。于是： “是否可以让服务器端和客户端约定一个代表文件尾的字符？” 为防止文件中出现与约定字符相同的内容，服务器端最好向客户端传递 EOF 表示结束，于是： ”断开输出流时，向对方主机传输 EOF。“ 为了断开输出流后，仍能接收到客户端传来的”Thank you“字符串，使用”半关闭“理所应当。 7.1.5 基于半关闭的文件传输程序 file_server.c file_client.c 7.2 基于 Windows 的实现 7.3 习题","categories":[{"name":"阅读","slug":"阅读","permalink":"http://aaaris.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"Linux系统编程 第十章","slug":"Linux系统编程/Linux系统编程 第十章","date":"2022-10-26T14:05:22.739Z","updated":"2022-11-05T02:23:54.531Z","comments":true,"path":"2022/10/26/Linux系统编程/Linux系统编程 第十章/","link":"","permalink":"http://aaaris.github.io/2022/10/26/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E5%8D%81%E7%AB%A0/","excerpt":"","text":"Linux系统编程 第十章 时间 内核关心三个时间： 墙上时间——真实事件（时间戳） 进程时间——进程消耗时间 单调时间——系统启动时间 Unix 系统使用大纪元——1970 年 1 月 1日 00 : 00 : 00——经过的秒数表示绝对时间。 Linux 中系统计时器频率被称为 HZ，通常是 100、250、1000。 POSIX 定义 sysconf (_SC_CLK_TCK) 用于获取 HZ。 10.1 时间的数据结构 10.1.1 原始表示 time_t 表示自大纪元以来已流逝的秒数。 12#include &lt;time.h&gt;typdef long time_t 10.1.2 毫秒级精度 12345#include &lt;sys/time.h&gt;struct timeval &#123; time_t tv_sec; /* seconds */ suseconds_t tv_usec; /* microseconds */&#125;; 10.1.3 纳秒级精度 12345#include &lt;time.h&gt;struct timespec &#123; time_t tv_sec; /* seconds */ long tv_nsec; /* nanoseconds */&#125;; 系统计时器没有提供上述进度，故以上结构实际上无法提供所声明的精度。 10.1.4 “分解”时间 标准 C 提供结构体 tm 便于进行分解构造字符串。 1234567891011121314151617#include &lt;time.h&gt;struct tm &#123; int tm_sec; /* seconds */ int tm_min; /* minutes */ int tm_hour; /* hours */ int tm_mday; /* the day of the month */ int tm_mon; /* the month */ int tm_year; /* the year */ int tm_wday; /* the day of the week */ int tm_yday; /* the day in the year */ int tm_isdst; /* daylight savings time? */#ifdef _BSD_SOURCE long tm_gmtoff; /* time zone’s offset from GMT */ const char *tm_zone; /* time zone abbreviation */#endif /* _BSD_SOURCE */&#125;; 10.1.5 一种进程时间类型 clock_t 表示系统实际计时器频率（HZ）或者 CLOCKS_PER_SEC。 10.2 POSIX 时钟 10.3 时间源精度 POSIX 定义 clock_getres() 函数取得时间源精度 12#include &lt;time.h&gt;int clock_getres (clockid_t clock_id, struct timespec *res); 实例代码，输出四种时间源精度： 1234567891011121314151617181920clockid_t clocks[] = &#123; CLOCK_REALTIME, CLOCK_MONOTONIC, CLOCK_PROCESS_CPUTIME_ID, CLOCK_THREAD_CPUTIME_ID, (clockid_t) -1 &#125;;int i;for (i = 0; clocks[i] != (clockid_t) -1; i++) &#123; struct timespec res; int ret; ret = clock_getres (clocks[i], &amp;res); if (ret) perror (&quot;clock_getres&quot;); else printf (&quot;clock=%d sec=%ld nsec=%ld\\n&quot;, clocks[i], res.tv_sec, res.tv_nsec);&#125; 输出示例： 结果显示，CLOCK_REALTIME 和 CLOCK_MONOTONIC和 HZ 精度有关；而CLOCK_PROCESS_CPUTIME_ID 和 CLOCK_THREAD_CPUTIME_ID 使用 TSC，提供纳秒级精度。 10.4 取得当前时间 12#include &lt;time.h&gt;time_t time (time_t *t); time_t 表示时间并不准确，但要点在于计算方法一致。 time() 函数返回了当前时间点到linux epoch的秒。 10.4.1 一个更好的接口 gettimeofday() 扩展了 time() ，提供微秒级精度。 12#include &lt;sys/time.h&gt;int gettimeofday (struct timeval *tv, struct timezone *tz); timezone 已过时。 10.4.2 一个高级接口 POSIX 提供 clock_gettime() 取得指定时间源的时间，如果取两种时间源可达纳秒级精度。 12#include &lt;time.h&gt;int clock_gettime(clockid_t clock_id, struct timespec *ts); 10.4.3 取得进程时间 times() 系统调用可以获取父子进程的进程时间（用户时间和内核时间）。 获取子进程时间前提是：父进程使用 waitpid相关函数且子进程退出后。 12345678910#include &lt;sys/times.h&gt;struct tms &#123; clock_t tms_utime; /* user time consumed */ clock_t tms_stime; /* system time consumed */ clock_t tms_cutime; /* user time consumed by children */ clock_t tms_cstime; /* system time consumed by children */&#125;;clock_t times (struct tms *buf); 10.5 设置当前时间 123#define _SVID_SOURCE#include &lt;time.h&gt;int stime (time_t *t); 发起者拥有 CAP_SYS_TIME 权限。 stime() 是设定当前时间点到 linux epoch的秒数。 10.5.1 高精度定时 与 gettimeofday() 对应的是 settimeofday()： 12#include &lt;sys/time.h&gt;int settimeofday (const struct timeval *tv, const struct timezone *tz); 例子，设置当前时间为 1979 十二月中的一个周六 123456struct timeval tv = &#123; .tv_sec = 31415926, .tv_usec = 27182818 &#125;;int ret;ret = settimeofday (&amp;tv, NULL);if (ret) perror (&quot;settimeofday&quot;); 10.5.2 设置时间的一个高级接口 对应 clock_gettime() 有 clock_settime()： 123#include &lt;time.h&gt;int clock_settime (clockid_t clock_id, const struct timespec *ts); 一般情况下，只有 CLOCK_REALTIME 可以进行设置。 10.6 玩转时间 asctime() 将 tm 结构体转换成一个 ASCII 字符串： 123#include &lt;time.h&gt;char * asctime (const struct tm *tm);char * asctime_r (const struct tm *tm, char *buf); asctime() 返回一个指向静态分配的字符串的指针；asctime() 不是线程安全的。 多线程程序，可以使用 asctime_r()，存储在 buf 中，buf 要求至少具备 26 个字符长度。 mktime() 将 tm 结构体转换为一个 time_t。 12#include &lt;time.h&gt;time_t mktime (struct tm *tm); ctime() 将一个 time_t 转换为 ASCII 表示： 123#include &lt;time.h&gt;char * ctime (const time_t *timep);char * ctime_r (const time_t *timep, char *buf); gmtime() 将 time_t 转换到 tm 结构体，用 UTC 时区格式表示： 123#include &lt;time.h&gt;struct tm * gmtime (const time_t *timep);struct tm * gmtime_r (const time_t *timep, struct tm *result); localtime() 和 localtime_r() 与 gmtime() 类似，但时区格式使用用户时区： 123#include &lt;time.h&gt;struct tm * localtime (const time_t *timep);struct tm * localtime_r (const time_t *timep, struct tm *result); difftime() 返回两个 time_t 的差值，并转换到双精度浮点型表示相差的秒数。 12include &lt;time.h&gt;double difftime (time_t time1, time_t time0); 在所有 POSIX 系统上，time_t 是一个算术类型，等价于： 1(double) (time1 - time0) 为保证可移植性，最好使用 difftime()。 10.7 调校系统时钟 例子：make 程序通过判断源文件（.c）和目标文件（.o）之间的改动时间戳大小，选择是否重新编译源文件。若用户修改了系统时间后，编辑某源文件，可能会导致该源文件不会被重新编译（时间早于目标文件）。 Unix 提供 adjtime() 函数，避免发生上述情况。 adjtime() 函数，指示内核使用 delte 来减缓或加速系统时钟，保证时间单调递增。 123#define _BSD_SOURCE#include &lt;sys/time.h&gt;int adjtime (const struct timeval *delta, struct timeval *olddelta); Linux 包含 adjtimex() 函数，实现了一个更复杂的算法： 12#include &lt;sys/timex.h&gt;int adjtimex (struct timex *adj); 如果考虑移植性，应使用 adjtime() 。 10.8 睡眠和等待 sleep() 让发起进程睡眠指定秒数 12#include &lt;unistd.h&gt;unsigned int sleep (unsigned int seconds); 10.8.1 微秒级精度睡眠 1234567/* BSD version */#include &lt;unistd.h&gt;void usleep (unsigned long usec);/* SUSv2 version */#define _XOPEN_SOURCE 500#include &lt;unistd.h&gt;int usleep (useconds_t usec); 10.8.2 Linux 的实时支持 尽可能满足移植性，Best practices： 12unsigned int usecs = 200;usleep (usecs); 10.8.3 纳秒级精度睡眠 123#define _POSIX_C_SOURCE 199309#include &lt;time.h&gt;int nanosleep (const struct timespec *req, struct timespec *rem); 示例： 12345struct timespec req = &#123; .tv_sec = 0, .tv_nsec = 200 &#125;;/* sleep for 200 ns */ret = nanosleep (&amp;req, NULL);if (ret) perror (&quot;nanosleep&quot;); nanosleep() 的优点： 纳秒级精度 POSIX 标准 不是用信号来实现 10.8.4 实现睡眠的高级方法 12345#include &lt;time.h&gt;int clock_nanosleep (clockid_t clock_id, int flags, const struct timespec *req, struct timespec *rem); 两者区别在于，clock_nanosleep 可以指定衡量睡眠时间的时间源。 示例，绝对时间睡眠一秒钟，以避免产生潜在的竞态条件： 12345678910111213struct timespec ts;int ret;/* we want to sleep until one second from NOW */ret = clock_gettime (CLOCK_MONOTONIC, &amp;ts);if (ret) &#123; perror (&quot;clock_gettime&quot;); return;&#125;ts.tv_sec += 1;printf (&quot;We want to sleep until sec=%ld nsec=%ld\\n&quot;,ts.tv_sec, ts.tv_nsec);ret = clock_nanosleep (CLOCK_MONOTONIC,TIMER_ABSTIME,&amp;ts, NULL);if (ret) perror (&quot;clock_nanosleep&quot;); 10.8.5 sleep 的一种可移植实现 利用 select() 实现可以可移植睡眠（详情跳转 select()）。 10.8.6 超限 睡眠时间超时： 调度行为——选择另外一个任务执行。 定时器超限——定时器粒度大于要求时间间隔。（10ms/报时，1ms/睡眠） 10.8.7 替代睡眠 文件阻塞——只在需要时唤醒。 10.9 定时器 10.9.1 简单的闹钟 alaram()配合 signal handler 使用，用于处理 SIGALRM 信号。 12#include &lt;unistd.h&gt;unsigned int alarm (unsigned int seconds); 如果先前的信号尚未处理，调用会取消先前信号，使用新的代替，返回剩余秒数。 示例： 1234567891011void alarm_handler (int signum)&#123; printf (&quot;Five seconds passed!\\n&quot;);&#125;void func (void)&#123; signal (SIGALRM, alarm_handler); alarm (5); pause ();&#125; 10.9.2 间歇定时器 与 alarm()操作不同的是：间歇定时器可以自动重启自身。 12345#include &lt;sys/time.h&gt;int getitimer (int which, struct itimerval *value);int setitimer (int which, const struct itimerval *value, struct itimerval *ovalue); 示例： 1234567891011121314151617181920void alarm_handler (int signo)&#123; printf (&quot;Timer hit!\\n&quot;);&#125;void foo (void) &#123; struct itimerval delay; int ret; signal (SIGALRM, alarm_handler); delay.it_value.tv_sec = 5; delay.it_value.tv_usec = 0; delay.it_interval.tv_sec = 1; delay.it_interval.tv_usec = 0; ret = setitimer (ITIMER_REAL, &amp;delay, NULL); if (ret) &#123; perror (&quot;setitimer&quot;); return; &#125; pause ( );&#125; 10.9.3 高级定时器 如果优先考虑简洁或者可移植性，那么 setitimer() 是更好的选择。 10.9.3.1 建立一个定时器 12345#include &lt;signal.h&gt;#include &lt;time.h&gt;int timer_create (clockid_t clockid, struct sigevent *evp, timer_t *timerid); 进程可以指定定时器的过期行为——sigev_notify: 示例，定时器到期内核发出 SIGUSER1 信号，并设置 si_value 为存储器定时器ID的地址值： 123456789struct sigevent evp;timer_t timer;int ret;evp.sigev_value.sival_ptr = &amp;timer;evp.sigev_notify = SIGEV_SIGNAL;evp.sigev_signo = SIGUSR1;ret = timer_create (CLOCK_REALTIME, &amp;evp, &amp;timer);if (ret) perror (&quot;timer_create&quot;); 10.9.4 设置定时器 time_settime() 将设置 timerid指定的定时器的过期时间为 value。 12345#include &lt;time.h&gt;int timer_settime (timer_t timerid, int flags, const struct itimerspec *value, struct itimerspec *ovalue); 设置 flags 为 TIMER_ABSTIME 后，可避免产生竞争条件。 10.9.4.1 取得定时器的过期时间 12#include &lt;time.h&gt;int timer_gettime (timer_t timerid, struct itimerspec *value); 10.9.4.2 取得定时器的超时值 12#include &lt;time.h&gt;int timer_getoverrun (timer_t timerid); 10.9.4.3 删除定时器 12#include &lt;time.h&gt;int timer_delete (timer_t timerid);","categories":[{"name":"阅读","slug":"阅读","permalink":"http://aaaris.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"Linux系统编程 第九章","slug":"Linux系统编程/Linux系统编程 第九章","date":"2022-10-25T00:39:47.000Z","updated":"2022-11-05T02:22:46.545Z","comments":true,"path":"2022/10/25/Linux系统编程/Linux系统编程 第九章/","link":"","permalink":"http://aaaris.github.io/2022/10/25/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E4%B9%9D%E7%AB%A0/","excerpt":"","text":"Linux 系统编程 第九章 信号 信号是提供处理异步事件机制的软件中断，也是一种 IPC 的基本形式。 信号处理函数在内核注册，并被异步地调用。 9.1 信号概念 信号生命周期：产生 &gt;&gt; 内存存储发送 &gt;&gt; 内核处理 内核根据进程的请求进行三种处理方式： 忽略信号 不采取任何操作。（SIGKILL 和 SIGSTOP 无法忽略） 捕获并处理信号 暂停进程 &gt;&gt; 调用注册函数 &gt;&gt; 回到进程继续运行。（SIGKILL 和 SIGSTOP 无法捕获） 执行默认操作 取决于被发送的信号，默认操作通常是终止信号。程序员自提供信号默认是忽略。 9.1.1 信号标识符 信号标识符以 SIG 作为前缀，在 &lt;signal.h&gt; 头文件定义。 使用 kill -l 命令产生一个系统支持的信号列表 9.1.2 Linux 支持的信号 9.2 基本信号管理 signal() 函数是最简单古老的信号管理接口。 123#include &lt;signal.h&gt;typedef void (*sighandler_t)(int);sighandler_t signal (int signo, sighandler_t handler); 成功调用后，移除 signo 信号的当前操作，并注册 handler 函数来处理该信号。 SIG_DEF 设置未默认操作，SIG_IGN 忽略 signo 表示的信号。 9.2.1 等待信号 POSIX 定义 pause() 调用，使进程睡眠，接收到信号（不包括被忽略的信号）后返回。 12#include &lt;unistd.h&gt;int pause (void); 9.2.2 例子 1234567891011121314151617181920212223242526272829#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;/* SIGINT 的处理程序*/static void sigint_handler (int signo)&#123; /* * 从技术上来说，在信号处理程序中不应该使用 printf()， * 但这不是非常严重的问题。 * 我会在“重入”这部分讨论为什么可以这么做。 */ printf (&quot;Caught SIGINT!\\n&quot;); exit (EXIT_SUCCESS);&#125;int main (void)&#123; /* * 注册 signint_handler 作为 SIGINT 的信号处理程序。 */ if (signal (SIGINT, sigint_handler) == SIG_ERR) &#123; fprintf (stderr, &quot;Cannot handle SIGINT!\\n&quot;); exit (EXIT_FAILURE); &#125; for (;;) pause ( ); return 0;&#125; 9.2.3 执行与继承 新进程中，任何父进程捕获的信号都重置为默认操作。因为新进程没共享父进程的地址空间。 当内核执行一个”后台“进程时，应设置 SIGINT 和 SIGQUIT 为忽略。 例子，处理程序得先检查信号不被忽略： 12345678910/* 只有 SIG_INT 不被忽略时才处理它 */if (signal (SIGINT, SIG_IGN) != SIG_IGN) &#123; if (signal (SIGINT, sigint_handler) == SIG_ERR) fprintf (stderr, &quot;Failed to handle SIGINT!\\n&quot;);&#125;/* 只有 SIG_QUIT 不被忽略时才处理它 */if (signal (SIGQUIT, SIG_IGN) != SIG_IGN) &#123; if (signal(SIGQUIT, sigquit_handler) == SIG_ERR) fprintf (stderr, &quot;Failed to handle SIGQUIT!\\n&quot;);&#125; 在设置信号的行为前需要检查信号的行为，这是 signal() 一个突出的缺点。 fork() 得到的子进程完全继承父进程的信号处理方式，因为父子进程共享同一个地址空间。 9.2.4 映射信号标号为字符串 从静态定义列表中检索字符串： 1extern const char * const sys_siglist[]; 通常是 best choice BSD 定义 psignal() 接口向 stderr 输出 msg，加上 signo 的信号名称 12#include &lt;signal.h&gt;void psignal (int signo, const char *msg); 非标准化接口 strsignal() 返回一个描述 signo 信号的指针： 123#define _GNU_SOURCE#include &lt;string.h&gt;char *strsignal (int signo); strsignal() 不是线程安全的。 9.3 发送信号 kill() 调用从一个进程向另外一个进程发送信号，向 pid 进程发送 signo信号： 123#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;int kill (pid_t pid, int signo); 9.3.1 权限 有 CAP_KILL 权限的进程能给任何进程发送信号。此外，用户只能给自己的进程发送信号。 Unix 为 SIGCOUT 定义了一个特例：同一个会话中，进程可以任意发送该信号。 测试进程关于发送信号的权限，通常可以使用空信号—— signo 为零。 9.3.2 例子 发送 SIGHUP： 1234int ret;ret = kill (1722, SIGHUP);if (ret) perror (&quot;kill&quot;); 检测权限： 123456int ret;ret = kill (1722, 0);if (ret) ; /* 没有权限 */else ; /* 有权限 */ 9.3.3 给自己发信号 raise() 是一种简单的进程给自己发送信号的方法： 12#include &lt;signal.h&gt;int raise (int signo); raise (signo)与kill (getpid (), signo) 等价 9.3.4 给整个进程发送信号 12#include &lt;signal.h&gt;int killpg (int pgrp, int signo); killpg (pgrp, signo)与kill (-pgrp, signo)等价 9.4 重入 可重入函数是指可以安全调用自身的函数。 可重入函数绝不能操作静态数据（全局变量 变量），必须只操作栈分配的数据或者调用者提供的数据。 9.4.1 有保证的可重入函数 信号处理函数应只调用可重入函数，确保数据安全操作。 9.5 信号集 为了处理信号集，POSIX 定义了以下调用： 123456#include &lt;signal.h&gt;int sigemptyset (sigset_t *set);int sigfillset (sigset_t *set);int sigaddset (sigset_t *set, int signo);int sigdelset (sigset_t *set, int signo);int sigismember (const sigset_t *set, int signo); 9.5.1 更多的信号集函数 Linux 也提供了一些非标准的函数： 12345#define _GNU_SOURCE#define &lt;signal.h&gt;int sigisemptyset (sigset_t *set);int sigorset (sigset_t *dest, sigset_t *left, sigset_t *right);int sigandset (sigset_t *dest, sigset_t *left, sigset_t *right); 9.6 阻塞信号 临界区：程序中某些部分在运行时不被信号中断。 阻塞信号：临时挂起信号，以保护临界区。 被进程阻塞的信号叫做该进程的信号掩码。 POSIX 定义，Linux 实现了一个管理进程信号掩码的函数： 12#include &lt;signal.h&gt;int sigprocmask (int how, const sigset_t *set, sigset_t *oldset); how：SIG_SETMASK、SIG_BLOCK、SIG_UNBLOCK 9.6.1 获取待处理信号 获取待处理信号集合： 12#include &lt;signal.h&gt;int sigpending (sigset_t *set); 9.6.2 等待信号集 POSIX 使用 sigsuspend() 允许进程临时改变信号掩码的函数： 12#include &lt;signal.h&gt;int sigsuspend (const sigset_t *set); 9.7 高级信号管理 POSIX 定义了 sigaction() 系统调用，提供更强大的信号管理能力。 1234#include &lt;signal.h&gt;int sigaction (int signo, const struct sigaction *act, struct sigaction *oldact); sigaction 结构允许精细地控制信号： 1234567struct sigaction &#123; void (*sa_handler)(int); /* 信号处理程序或操作 */ void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; /* 阻塞的信号 */ int sa_flags; /* 标志 */ void (*sa_restorer)(void); /* 已经过时且不符合 POSIX 标准 */&#125; 设置 sa_flags 为 SIG_SIGINFO 时，通过 sa_sigaction 指示信号处理函数。 信号处理程序可以通过 siginfo_t 结构获取丰富信息。 9.7.1 siginfo_t 结构 12345678910111213141516typedef struct siginfo_t &#123; int si_signo; /* 信号编号 */ int si_errno; /* errno 值 */ int si_code; /* 信号代码 */ pid_t si_pid; /* 发送进程PID */ uid_t si_uid; /* 发送进程的真实UID */ int si_status; /* 退出值或信号 */ clock_t si_utime; /* 用户时间消耗 */ clock_t si_stime; /* 系统时间消耗 */ sigval_t si_value; /* 信号载荷值 */ int si_int; /* POSIX.1b 信号*/ void *si_ptr; /* POSIX.1b 信号 */ void *si_addr; /* 造成错误的内存位置 */ int si_band; /* 带事件 */ int si_fd; /* 文件描述符 */&#125; 9.7.2 si_code 的精彩世界 对于用户发送的信号，该域说明信号是如何被发送的。 对于内核发送的信号，该域说明信号发生的原因。 9.8 发送带附加信息的信号 由 POSIX 定义的 sigqueue() 函数，允许进程发送带附加信息的信号： 1234#include &lt;signal.h&gt;int sigqueue (pid_t pid, int signo, const union sigval value); 9.8.1 例子 123456sigval value;int ret;value.sival_int = 404;ret = sigqueue (1722, SIGUSR2, value);if (ret) perror (&quot;sigqueue&quot;); 9.9 结论 在多线程程序和循环事件中，信号不合适。 信号的不便之处： 很难写出一个安全的可重入的信号处理程序。 程序员仍然使用 signal() 和 kill() 而不是 sigaction() 和 sigqueue() 来管理信号。","categories":[{"name":"阅读","slug":"阅读","permalink":"http://aaaris.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"Linux系统编程 第八章","slug":"Linux系统编程/Linux系统编程 第八章","date":"2022-10-24T12:55:39.017Z","updated":"2024-03-14T08:35:49.793Z","comments":true,"path":"2022/10/24/Linux系统编程/Linux系统编程 第八章/","link":"","permalink":"http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E5%85%AB%E7%AB%A0/","excerpt":"","text":"Linux系统编程 第八章 内存管理 8.1 进程地址空间 Linux 内核为每个进程维护一个特殊的虚拟地址，从 0 开始。 8.1.1 页和页面调度 页大小包括 4K (32 bit)，8K (64 bit)。 每个页面有两种状态： 有效——与物理页或者一些二级存储介质相关联 无效——未分配或使用 8.1.1.1 共享和写时复制 虚存中的多个页面可能被映射到同个物理页面。 当一个进程试图写共享页： 内核允许 产生异常，内核进行写时拷贝。 8.1.2 存储器区域 内核将某些相同特征（例如读写权限）的页组织成块——段。 每个进程可见的段： 文本段：只读数据——代码、字符串 堆栈段：执行栈 数据段：（heap）动态存储空间，可写。 BSS 段：未被初始化的全局变量 映射文件：C 可链接库，映像文件等。 8.2 动态内存分配 malloc() 获取动态内存： 12#include &lt;stdlib.h&gt;void *malloc (size_t size); C 会自动把返回值由 void 指针转变为需要的类型，C++ 不提供这种自动转换。 例子 xmalloc() ： 123456789101112/* like malloc(), but terminates on failure */void *xmalloc (size_t size)&#123; void *p; p = malloc (size); if (!p) &#123; perror (&quot;xmalloc&quot;); exit (EXIT_FAILURE); &#125; return p;&#125; 8.2.1 数组分配 元素大小确定，个数不确定，C 提供 calloc() 函数解决这个问题： 12#include &lt;stdlib.h&gt;void *calloc (size_t nr, size_t size); 例子： 1234567891011int *x, *y;x = malloc (50 * sizeof (int));if (!x) &#123; perror (&quot;malloc&quot;); return -1;&#125;y = calloc (50, sizeof (int));if (!y) &#123; perror (&quot;calloc&quot;); return -1;&#125; 以上得到的内存大小是一样的，但 calloc 会用二进制0 进行初始化。 自定义接口： 1234567891011/* like malloc( ), but zeros memory and terminates on failure */void *xmalloc0 (size_t size)&#123; void *p; p = calloc (1, size); if (!p) &#123; perror (&quot;xmalloc0&quot;); exit (EXIT_FAILURE); &#125; return p;&#125; 8.2.2 调整已分配内存大小 12#include &lt;stdlib.h&gt;void *realloc (void *ptr, size_t size); 当已有空间无法增加到 size 时，就会另外申请 size 内存并有拷贝操作。 如果 size 为零，效果就会和 ptr 上调用 free() 相同 8.2.3 动态内存的释放 动态内存分配，必须被显示释放。 12#include &lt;stdlib.h&gt;void free (void *ptr); ptr 必须是分配函数的返回值，不能用 free() 来释放申请到的部分内存。 memory leak use-after-free 8.2.4 对齐 自然对齐：一个变量的地址是它大小的倍数。 8.2.4.1 预对齐内存的分配 一般，编译器和 C 库会自动处理对齐问题。 对于页面等更大的边界， POSIX 提供 posix_memalign() 函数进行动态对齐。 12345/* one or the other -- either suffices */#define _XOPEN_SOURCE 600#define _GNU_SOURCE#include &lt;stdlib.h&gt;int posix_memalign (void **memptr, size_t alignment, size_t size); BSD 和 SunOS 提供 valloc() 接口 123#include &lt;malloc.h&gt;void * valloc (size_t size);void * memalign (size_t boundary, size_t size); 优先选择 posix_memalign() 8.2.4.2 其他对齐问题 非标准类型的对齐——处理指针和强转时产生错误。 8.3 数据段的管理 123#include &lt;unistd.h&gt;int brk (void *end);void * sbrk (intptr_t increment); brk() 会设置数据段的末端地址为 end，sbrk() 将数据段的末端增加 increment 字节并返回更新后的字节。 8.4 匿名存储器映射 buddy memory allocation scheme 算法： 划分大小为 2 的幂的块，返回最小符合块。 释放则标记为未使用。 如果相邻分区空闲，则进行合并。 堆顶空闲，使用 brk() 归还内存。 GLIBC —— arena 算法： 维护释放的内存，后续分配使用 使用匿名内存映射管理大分配。 匿名内存映射类似文件映射，但没有对应的文件。 8.4.1 创建匿名存储器映射 例子，mmap() 中进行 MAP_ANONYMOUS 设置： 1234567891011void *p;p = mmap (NULL, /* do not care where */ 512 * 1024, /* 512 KB */ PROT_READ | PROT_WRITE, /* read/write */ MAP_ANONYMOUS | MAP_PRIVATE, /* anonymous, private */ -1, /* fd (ignored) */ 0); /* offset (ignored) */if (p == MAP_FAILED) perror (&quot;mmap&quot;);else/* ’p’ points at 512 KB of anonymous memory... */ 调用 munmap() 释放一个匿名映射： 123456int ret;/* all done with ’p’, so give back the 512 KBmapping */ret = munmap (p, 512 * 1024);if (ret) perror (&quot;munmap&quot;); 8.4.2 映射到 /dev/zero 对于没有 MAP_ANONYMOUS 标志的系统，使用 /dev/zeror 实现了类似的解决方案。 1234567891011121314151617181920212223242526void *p;int fd;/* open /dev/zero for reading and writing */fd = open (&quot;/dev/zero&quot;, O_RDWR);if (fd &lt; 0) &#123; perror (&quot;open&quot;); return -1;&#125;/* map [0,page size) of /dev/zero */p = mmap (NULL, /* do not care where */ getpagesize ( ), /* map one page */ PROT_READ | PROT_WRITE, /* map read/write */ MAP_PRIVATE, /* private mapping */ fd, /* map /dev/zero */ 0); /* no offset */if (p == MAP_FAILED) &#123; perror (&quot;mmap&quot;); if (close (fd)) perror (&quot;close&quot;); return -1;&#125;/* close /dev/zero, no longer needed */if (close (fd)) perror (”close”);/* ’p’ points at one page of memory, use it... */ 8.5 高级存储器分配 mallopt() 调用可以用于改变一些内核参数。 M_CHECK_ACTION M_MMAP_MAX 最大存储器映射 M_MMAP_THRESHOLD 使用匿名映射和数据段之间的阈值 M_MXFAST fast bin 的最大大小 M_TOP_PAD 调整数据段使用的填充字节数 需要在调用内存分配函数之前使用 mallopt() 8.5.1 使用 malloc_usable_size() 和 malloc_trim() 进行调优 malloc_usable_size() 用来查询已分配块拥有的可用字节数。 12#include &lt;malloc.h&gt;size_t malloc_usable_size (void *ptr); malloc_trim() 允许程序强制 glibc 归还所有的可释放的动态内存给内核： 12#include &lt;malloc.h&gt;int malloc_trim (size_t padding); 它们是不可移植的，且会暴露底层细节。 8.6 调试内存分配 程序可以设置 MALLOC_CHECK_ 环境变量来开启存储系统额外的调试功能。 执行如下指令： 1MALLOC_CHECK_=1 ./rudder 8.6.1 获得统计数据 Linux 提供 mallinfo() 函数来获得关于动态存储分配系统的统计数据： 12#include &lt;malloc.h&gt;struct mallinfo mallinfo (void); Linux 提供 stats() 函数，将更内存相关的统计数据打印到标准错误输出： 12#include &lt;malloc.h&gt;void malloc_stats (void); 8.7 基于栈的分配 使用 alloca() 在栈中实现动态内存分配： 12#include &lt;alloca.h&gt;void * alloca (size_t size); 由于内存在栈中，当调用它的函数返回时，这块内存将被自动释放。 例子： 123456789int open_sysconf (const char *file, int flags, int mode)&#123; const char *etc = SYSCONF_DIR; /* ”/etc/” */ char *name; name = alloca (strlen (etc) + strlen (file) +1); strcpy (name, etc); strcat (name, file); return open (name, flags, mode);&#125; 不能将由 alloca() 得到的内存来作为一个函数调用的参数。 8.7.1 栈中的字符串 alloca() 常见的用法是用来临时复制一个字符串： 123456/* we want to duplicate ’song’ */char *dup;dup = alloca (strlen (song) + 1);strcpy (dup, song);/* manipulate ’dup’... */return; /* ’dup’ is automatically freed */ 由于 alloca() 高效，Linux 系统专门提供了 strdup() 来将给定字符串复制到栈中： 1234#define _GNU_SOURCE#include &lt;string.h&gt;char * strdupa (const char *s);char * strndupa (const char *s, size_t n); 如果考虑移植性，不鼓励使用这些函数。 然而在 Linux 上，alloca() 及其衍生函数，通过移动栈指针替代复杂的动态分配内存方法，带来高效性能是很方便的。 8.7.2 变长数组 C99 引进了变长数组（VLAs），其长度是在运行时决定的并非编译时。 VLAs 用于 alloca() 相似的方法避免了动态存储分配所产生的负载。 例子，利用变长数组，重写 open_sysconf() 函数： 123456789int open_sysconf (const char *file, int flags, int mode)&#123; const char *etc; = SYSCONF_DIR; /* ”/etc/” */ char name[strlen (etc) + strlen (file) + 1]; strcpy (name, etc); strcat (name, file); return open (name, flags, mode);&#125; VLAs 和 alloca() 的区别在于内存的释放时间。 VLAs 获得的内存在出了作用域后就释放，alloca() 直到函数返回才释放。 8.8 选择一个合适的内存分配机制 8.9 存储器操作 8.9.1 字节设置 memset() 将从 s 指向区域开始的 n 个字节设置为 c，返回 s。 12#include &lt;string.h&gt;void * memset (void *s, int c, size_t n); memset() 常用于将一块内存清零。 如果你可以使用 calloc() 分配内存那就坚决不用 memset()。 8.9.2 字节比较 类似 strcmp()，memcmp() 比较两块内存是否相等： 12#include &lt;string.h&gt;int memcmp (const void *s1, const void *s2, size_t n); 8.9.3 字节移动 memmove() 复制 src 的前 n 字节到 dst，返回 dst： 12#include &lt;string.h&gt;void * memmove (void *dst, const void *src, size_t n); memmove() 可以安全地处理内存区域重叠问题。 例外，不支持内存覆盖的 memmove() 变种： 12#include &lt;string.h&gt;void * memcpy (void *dst, const void *src, size_t n); 另外一个安全复制函数是 memccpy()： 12#include &lt;string.h&gt;void * memccpy (void *dst, const void *src, int c, size_t n); 最后我们可以使用 mempcpy() 来跨过拷贝的内存： 123#define _GNU_SOURCE#include &lt;string.h&gt;void * mempcpy (void *dst, const void *src, size_t n); mempcpy() 和 memcpy() 几乎一样，区别在于前者返回 dst + n。 8.9.4 字节搜索 函数 memchr() 和 memrchr() 可以在内存块中搜索一个给定的字节： 12#include &lt;string.h&gt;void * memchr (const void *s, int c, size_t n); memrchr() 是反向搜索： 1234#define _GNU_SOURCE#include &lt;string.h&gt;void * memrchr (const void *s, int c, size_t n); 对于复杂搜索，memmem() 函数可以在一块内存中搜索任意的字节数组： 1234#define _GNU_SOURCE#include &lt;string.h&gt;void * memmem (const void *haystack, size_t haystacklen, const void *needle, size_t needlelen); 8.9.5 字节加密 简单加密接口（与 42 进行异或操作）： 123#define _GNU_SOURCE#include &lt;string.h&gt;void * memfrob (void *s, size_t n); 8.10 内存锁定 当虚拟内存页和实际页帧相“关联”，并保持该状态（称为锁定）。 Linux 实现了请求页面调度：需要时才将页面从硬盘交换进来。 进程的虚拟地址空间拥有近乎无限物理内存——由于页面调度，虚拟内存页未被锁定 不考虑==确定性，安全性==的情况下，应用尽量不要改变内核的行为。 8.10.1 锁定部分地址空间 POSIX 指定 mlock() 函数锁定给定地址区间，保证不会被交换到磁盘： 12#include &lt;sys/mman.h&gt;int mlock (const void *addr, size_t len); POSIX 标准要求 addr 应该与页对齐。 8.10.2 锁定全部地址空间 POSIX 定义 mlockall() 函数在物理内存中锁定进程的全部地址空间。 12#include &lt;sys/mman.h&gt;int mlockall (int flags); 8.10.3 内存解锁 POSIX 提供两个接口进行内存解锁： 123#include &lt;sys/mman.h&gt;int munlock (const void *addr, size_t len);int munlockall (void); 内存锁定并不会重叠。故mlock() 或 mlockall() 调用次数无需考虑，页面的解除只需一次。 8.10.4 锁定的限制 CAP_IPC_LOCK 权限的进程能锁定任意多的页面。 此外，进程最多锁定 RLIMIT_MEMLOCK 个字节。 8.10.5 这个页面在物理内存中吗？ Linux 提供 mincore() 方便调试： 123#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;int mincore (void *start, size_t length, unsigned char *vec); 8.11 投机性存储分配策略 Linux 使用投机分配策略： 当进程请求内存，内核做出分配承诺但未进行分配。 仅当进程对“分配”内存写操作时，内核才真正进行分配。 8.11.1 超量使用和内存耗尽 超量使用：使用的内存仅仅是请求内存中进行写操作的页面大小。 内存耗尽（OOM）：当超量使用导致内存不足，内核进行选择终止一个进程。","categories":[{"name":"阅读","slug":"阅读","permalink":"http://aaaris.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"Linux系统编程 第七章","slug":"Linux系统编程/Linux系统编程 第七章","date":"2022-10-24T12:52:16.828Z","updated":"2022-11-05T02:22:33.986Z","comments":true,"path":"2022/10/24/Linux系统编程/Linux系统编程 第七章/","link":"","permalink":"http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E4%B8%83%E7%AB%A0/","excerpt":"","text":"Linux系统编程 第七章 文件与目录管理 7.1 文件及其元数据 7.1.1 一组 stat 函数 123456#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;int stat (const char *path, struct stat *buf);int fstat (int fd, struct stat *buf);int lstat (const char *path, struct stat *buf); 结构 stat 存储了获取的文件信息。 stat() 返回由路径 path 指明的文件信息。 fstat() 返回由 fd 指向的文件信息。 lstat() 类似 stat() 但返回符号链接本身。 例子： 1234567891011121314151617181920#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main (int argc, char *argv[])&#123; struct stat sb; int ret; if (argc &lt; 2) &#123; fprintf (stderr, &quot;˖usage %s &lt;file&gt;\\n&quot;, argv[0]); return 1; &#125; ret = stat (argv[1], &amp;sb); if (ret) &#123; perror (&quot;stat&quot;); return 1; &#125; printf (&quot;%s is %ld bytes\\n&quot;, argv[1], sb.st_size); return 0;&#125; 7.1.2 权限 stat() 常用于获取给定文件的权限，使用 chmod() 和 fchmod() 设置权限： 1234#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;int chmod (const char *path, mode_t mode);int fchmod (int fd, mode_t mode); 二者均可设置文件权限为 mode。 调用进程的 euid 必须匹配文件的所有者，或如进程具有 CAP_FOWNER 能力。 例子： 123456789int ret;/** Set ’map.png’ in the current directory to* owner-readable and -writable. This is the* same as ’chmod 600 ./map.png’.*/ret = chmod (&quot;./map.png&quot;, S_IRUSR | S_IWUSR);if (ret) perror (&quot;chmod&quot;); 7.1.3 所有权 以下三个系统调用允许用户改变文件的所有者和所属群： 12345#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int chown (const char *path, uid_t owner, gid_t group);int lchown (const char *path, uid_t owner, gid_t group);int fchown (int fd, uid_t owner, gid_t group); chown() 和 lchown() 作用一样，但对于符号链接，lchown() 只改变符号链接文件的所有权。 只有 CAP_CHOWN 能力的进程能改变文件所有者。 文件所有者能改变文件所属组。 例子，用户具备 CAP_CHOWN 能力或用户是文件所有者且在 officers 组中： 12345678910111213141516struct group *gr;int ret;/** getgrnam( ) returns information on a group* given its name.*/gr = getgrnam (&quot;officers&quot;);if (!gr) &#123; /* likely an invalid group */ perror (&quot;getgrnam&quot;); return 1;&#125;/* set manifest.txt’s group to ’officers’ */ret = chown (&quot;manifest.txt&quot;, -1, gr-&gt;gr_gid);if (ret) perror (&quot;chown&quot;); 7.1.4 扩展能力 扩展属性与文件系统无关，内核将不同文件系统存储扩展属性的方式从扩展属性接口抽象出来。 7.1.4.1 键和值 每个扩展属性对应一个 key，key 采用 namespace.attribute 的形式。 Linux 对键和值没有限制，但文件系统限制了文件关联的所有键和值的总长度。 7.1.4.2 扩展属性命名空间 system 内核特性 （没有用户能访问） security 安全模块（只允许 CAP_SYS_ADMIN 写） trusted 用户空间限制信息（只允许 CAP_SYS_ADMIN 读写） user 普通标准命名空间 7.1.4.3 扩展属性操作 定义操作： 获取键值 设置键值 获取键列表 移除属性（键） 每个操作，三种系统调用： 操作路径 操作路径（符号链接本身） 操作 fd 7.2 目录 7.2.1 当前工作目录 cwd(current work dir) 7.2.1.1 获取当前工作目录 getcwd() 会以绝对路径形式获取 cwd： 12#include &lt;unistd.h&gt;char * getcwd (char *buf, size_t size); 例子： 12345678char *cwd;cwd = getcwd (NULL, 0);if (!cwd) &#123; perror (&quot;getcwd&quot;); exit (EXIT_FAILURE);&#125;printf (&quot;cwd = %s\\n&quot;, cwd);free (cwd); Linux 的 C 库也提供函数 get_current_dir_name() ，： 123#define _GNU_SOURCE#include &lt;unistd.h&gt;char * get_current_dir_name (void); 7.2.1.2 更改当前工作目录 123#include &lt;unistd.h&gt;int chdir (const char *path);int fchdir (int fd); Unix 没有修改不同进程当前工作目录的机制。 例子： 12345678910111213141516171819202122char *swd;int ret;/* save the current working directory */swd = getcwd (NULL, 0);if (!swd) &#123; perror (&quot;getcwd&quot;); exit (EXIT_FAILURE);&#125;/* change to a different directory */ret = chdir (some_other_dir);if (ret) &#123; perror (&quot;chdir&quot;); exit (EXIT_FAILURE);&#125;/* do some other work in the new directory... *//* return to the saved directory */ret = chdir (swd);if (ret) &#123; perror (&quot;chdir&quot;); exit (EXIT_FAILURE);&#125;free (swd); open打开当前目录，随后调用 fchidir() 的方式开销更小。 7.2.2 创建目录 123#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;int mkdir (const char *path, mode_t mode); 在 Linux，新建目录的权限位是（mode &amp; ~ umask &amp; 01777）。 7.2.3 移除目录 POSIX 调用 rmdir() 将目录从文件系统层次上移除： 12#include &lt;unistd.h&gt;int rmdir (const char *path); 7.2.4 读取目录内容 读取之前，先创建一个 DIR 对象指向的目录流： 123#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;DIR * opendir (const char *name); 目录流比打开目录的文件描述符增加了一些元数据和保存目录内容的缓冲区。 获取目录流的的文件描述符（BSD的扩展）： 1234#define _BSD_SOURCE /* or _SVID_SOURCE */#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;int dirfd (DIR *dir); 7.2.4.1 从目录流读取 使用 readdir() 可以获取 dir 指向的下一个目录项： 123#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;struct dirent * readdir (DIR *dir); POSIX 只要求 dirent 结构中的 d_name，若考虑移植性，应只访问 d_name 程序通过连续调用 readdir()，获取目录每个文件，直到目录读完 readdir() 返回 NULL。 7.2.4.2 关闭目录流 123#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;int closedir (DIR *dir); 例子，实现在给定目录中搜索指定文件： 1234567891011121314151617181920212223242526/** find_file_in_dir - searches the directory &#x27;path&#x27; for a* file named &#x27;file&#x27;.** Returns 0 if &#x27;file&#x27; exists in &#x27;path&#x27; and a nonzero* value otherwise.*/int find_file_in_dir (const char *path, const char *file)&#123; struct dirent *entry; int ret = 1; DIR *dir; dir = opendir (path); errno = 0; while ((entry = readdir (dir)) != NULL) &#123; if (!strcmp(entry-&gt;d_name, file)) &#123; ret = 0; break; &#125; &#125; if (errno &amp;&amp; !entry) perror (&quot;readdir&quot;); closedir (dir); return ret;&#125; 7.2.4.3 用于读取目录内容的系统调用 1234567891011#include &lt;unistd.h&gt;#include &lt;linux/types.h&gt;#include &lt;linux/dirent.h&gt;#include &lt;linux/unistd.h&gt;#include &lt;errno.h&gt;/** Not defined for user space: need to* use the _syscall3( ) macro to access.*/int readdir (unsigned int fd, struct dirent *dirp, unsigned int count);int getdents (unsigned int fd, struct dirent *dirp, unsigned int count); readir() 内部使用，不可移植。 7.3 链接 单个 inode 可以由多个名字（同一文件系统）指向。 唯一的限制是用来表示链接树的整数数据类型的范围。 7.3.1 硬链接 POSIX 标准使用 link() 为存在文件创建新链接： 12#include &lt;unistd.h&gt;int link (const char *oldpath, const char *newpath); oldpath 和 newpath 均指向同一个文件——无法确知初始链接。 例子： 12345678910int ret;/** create a new directory entry,* &#x27;/home/kidd/privateer&#x27;, that points at* the same inode as &#x27;/home/kidd/pirate&#x27;*/ret = link (&quot;/home/kidd/privateer&quot;, &quot;/home/kidd/pirate&quot;);if (ret) perror (&quot;link&quot;); 7.3.2 符号链接 软链接：不增加额外的目录项，而是一种特殊的文件类型——包含指向文件的路径名。 运行时，内核用指向文件路径名代替 symlinks 的路径名（除了&quot;l&quot;开头的系统调用）。 软连接可以指向一切位置（不存在的文件）。区别于硬链接，它可以跨越文件系统。 symlink() 系统调用创建指向 oldpath 的符号链接 newpath。 12#include &lt;unistd.h&gt;int symlink (const char *oldpath, const char *newpath); 12345678910int ret;/** create a symbolic link,* &#x27;/home/kidd/privateer&#x27;, that* points at &#x27;/home/kidd/pirate&#x27;*/ret = symlink (&#x27;/home/kidd/privateer&#x27;, &#x27;/home/kidd/pirate&#x27;);if (ret) perror (&quot;symlink&quot;); 7.3.3 解除链接 unlink() 从文件系统移除路径名，如果链接计数清零则会删除文件（不会移除目录）： 12#include &lt;unistd.h&gt;int unlink (const char *pathname); 为了简化对各种类型的删除，C 语言提供函数 remove()： 12#include &lt;stdio.h&gt;int remove (const char *path); 7.4 复制和移动文件 7.4.1 复制 需要独立实现。 7.4.2 移动 POSIX 对于多文件和目录操作都支持： 12#include &lt;stdio.h&gt;int rename (const char *oldpath, const char *newpath); 调用 rename() 将路径名 oldpath 重命名为 newpath。文件内容和 inode 保持不变 oldpath 和 newpath 必须位于同一文件系统。 mv 等工具必须通过一次调用复制和解除链接来完成这个操作。 7.5 设备节点 设备节点是应用程序和设备驱动交互的特殊文件。 应用发起请求 &gt;&gt; 内核转交给设备驱动 &gt;&gt; 驱动处理并返回结果 每个设备节点都有两个属性——主设备号和次设备号。 7.5.1 特殊设备节点 空设备 /dev/null 主 1 次 3，忽略写，读返回 EOF 零设备 /dev/zero 主 1 次 5，忽略写，读返回 null 满设备 /dev/full 主 1 次 7，写报错，读返回 null， 7.5.2 随机数生成器 内核的随机数生成器位于 /dev/random 和 /dev/urandom。 主设备号为1，次设备号分别是 8 和 9。 7.6 带外通信 使用 ioctl() 可以进行带外通信： 12#include &lt;sys/ioctl.h&gt;int ioctl (int fd, int request, ...); 例子，使用 CDROMEJECT 请求，弹出光盘： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/cdrom.h&gt;#include &lt;stdio.h&gt;int main (int argc, char *argv[])&#123; int fd, ret; if (argc &lt; 2) &#123; fprintf (stderr, &quot;usage: %s &lt;device to eject&gt;\\n&quot;, argv[0]); return 1; &#125; /* * Opens the CD-ROM device, read-only. O_NONBLOCK * tells the kernel that we want to open the device * even if there is no media present in the drive. */ fd = open (argv[1], O_RDONLY | O_NONBLOCK); if (fd &lt; 0) &#123; perror (&quot;open&quot;); return 1; &#125; /* Send the eject command to the CD-ROM device. */ ret = ioctl (fd, CDROMEJECT, 0); if (ret) &#123; perror (&quot;ioctl&quot;); return 1; &#125; ret = close (fd); if (ret) &#123; perror (&quot;close&quot;); return 1; &#125; return 0;&#125; 7.7 监视文件事件 Linux 提供监视文件接口 inotify 监控文件的移动，读写或删除。 7.7.1 初始化 inotify 初始化实例指向的文件描述符： 12#include &lt;inotify.h&gt;int inotify_init (void); 7.7.2 监视 watch descriptor —— 由 Unix Path 和 监视掩码（监视操作）组成。 inotify 可以监视目录，但不包括递归子目录。 7.7.2.1 增加新监视 inotify_add_watch() 在 path 上增加监视事件（mask）。 12#include &lt;inotify.h&gt;int inotify_add_watch (int fd, const char *path, uint32_t mask); 7.7.2.2 监视掩码 7.7.3 inotify 事件 使用 inotify_event 来描述监视事件。 123456789#include &lt;inotify.h&gt;struct inotify_event &#123; int wd; /* watch descriptor */ uint32_t mask; /* mask of events */ uint32_t cookie; /* unique cookie */ uint32_t len; /* size of ’name’ field */ char name[]; /* null-terminated name */&#125;; 在计算下个inotify_event 结构的偏移是，必须使用 len。 cookie 通常用来连接独立和相关事件。 7.7.3.1 读取 inotify 事件 123456789101112131415char buf[BUF_LEN]__attribute__((aligned(4)));ssize_t len, i = 0;/* read BUF_LEN bytes&#x27; worth of events */len = read (fd, buf, BUF_LEN);/* loop over every read event until none remain */while (i &lt; len) &#123; struct inotify_event *event = (struct inotify_event *) &amp;buf[i]; printf (&quot;wd=%d mask=%d cookie=%d len=%d dir=%s\\n&quot;, event-&gt;wd, event-&gt;mask, event-&gt;cookie, event-&gt;len, (event-&gt;mask &amp; IN_ISDIR) ? &quot;yes&quot; : &quot;no&quot;); /* if there is a name, print it */ if (event-&gt;len) printf (&quot;name=%s\\n&quot;, event-&gt;name); /* update the index to the start of the next event */ i += sizeof (struct inotify_event) + event-&gt;len;&#125; 通过 select()，poll()，epoll() 进行 I/O 多路传输 inotify 事件。 检查事件，应进行按位测试： 123456if (event-&gt;mask &amp; IN_ACCESS) printf (&quot;The file was read from!\\n&quot;);if (event-&gt;mask &amp; IN_UNMOUNTED) printf (&quot;The file’s backing device was unmounted!\\n&quot;);if (event-&gt;mask &amp; IN_ISDIR) printf (&quot;The file is a directory!\\n&quot;); 7.7.3.2 关联 “移动” 事件 cookie 非零时，则包含一个将两个事件连接的唯一值。 7.7.4 高级监视选项 IN_DONT_FOLLOW 、IN_MASK_ADD 、IN_ONESHOT、IN_ONLYDIR 7.7.5 删除 inotify 监视 调用 inotify_rm_watch() 从 inotify 实例中移除监视： 12#include &lt;inotify.h&gt;int inotify_rm_watch (int fd, uint32_t wd); 应用可以用专门 IN_IGNORED 事件处理函数来强化对事件移除处理。 7.7.6 获取事件队列大小 在 inotify 实例文件描述符上执行 ioctl 获取： 1234567unsigned int queue_len;int ret;ret = ioctl (fd, FIONREAD, &amp;queue_len);if (ret &lt; 0) perror (&quot;ioctl&quot;);else printf (&quot;%u bytes pending in queue\\n&quot;, queue_len); 返回的是队列的字节大小，而非队列的时间数（ sizeof 计算获取）。 7.7.7 销毁 inotify 实例 123456int ret;/* &#x27;fd&#x27; was obtained via inotify_init( ) */ret = close (fd);if (fd == -1) perror (&quot;close&quot;);","categories":[{"name":"阅读","slug":"阅读","permalink":"http://aaaris.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"Linux系统编程 第六章","slug":"Linux系统编程/Linux系统编程 第六章","date":"2022-10-24T12:52:03.293Z","updated":"2024-03-14T08:34:33.484Z","comments":true,"path":"2022/10/24/Linux系统编程/Linux系统编程 第六章/","link":"","permalink":"http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E5%85%AD%E7%AB%A0/","excerpt":"","text":"Linux系统编程 第六章 高级进程管理 6.1 进程调度 调度器：把有限的处理器资源分配给进程的内核子系统。 时间片：进程在被强占前所允许的时间称为进程时间片。 Linux 实现了抢占式多任务操作系统——要求一个进程停止，处理器允许另一个。 6.1.1 大 O 计法 Linux 调度器的实现算法是 O(1) 算法。 6.1.2 时间片 Linux 通过动态分配进程时间片，以平衡交互性能和系统吞吐量。 6.1.3 I/O 约束进程 Vs. 处理器约束进程 处理器约束进程：持续消耗时间片（科学计算，无限循环） I/O 约束进程：总是在等待资源的阻塞状态（GUI应用程序） 6.1.4 抢占调度 内核会基于所有耗光时间片的进程新的时间片，确保所有进程都运行。 如果没有就绪进程，内核会”运行“空闲进程（idle process）。 6.1.5 线程 Linux 内核把线程简化为共享资源的进程。 Linux 线程编程常用 API ”pthreads“。 6.2 让出处理器 sched_yield() 允许进程主动让出处理器，如果没有其他就绪进程，让出进程直接恢复。 12#include &lt;sched.h&gt;int sched_yield (void); 6.2.1 合理使用 消费者/生产者模型，消费之等待（常用阻塞机制）。 用户线程锁 内核能比独立进程做出更好的全局调度决策，一般不常用该调用。 6.2.2 让出处理器方法的过去和现状 2.6 内核之后，调整了算法，防止”乒乓“的不合理情况发生。 6.3 进程优先级 优先级：“nice values”。nice 值意味着对系统友好。nice 值越高，优先级越低，时间片越短。 Linux 调度器基于”高优先级程序先运行“的原则进行调度。 6.3.1 nice() nice() 将在现有优先级上增加 inc，并返回新值。 非 root 进程只能降低优先级（增加 inc）。 12#include &lt;unistd.h&gt;int nice (int inc); 6.3.2 getpriority() 和 setpriority() 1234#include &lt;sys/time.h&gt;#include &lt;sys/resource.h&gt;int getpriority (int which, int who);int setpriority (int which, int who, int prio); getpriority() 返回指定进程中的最高优先级，setpriority() 将所有进程的优先级都设为”prio“。 12345678910/* get current process&#x27;s priority */int ret;ret = getpriority (PRIO_PROCESS, 0);printf (&quot;nice value is %d\\n&quot;, ret);/* set all process&#x27;s priority to 10 in current process group */int ret;ret = setpriority (PGIO_PGRP, 0, 10);if (ret == -1)perror (&quot;setpriority&quot;); 6.3.3 I/O 优先级 缺省情况，I/O 调度器使用进程友好度决定 I/O 优先级。 因此，设置优先级自动改变 I/O 优先级。 6.4 处理器亲和度 处理器亲和度表明一个进程停留在同一处理器上的可能性。 软亲和度表明了调度器持续调度进程到同一处理器上的自然倾向。 硬亲和度描述了强制内核保证进程到处理器的绑定。 处理器的缓存独立，因此迁移进程会带来缓存效应。 6.4.1 sched_getaffinity() 和 sched_setaffinity() Linux 提供两个系统调用设定和获取进程的硬亲和度。 12345678910#define _GNU_SOURCE#include &lt;sched.h&gt;typedef struct cpu_set_t;size_t CPU_SETSIZE;void CPU_SET (unsigned long cpu, cpu_set_t *set);void CPU_CLR (unsigned long cpu, cpu_set_t *set);int CPU_ISSET (unsigned long cpu, cpu_set_t *set);void CPU_ZERO (cpu_set_t *set);int sched_setaffinity (pid_t pid, size_t setsize, const cpu_set_t *set);int sched_getaffinity (pid_t pid, size_t setsize, const cpu_set_t *set); 例子： 1234567891011121314cpu_set_t set;int ret, i;CPU_ZERO (&amp;set); /* clear all CPUs */CPU_SET (0, &amp;set); /* allow CPU #0 */CPU_CLR (1, &amp;set); /* forbid CPU #1 */ret = sched_setaffinity (0, sizeof (cpu_set_t), &amp;set);if (ret == -1) perror (&quot;sched_setaffinity&quot;);for (i = 0; i &lt; CPU_SETSIZE; i++) &#123; int cpu; cpu = CPU_ISSET (i, &amp;set); printf (&quot;cpu=%i is %s\\n&quot;, i, cpu ? &quot;set&quot; : &quot;unset&quot;);&#125; 6.5 实时系统 如果一个系统受到操作期限的支配（任务具有限定时间），称该系统是”实时“的。 特点：逻辑和时序出现出现偏差会引起严重后果的系统。 6.5.1 软硬实时系统 软实时系统：各个任务越快越好，不要求限定时间。 硬实时系统：各任务执行无误且准时。 6.5.2 延时，抖动和截止期限 延时：刺激发生到响应运行的时间。 抖动：连续事件中间的时间变化 6.5.3 Linux 的实时支持 POISX 标准仅仅描述了一些基于优先级的调度策略。 6.5.4 Linux 调度策略和优先级 6.5.4.1 ”先进先出“策略 只要没有高优先级进程就绪，FIFO 进程就会持续运行。 6.5.4.2 ”轮转“策略 类似 FIFO 类型，引入时间片来处理同优先级进程的规则。 6.5.4.3 普通调度策略 默认进程，静态优先级为0。 6.5.4.4 批调度策略 只在没有其他就绪进程时，才会运行。 6.5.4.5 设置 Linux 调度策略 通过 sched_getscheduler() 和 sched_setcheduler() 操作调度策略。 6.5.5 设置调度参数 POSIX 定义的 sched_getparam() 和 sched_setparam() 接口可以获取和设置已有调用策略的相关参数。 123456789#include &lt;sched.h&gt;struct sched_param &#123;/* ... */int sched_priority;/* ... */&#125;;int sched_getparam (pid_t pid, struct sched_param *sp);int sched_setparam (pid_t pid, const struct sched_param *sp); 6.5.5.1 错误码 6.5.5.2 确定有效优先级的范围 Linux 提供两个系统调用来获取优先级范围： 123#include &lt;sched.h&gt;int sched_get_priority_min (int policy);int sched_get_priority_max (int policy); 例子： 1234567891011121314151617181920212223/** set_highest_priority – set the associated pid’s scheduling* priority to the highest value allowed by its current* scheduling policy. If pid is zero, sets the current* process’s priority.** Returns zero on success.*/int set_highest_priority (pid_t pid)&#123; struct sched_param sp; int policy, max, ret; policy = sched_getscheduler (pid); if (policy == -1) return -1; max = sched_get_priority_max (policy); if (max == -1) return -1; memset (&amp;sp, 0, sizeof (struct sched_param)); sp.sched_priority = max; ret = sched_setparam (pid, &amp;sp); return ret;&#125; 程序一般获取系统的最值，然后按1递增（如max-1,max-2），分配给进程 6.5.6 sched_rr_get_interval() 在 Linux 上，它可以获取任意进程的时间片长度。 123456#include &lt;sched.h&gt;struct timespec &#123; time_t tv_sec; /* seconds */ long tv_nsec; /* nanoseconds */&#125;;int sched_rr_get_interval (pid_t pid, struct timespec *tp); 例子： 12345678910struct timespec tp;int ret;/* get the current task’s timeslice length */ret = sched_rr_get_interval (0, &amp;tp);if (ret == -1) &#123; perror (&quot;sched_rr_get_interval&quot;); return 1;&#125;/* convert the seconds and nanoseconds to milliseconds */printf (&quot;Our time quantum is %.2lf milliseconds\\n&quot;, (tp.tv_sec * 1000.0f) + (tp.tv_nsec / 1000000.0f)); 6.5.6.1 错误码 6.5.7 关于实时进程的一些提醒 开发时，保证高优先级程序存在。 6.5.8 确定性 确定性动作：输入相同，动作在相同的事件产生相同结果。 6.5.8.1 数据故障预测和内存锁 分页和交换给实时进程带来了很多不确定性。 实时应用往往“通过锁定”或者“硬连接”来将地址空间中的页提前放入物理内存，阻止被交换。 6.5.8.2 CPU 亲和度和实时进程 为每个实时进程保留一个处理器，剩余处理器共享使用。 6.6 资源限制 Linux 提供两个操作资源限制的系统调用： 12345678#include &lt;sys/time.h&gt;#include &lt;sys/resource.h&gt;struct rlimit &#123; rlim_t rlim_cur; /* soft limit */ rlim_t rlim_max; /* hard limit */&#125;;int getrlimit (int resource, struct rlimit *rlim);int setrlimit (int resource, const struct rlimit *rlim); 内核对进程强制实行软限制，但可被修改。非特权程序不能提升硬限制。 6.6.1 限制列表 RLIMIT_AS 进程地址空间 RLIMIT_CORE 内存转储文件 RLIMIT_CPU 使用的最长 CPU 时间 RLIMIT_DATA 进程数据段和堆大小 RLIMIT_FSIZE 创建文件大小 RLIMIT_LOCKS 文件锁数量（已移除） RLIMIT_MEMLOCK 非 root 程序锁定内存字节数 RLIMIT_MSGQUEUE 在消息队列中非陪的最多字节 RLIMIT_NICE 进程可以降低 nice 值 RLIMIT_NOFILE 打开的最多文件数 RLIMIT_NPROC 允许的最多进程数 RLMIT_RSS 进程驻留在内存中的最多页数 RLIMIT_RTPRIO 最大实时优先级 RLIMIT_SIGPENDING 消息队列中最多信号数 RLIMIT_STACK 栈最大字节长度 6.6.1.1 默认限制 约束变量：初始软限制，初始硬限制和系统管理员。 6.6.2 获取和设置资源限制 获取例子： 123456789struct rlimit rlim;int ret;/* get the limit on core sizes */ret = getrlimit (RLIMIT_CORE, &amp;rlim);if (ret == -1) &#123; perror (&quot;getrlimit&quot;); return 1;&#125;printf (&quot;RLIMIT_CORE limits: soft=%ld hard=%ld\\n&quot;, rlim.rlim_cur, rlim.rlim_max); 设置： 12345678910struct rlimit rlim;int ret;rlim.rlim_cur = 32 * 1024 * 1024; /* 32 MB */rlim.rlim_max = RLIM_INFINITY; /* leave it alone */ret = setrlimit (RLIMIT_CORE, &amp;rlim);if (ret == -1) &#123; perror (&quot;setrlimit&quot;); return 1;&#125; 6.6.2.1 错误码","categories":[{"name":"阅读","slug":"阅读","permalink":"http://aaaris.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"Linux系统编程 第五章","slug":"Linux系统编程/Linux系统编程 第五章","date":"2022-10-24T12:51:44.511Z","updated":"2022-11-05T02:22:28.105Z","comments":true,"path":"2022/10/24/Linux系统编程/Linux系统编程 第五章/","link":"","permalink":"http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E4%BA%94%E7%AB%A0/","excerpt":"","text":"Linux系统编程 第五章 进程管理 5.1 进程 ID 进程由 pid 作为唯一标识。 init 是内核运行的第一个进程，pid 为 1。 5.1.1 分配进程 ID 缺省情况，PID 最大限制为 32768（16位，向下兼容）。 内核分配 PID 是以严格的线性函数方式进行，保证同一时间 pid 的唯一性。 5.1.2 进程体系 创建新进程的称为父进程，新进程称为子进程，ppid 表示父进程 pid。 每个子进程都继承了父进程的用户和组，子进程通常属于其父进程所在的进程组便于通信。 5.1.3 pid_t 定义在 &lt;sys/types.h&gt; 中，在 Linux 中，通常是 C 语言的 int 类型。 5.1.4 获得进程 ID 和父进程 ID getpid() 返回调用进程 ID。 123#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t getpid (void); getppid() 返回调用进程的父进程 ID。 123#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t getppid (void); 5.2 运行新进程 exec()：载入内存并执行程序映像（运行一个新程序）。 fork()：创建一个新进程。 5.2.1 exec 系列系统调用 12#include &lt;unistd.h&gt;int execl (const char *path, const char *arg, ...); execl() 调用将 path 所指路径的映像载入内存，替换当前进程的映像，arg 是第一个参数，省略号代表可变长度的参数列表，以 NULL 结尾。 例子，如果你想编辑 /home/kidd/hooks.txt： 12345int ret;ret = execl (&quot;/bin/vi&quot;, &quot;vi&quot;, &quot;/home/kidd/hooks.txt&quot;, NULL);if (ret == -1) perror (&quot;execl&quot;); 通常 execl() 不会返回，调用会跳转到新程序入口作为结束。错误时返回 -1，并设置 errno。 execl() 改变了进程的一些属性： 挂起信号丢失。 捕捉信号还原为缺省方式。 内存的锁定（第八章）丢失。 线程属性还原为缺省值。 进程的统计信息复位。 与内存相关数据都会丢失，包括映射文件。 通常打开的文件描述符可以继承，但一般都在 exec 调用前关闭文件。 5.2.1.1 其他 exec 系列系统调用 123456#include &lt;unistd.h&gt;int execlp (const char *file, const char *arg, ...);int execle (const char *path, const char *arg, ..., char * const envp[]);int execv (const char *path, char *const argv[]);int execvp (const char *file, char *const argv[]);int execve (const char *filename, char *const argv[], char *const envp[]); 字母 l 和 v 分别表示参数是以 list 或者 vector 方式提供的。 字母 p 表示在用户的 PATH 环境变量中寻找可执行文件。 最后的 e 表示会提供给新进程以新的环境变量。 例子，使用 execvp() 来执行 vi： 12345const char *args[] = &#123; &quot;vi&quot;, &quot;/home/kidd/hooks.txt&quot;, NULL &#125;;int ret;ret = execvp (&quot;vi&quot;, args);if (ret == -1) perror (&quot;execvp&quot;); 5.2.1.2 错误返回值 成功调用时，exec 不会返回，失败返回 -1，设置 errno 5.2.2 fork() 系统调用 创建一个和当前进程映像一样的进程可以通过 fork() ： 123#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t fork (void); 成功的 fork() 返回0，在父进程中 fork() 返回子进程的 pid；失败返回 -1，设置 errno。 父子进程不同处： 父子进程 pid 不同。 子进程 ppid 设置为父进程 pid。 子进程中资源统计信息清零。 挂起信号清除。 文件锁时非继承的。 ”派生加执行“的方式是很常见的。 5.2.2.1 写时复制 如果进程要修改自己的资源”副本“，则进行复制并修改复制后的资源，其他进程仍然共享没修改过的资源。 在使用虚拟内存的情况下， Copy-on-write 是以页为基础进行的。 5.2.2.2 vfork 123#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t vfork (void); vfork() 会挂起父程序直到子进程终止或者运行新程序，以避免地址空间的按页复制。 实际上，vfork() 只做了一件事：复制内部的内核数据结构。 5.3 终止进程 12#include &lt;stdlib.h&gt;void exit (int status); exit() 会执行一些基本的终止步骤，然后通知内核终止进程。 在终止之前，C 语言函数执行以下工作： 以注册的逆序调用 atexit() 或 on_exit() 注册的函数 清空所有已打开的标准 I/O 流。 删除由 tmpfile() 创建的所有临时文件。 随后，exit() 调用 _exit() 让内核处理剩余工作。 12#include &lt;unistd.h&gt;void _exit (int status); vfork() 终止进程是，必须使用 _exit()，而不是 exit()。 5.3.1 其他终止进程的方式 main() 函数返回时，编译器会插入 _exit()。 进程收到终止信号，SIGTERM 和 SIGKILL。 进程被内核惩罚性终止（段错误、内存耗尽）。 5.3.2 atexit() atexit() 会把指定函数注册，在进程正常结束时进行调用。 12#include &lt;stdlib.h&gt;int atexit (void (*function)(void)); 函数存储在栈中，调用顺序和注册顺序相反， 以 LIFO 的方式调用。 注册函数不能调用 exit()，否则会引起递归。 例子： 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void out (void)&#123; printf (&quot;atexit( ) succeeded!\\n&quot;);&#125;int main (void)&#123; if (atexit (out)) fprintf(stderr, &quot;atexit( ) failed!\\n&quot;); return 0;&#125; 5.3.3 on_exit() 与 atexti() 一样，只是注册的函数原型不同。 12#include &lt;stdlib.h&gt;int on_exit (void (*function)(int , void *), void *arg); 5.3.4 SIGCHLD 当一个进程子程序终止时，内核会向其夫程序发送 SIGCHILD 信号。 进程可通过 signal() 或 sigaction() 系统调用来选择处理该信号。 5.4 等待终止的子进程 如果子进程在父进程之前结束，内核将子进程设置为一个特殊状态（僵死进程）。 进程只保留最小的概要信息，等待父进程来查询自己的信息，之后消失。 wait() 返回已终止子进程的 pid，或者 -1 表示出错，调用者会阻塞直到子进程终止。 123#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;pid_t wait (int *stauts); status 通常包含一些子进程的附加信息，POSIX 标准提供宏来解释 status： 123456789#include &lt;sys/wait.h&gt;int WIFEXITED (status);int WIFSIGNALED (status);int WIFSTOPPED (status);int WIFCONTINUED (status);int WEXITSTATUS (status);int WTERMSIG (status);int WSTOPSIG (status);int WCOREDUMP (status); 5.4.1 等待特定进程 使用 waitpid() 系统调用成功，返回状态改变的进程的 pid，错误时返回 -1，设置 errno。 123#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;pid_t waitpid (pid_t pid, int *status, int options); 5.4.2 其他等待子进程的方法 Linux 提供了 waitid()，该调用有更多的选项，并可以获取更详细的信息。 12#include &lt;sys/wait.h&gt;int waitid (idtype_t idtype, id_t id, siginfo_t *infop, int options); 5.4.3 BSD 中的 wait3() 和 wait4() 123456#include &lt;sys/types.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/resource.h&gt;#include &lt;sys/wait.h&gt;pid_t wait3 (int *status, int options, struct rusage *rusage);pid_t wait4 (pid_t pid, int *status, int options, struct rusage *rusage); 数字 3 和 4 实际上是指这两个函数分别有三个和四个参数。 wait3() 等待任何子进程改变状态，wait4() 等待有 pid 指定的子进程改变状态。 rsuage参数提供子进程资源的使用情况。 5.4.4 创建并等待一个新进程 system() 用于创建新进程并等待它结束。 123#define _XOPEN_SOURCE /* if we want WEXITSTATUS, etc. */#include &lt;stdlib.h&gt;int system (const char *command); 成功时，返回时是执行命令的返回状态；失败时返回 -1。 使用 system() 来运行一个简单的工具程序或 shell 脚本是很常见的。 利用 fork()、exec 系统调用和 waitpid() 实现一个 system() 的例子： 123456789101112131415161718192021222324252627282930/** my_system - synchronously spawns and waits for the command* &quot;/bin/sh -c &lt;cmd&gt;&quot;.** Returns -1 on error of any sort, or the exit code from the* launched process. Does not block or ignore any signals.*/int my_system (const char *cmd)&#123; int status; pid_t pid; pid = fork ( ); if (pid == -1) return -1; else if (pid == 0) &#123; const char *argv[4]; argv[0] = &quot;sh&quot;; argv[1] = &quot;-c&quot;; argv[2] = cmd; argv[3] = NULL; execv (&quot;/bin/sh&quot;, argv); exit (-1); &#125; if (waitpid (pid, &amp;status, 0) == -1) return -1; else if (WIFEXITED (status)) return WEXITSTATUS (status); return -1;&#125; 5.4.5 僵死程序 如果父进程在子进程之前结束了，内核会将遍历其所有子进程，并将 init() 设置为父进程。 5.5 用户和组 用户 ID 和组 ID 分别用 C 语言的 uid_t 和 gid_t 两个类型表示。 5.5.1 实际用户（组）ID、有效用户（组）ID 和保存设置的用户（组）ID uid（same as gid） desc 实际用户 ID 运行进程的用户 ID（继承父进程） 有效用户 ID 当前进程使用的用户 ID）（权限验证） 保存设置的用户 ID 进程原先的有效用户 ID 有效 ID 用于验证权限。 实际 ID 和保存设置 ID 的作用是允许非 root 进程在用户 ID 之间切换。 5.5.2 改变实际用户（组）ID 和保存设置的用户（组）ID setuid() 行为： 如果普通用户调用，则将有效 ID 设置为 uid。 如果由有效用户 ID 为0的进程调用，则将real、saved、effective ID 都设置为 uid。 1234#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int setuid (uid_t uid);int setgid (gid_t gid); 5.5.3 改变有效用户和组 ID Linux 提供两个 POSIX 定义函数来改变当前进程的有效用户 ID 和组 ID 的值： 1234#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int seteuid (uid_t euid);int setegid (gid_t egid); 与 setgid() 区别在于，有效 ID 为 0 的进程调用时，setegid() 只会改变有效用户 ID。 5.5.4 BSD 改变用户 ID 和组 ID 的方式 1234#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int setreuid (uid_t ruid, uid_t euid);int setregid (gid_t rgid, gid_t egid); 5.5.5 HP-UX 中改变用户 ID 和组 ID 的方式 1234#define _GNU_SOURCE#include &lt;unistd.h&gt;int setresuid (uid_t ruid, uid_t euid, uid_t suid);int setresgid (gid_t rgid, gid_t egid, gid_t sgid); 5.5.6 操作用户 ID 组 ID 的首选方法 非 root 使用 seteuid()；root 变三种用 setuid()，临时改变 euid 用 seteuid()。 5.5.7 对保存设置的用户 ID 的支持 检查 _POSIX_SAVED_IDS 宏。 5.5.8 获取用户 ID 和组 ID read ID : 1234#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;uid_t getuid (void);gid_t getgid (void) effective ID： 1234#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;uid_t geteuid (void);gid_t getegid (void); 5.6 会话和进程组 每个进程都属某个进程组，组内可以传递信号。 每个进程组由 pgid 作为唯一标识，且 pgid 就是组长进程 pid。 新用户登陆产生新会话，登陆 shell 作为会话首进程，会话囊括用户所有活动，并分配控制终端。 会话首进程 PID 等于 会话 ID。 进程组分为一个前台进程组和零个或多个后台进程组。 当用户退出终端，向前台进程组所有进程发送 SIGQUIT 信号。 当网络中断，向前台进程组所有进程发送 SIGHUP 信号。 当用户敲入终止键，向前台进程的所有进程发送 SIGINT 信号。 5.6.1 与会话相关的系统调用 如果进程不是某个进程组组长，调用 setsid() 会创建新会话，并创建新进程组。 12#include &lt;unistd.h&gt;pid_t setsid (void); 获取当前进程会话 ID： 123#define _XOPEN_SOURCE 500#include &lt;unistd.h&gt;pid_t getsid (pid_t pid); 5.6.2 与进程相关的系统调用 setpgid() 将 pid 进程的进程组 ID 设置为 pgid： 123#define _XOPEN_SOURCE 500#include &lt;unistd.h&gt;int setpgid (pid_t pid, pid_t pgid); 通过会话获取进程的进程组 ID： 123#define _XOPEN_SOURCE 500#include &lt;unistd.h&gt;pid_t getpgid (pid_t pid); 5.6.3 废弃的进程组函数 5.7 守护进程 守护进程在后台运行，不与控制终端关联。 创建守护进程步骤： 调用 fork()，创建新进程（未来的守护进程）。 父进程调用 exit()（保证守护进程不是组长进程）。 调用 setsid()，创建新会话和新进程组（取消关联终端）。 用 chdir() 改变工作目录为根目录。 关闭所有文件描述符。 将 三个标准文件重定向到 /dev/null 例子： 123456789101112131415161718192021222324252627282930313233#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/fs.h&gt;int main (void)&#123; pid_t pid; int i; /* create new process */ pid = fork ( ); if (pid == -1) return -1; else if (pid != 0) exit (EXIT_SUCCESS); /* create new session and process group */ if (setsid ( ) == -1) return -1; /* set the working directory to the root directory */ if (chdir (&quot;/&quot;) == -1) return -1; /* close all open files--NR_OPEN is overkill, but works */ for (i = 0; i &lt; NR_OPEN; i++) close (i); /* redirect fd’s 0,1,2 to /dev/null */ open (&quot;/dev/null&quot;, O_RDWR); /* stdin */ dup (0); /* stdout */ dup (0); /* stderror */ /* do its daemon thing... */ return 0;&#125; Unix 系统在 C 库中提供 daemon() 函数来简化以上工作： 12#include &lt;unistd.h&gt;int daemon (int nochdir, int noclose); 5.8 总结","categories":[{"name":"阅读","slug":"阅读","permalink":"http://aaaris.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"Linux系统编程 第四章","slug":"Linux系统编程/Linux系统编程 第四章","date":"2022-10-24T12:51:23.602Z","updated":"2022-11-05T02:22:24.545Z","comments":true,"path":"2022/10/24/Linux系统编程/Linux系统编程 第四章/","link":"","permalink":"http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E5%9B%9B%E7%AB%A0/","excerpt":"","text":"Linux系统编程 第四章 高级文件 I/O 4.1 散布 / 聚集 I/O 散布聚集 I/O 是一种可以在单次系统调用中操作多个缓冲区的 I/O 方法。 又称向量 I/O，第二章提到的可称作线性 I/O。 4.1.1 readv() 和 writev() readv() 从 fd 读取 count 个 segment 到 iov 描述的缓冲区中。 12#include &lt;sys/uio.h&gt;ssize_t readv (int fd, const struct iovec *iov, int count); writev() 从 iov 描述的缓冲区中读取 count 个 segment 的数据并写入 fd 中。 12#include &lt;sys/uio.h&gt;ssize_t writev (int fd, const struct iovec *iov, int count); 每个 iovec 结构体描述一个独立的缓冲区，我们称其为 segment 12345#include &lt;sys/uio.h&gt;strcut iovec &#123; void *iov_base; size_t iov_len;&#125;; 一组 segment 的集合称为 vector。 4.1.1.1 返回值 成功时返回读写的字节数，出错时返回 -1，设置 errno。 除了返回任何 read() 和 write() 可能返回的错误之外，标准定义两种额外错误。 EINVAL iov_len &gt; SSIZE_MAX EINVAL count &lt; 0 || count &gt; IOV_MAX = 1024 4.1.1.2 writev() 示例 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/uio.h&gt;int main () &#123; struct iovec iov[3]; ssize_t nr; int fd, i; char *buf[] = &#123;&quot;The term buccaneer comes from the word boucan.\\n&quot;, &quot;A boucan is a wooden frame used for cooking meat.\\n&quot;, &quot;Buccaneer is the West Indies name for a pirate.\\n&quot; &#125;; fd = open (&quot;buccaneer.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC); if (fd == -1) &#123; perror (&quot;open&quot;); return 1; &#125; /* fill out three iovec structures */ for (i = 0; i &lt; 3; i++) &#123; iov[i].iov_base = buf[i]; iov[i].iov_len = strlen (buf[i]) + 1; &#125; /* with a single call, write them all out */ nr = writev (fd, iov, 3); if (nr == -1) &#123; perror (&quot;writev&quot;); return 1; &#125; printf (&quot;wrote %d bytes\\n&quot;, nr); if (close (fd)) &#123; perror (&quot;close&quot;); return 1; &#125; return 0; &#125; 4.1.1.3 readv() 示例 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/uio.h&gt;int main ()&#123; char foo[48], bar[51], baz[49]; struct iovec iov[3]; ssize_t nr; int fd, i; fd = open (&quot;buccaneer.txt&quot;, O_RDONLY); if (fd == -1) &#123; perror (&quot;open&quot;); return 1; &#125; /* set up our iovec structures */ iov[0].iov_base = foo; iov[0].iov_len = sizeof (foo); iov[1].iov_base = bar; iov[1].iov_len = sizeof (bar); iov[2].iov_base = baz; iov[2].iov_len = sizeof (baz); /* read into the structures with a single call */ nr = readv (fd, iov, 3); if (nr == -1) &#123; perror (&quot;readv&quot;); return 1; &#125; for (i = 0; i &lt; 3; i++) printf (&quot;%d: %s&quot;, i, (char *) iov[i].iov_base); if (close (fd)) &#123; perror (&quot;close&quot;); return 1; &#125; return 0;&#125; 4.1.1.4 实现 简单的用户空间实现： 1234567891011121314151617181920#include &lt;unistd.h&gt;#include &lt;sys/uio.h&gt;ssize_t naive_writev (int fd, const struct iovec*iov, int count)&#123; ssize_t ret = 0; int i; for (i = 0; i &lt; count; i++) &#123; ssize_t nr; nr = write (fd, iov[i].iov_base, iov[i].iov_len); if (nr == -1) &#123; ret = -1; break; &#125; ret += nr; &#125; return ret;&#125; Linux 下readv() 和 writev() 作为系统调用实现，在内部使用散布 / 聚集 I/O。 实际上，内核里的所有 I/O 都是向量 I/O；read() 和 write() 是只有一个向量的向量 I/O。 4.2 Event Poll 接口 poll() 和 select() 调用必须遍历所有被监视的 fds，当 fds 数量增加时，性能就会出现瓶颈。 epoll() 使用三个系统调用解决这个问题： 初始化 epoll 上下文 从上下文中加入或删除需要监视的 fds 执行时间等待。 4.2.1 创建一个新的 epoll 实例 使用 epoll_create() 创建一个 epoll 上下文： 12#include &lt;sys/epoll.h&gt;int epoll_create (int size); 调用成功返回一个与 epoll 实例关联的 fd（方便后续调用），size 表示一个大概监听 fds 的数目。 出错时，返回 -1，设置 errno： errno desc EINVAL size &lt;= 0 ENFILE 系统达到打开文件数的上限 ENOMEM 内存不足 4.2.2 控制 epoll epoll_ctl() 可以向指定的 epoll 上下文中加入或删除文件描述符： 12#include &lt;sys/epoll.h&gt;int epoll_ctl (int epfd, int op, int fd, struct epoll_event *event); epoll event 结构体： 123456789struct epoll_event &#123; __u32 events; /* events */ union &#123; void *ptr; int fd; __u32 u32; __u64 u64; &#125; data;&#125;; 调用成功后，将关联 epoll 实例和 epfd。 参数 op 指定对 fd 要进行的操作，op有效值： op desc EPOLL CTL ADD add EPOLL CTL DEL del EPOLL CTL MOD modify event 参数描述 epoll 更具体的行为，结构体中 events 有效值： events desc EPOLLERR 文件出错（默认） EPOLLET 边沿触发 EPOLLHUP 文件挂起（默认） EPOLLIN 未阻塞，可读 EPOLLONESHOT 只监听一次操作 EPOLLOUT 未阻塞，可写 EPOLLPRI 高优带外可读 event_poll 中的 data 字段由用户使用，通过访问 data.fd 可知触发事件的 fd。 成功返回 0，失败返回 -1，设置 errno： errno desc EBADF bad fd EEXIST epfd 已存在 EINVAL epfd 不是一个epoll实例epfd = fdop 无效 ENOENT fd 与 epfd 未关联 ENOMEM 内存不足 EPERM fd 不支持 epoll 4.2.3 等待 Epoll 事件 epoll_wait() 等待给定 epoll 实例关联的文件描述符上的事件： 123#include &lt;sys/epoll.h&gt;int epoll_wait (int epfd, struct epoll_event *events, int maxevents, int timeout); arg desc epfd epoll 实例 epfd events 触发事件 maxevents 最多触发事件个数 timeout 时限 成功返回事件数目，出错返回 -1，并设置 errno errno desc EBADF epfd 无效 EFAULT 无权限操作 events 指向的内存 EINTR 信号中断 EINVAL epfd 无效，或 maxevents 大于小于0 4.2.4 边沿触发时间和水平触发事件 状态：可读 边沿触发：状态改变发生。（即使已经可读，仍等到有东西写入后返回） 水平触发：状态发生时触发。（可读就返回） 4.3 存储映射 将文件映射到内存中，通过内存操作文件。 4.3.1 mmap() 请求内核将 fd 从 offset 开始的 len 个字节数据映射到内存中。 123#include &lt;sys/mman.h&gt;void * mmap (void *addr, size_t len, int prot, int flags int fd, off_t offset); arg desc addr 内存映射文件最佳地址 prot 访问权限 flags 映射类型和行为 映射后，文件描述符引用计数会增加。 4.3.1.1 页大小 mmap() 调用操作页，addr 和 offset 必须按页大小对齐。 页大小可以通过三种方式获取： &lt;unistd.h&gt; 的 sysconf (_SC_PAGESIZE)（best choice） &lt;unistd.h 的 getpagesize()（Linux 支持，移植性差） &lt;asm/pages.h&gt; 中 的宏定义 PAGE_SIZE（编译时确定，移植性差） 4.3.1.2 返回值和错误码 成功返回映射区地址；失败时，返回 MAP_FAILED，设置 errno。 4.3.1.3 相关信号 signal desc SIGBUS 访问映射区无效。如文件映射后截短 SIGSEGV 映射区只读不可写。 4.3.2 munmap() Linux 提供 munmap() 来取消 mmap() 的映射。 munmap() 移除从 addr 开始的进程地址，len 字节长的所有内存映射。 12#include &lt;sys/mman.h&gt;int munmap (void *addr, size_t len); 成功返回 0；失败返回 -1，设置 errno。 4.3.3 存储映射例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;int main (int argc, char *argv[])&#123; struct stat sb; off_t len; char *p; int fd; if (argc &lt; 2) &#123; fprintf (stderr, &quot;usage: %s &lt;file&gt;\\n&quot;, argv[0]); return 1; &#125; fd = open (argv[1], O_RDONLY); if (fd == -1) &#123; perror (&quot;open&quot;); return 1; &#125; if (fstat (fd, &amp;sb) == -1) &#123; perror (&quot;fstat&quot;); return 1; &#125; if (!S_ISREG (sb.st_mode)) &#123; fprintf (stderr, &quot;%s is not a file\\n&quot;, argv[1]); return 1; &#125; p = mmap (0, sb.st_size, PROT_READ, MAP_SHARED, fd, 0); if (p == MAP_FAILED) &#123; perror (&quot;mmap&quot;); return 1; &#125; if (close (fd) == -1) &#123; perror (&quot;close&quot;); return 1; &#125; for (len = 0; len &lt; sb.st_size; len++) putchar (p[len]); if (munmap (p, sb.st_size) == -1) &#123; perror (&quot;munmap&quot;); return 1; &#125; return 0;&#125; 4.3.4 mmap() 的优点 避免用户缓冲区带来的多余的数据拷贝。 直接操作内存，开销小。 多进程映射同一对象到内存中时，数据共享。 用指针定位，无需 lseek()。 4.3.5 mmap() 的缺陷 由于映射页对齐带来的内存页空间浪费。 对于 32 位进程地址空间，大片连续的空内存少。 创建和维护映射以及相关内核数据结构有一定开销。 处理大文件、页对齐文件，mmap() 优势明显。 4.3.6 调整映射的大小 Linux （特有）提供 mremap() 来调整映射大小。 mremap() 将 [addr, addr + old_size) 的大小调整为 new_size。 根据大小和设置的 flags {0, MREMAP_MAYMOVE}，内核可以同时移动映射区。 12345#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;void * mremap (void *addr, size_t old_size, size_t new_size, unsigned long flags); 4.3.6.1 返回值和错误码 成功返回新区域的指针，失败返回 MAP_FAILED，设置 errno。 glibc 常用 mremap() 实现高效 realloc()，来调整 malloc() 分配的内存。 4.3.7 改变映射内存区域的权限 POSIX 定义了 mprotect()，允许程序改变内存区的权限： 12#include &lt;sys/mman.h&gt;int mprotect (const void *addr, size_t len, int prot); prot 值是非累积的。 如果一块可读区域将 mprotect 的 prot值设置为 PROT_WRITE，则调用后为只写。 4.3.7.1 返回值和错误码 成功返回 0；失败返回 -1，设置 errno。 4.3.8 使用映射机制同步文件 POSIX 提供一个使用存储映射机制并与 fsync() 等价的系统调用： 12#include &lt;sys/mman.h&gt;int msync (void *addr, size_t len, int flags); 调用 msync() 将映射内存修改回写到磁盘中，从而同步映射和被映射文件。 与 write() 不同，内存映射写入由进程直接修改内核页缓存，不经过内核。（待补充） 4.3.8.1 返回值和错误码 调用成功返回 0；失败返回 -1，设置 errno。 4.3.9 映射提示 为了更好利用映射区域，Linux 提供 madvise() 系统调用，指示内核如何进行操作。 12#include &lt;sys/mman.h&gt;int madvise (void *addr, size_t len, int advice); 程序可以通过 madvise() 来影响预读窗口的大小（设置连续访问或随机访问）。 4.3.9.1 返回值和错误码 成功返回 0，失败返回 -1 设置 errno。 4.4 普通文件 I/O 提示 4.4.1 posix_fadvise() 12#include &lt;fcntl.h&gt;int posix_fadvise (int fd, off_t offset, off_t len, int advise); 调用 posix_fadvise() 会给出内核在文件位置范围内操作提示。 如果 len = 0，则提示作用于区间 [offset, length of file]。 一般 len 和 offset 都置 0，从而使提示作用到整个文件。 示例——要求内核随机、无序的访问 fd 代表的文件： 1234int ret;ret = posix_fadvise (fd, 0, 0, POSIX_FADV_RANDOM);if (ret == -1) perror (”posix_fadvise”); 4.4.1.1 返回值和错误码 调用成功返回 0，失败返回 -1，设置 errno 4.4.2 readahead() 系统调用 12#include &lt;fcntl.h&gt;ssize_t readahead (int fd, off64_t offset, size_t count); readahead() 调用将读入 fd 的 [offset, offset + count) 区域到页缓存中。 4.4.2.1 返回值和错误码 成功返回 0，失败返回 -1，设置 errno 4.4.3 ”经济实用“的操作提示 读取文件的大部分内容，设置 POSIX_FADV_WILLNEED 要求内核预读文件。 读写了大量数据后，设置 POSIX_FADV_DONTNEED 要求内核丢弃缓冲内容。 进程试图读整个文件时，设置 POSIX_FADV_SEQUENTIAL 要求内核大量预读。 进程试图随机访问文件，设置 POSIX_FADV_RANDOM 告诉内核不进行预读。 4.5 同步，同步及异步操作 synchronous 和 asynchronous 指 I/O 操作在返回前是否等待某些事件的返回。 synchronized 和 asynchronized 准确指定了某个事件必须发生（例如写回）。 一个 synchronized 操作要比 synchronous 操作的限制更多也更安全。 4.5.1 异步 I/O Linux 实现了 aio，aio 库提供了一系列函数来实现异步 I/O 提交以及在完成时收到提示。 12345678910111213141516171819#include &lt;aio.h&gt;/* asynchronous I/O control block */struct aiocb &#123; int aio_filedes; /* file descriptor */ int aio_lio_opcode; /* operation to perform */ int aio_reqprio; /* request priority offset */ volatile void *aio_buf; /* pointer to buffer */ size_t aio_nbytes; /* length of operation */ struct sigevent aio_sigevent; /* signal number and value */ /* internal, private members follow... */&#125;;int aio_read (struct aiocb *aiocbp);int aio_write (struct aiocb *aiocbp);int aio_error (const struct aiocb *aiocbp);int aio_return (struct aiocb *aiocbp);int aio_cancel (int fd, struct aiocb *aiocbp);int aio_fsync (int op, struct aiocb *aiocbp);int aio_suspend (const struct aiocb * const cblist[], int n, const struct timespec *timeout); 4.5.1.1 基于线程的异步 I/O Linux 只支持使用 O_DIRECT 标志打开的文件上的 aio。对于普通文件，需要自己实现异步。 以下是使用线程方法，所要完成的任务： 创建一个线程池来处理所有的 I/O。 实现将 I/O 操作加入工作队列的一系列函数。 使这些函数返回唯一的 I/O 描述符，来区分相关的 I/O 操作。每个工作线程响应队列首的 I/O 请求，提交到内核，等待他们完成。 完成后，把操作的结果加入到一个结果队列中。 实现一些列从结果队列中获取状态信息的函数，使用最初返回的 I/O 描述符区分每个操作。 以上与 aio 相关函数行为相近，但增加了线程管理开销。 4.6 I/O 调度器和 I/O 性能 I/O 调度器：通过管理请求的顺序和次数，使得磁盘寻道次数和移动距离最小化。 4.6.1 磁盘寻址 CHS 寻址：柱面 （cylinders）（r），磁头（heads）（z）和扇区（section）（θ） LBA 寻址：硬盘驱动转换块号（物理块）到正确的 CHS 地址。 文件系统操作单元是逻辑块，逻辑块映射到一个或多个硬盘物理块。 4.6.2 调度器的功能 I/O 调度器实现两个基本操作：合并（两个或多个相邻请求）和排序（块号递增排序）。 4.6.3 改进读请求 由于存在读延迟问题，简单地插入处理请求会使排位靠后的读请求出现”饿死“，极大影响性能。 4.6.3.1 Deadline I/O 调度器 加入 FIFO 队列区分读写请求，并为读请求赋予更小的过期事件。 4.6.3.2 Anticipatory I/O 调度器 在 Deadline I/O 的基础上增加预测机制： ​ 调度后等待 6ms ，若又产生了对磁盘同部分的读请求，则响应。 4.6.3.3. CFQ I/O 调度器 为每个进程的队列分配时间片，使用轮转方式处理队列请求，直到时间片耗尽或所有请求处理完毕。 如果所有请求处理完了，调度器会空转一段时间，等待新请求。如果预测成功，则处理新请求；否则处理下个进程的队列请求。 CFQ 调度器适合高负载情况，并且是第一选择。 4.6.3.4 Noop I/O 调度器 最简单的调度器，一般用在无需对请求排队的特殊设备中。 4.6.4 选择和配置你的 I/O 调度器 例如，设置设备 hda 的 I/Q 调度程序为 CFQ 1#echo cfq &gt; /sys/block/hda/queue/scheduler 4.6.5 优化 I/O 性能 4.6.5.1 用户空间 I/O 调度 如果应用会产生大量读写请求，最好在提交前进行排序，避免性能损耗。 可处理的排序方式： 完整路径 简单，效率低。原理是同目录下文件在磁盘中相邻分布概率大。 inode 编号 比路径有效就，容易获取和排序，原理是 inode序号通常和物理块挂钩。 文件的物理块 获取文件文件真实的物理块号，接近最优结果。缺点是需要 root 权限。 4.7 结论","categories":[{"name":"阅读","slug":"阅读","permalink":"http://aaaris.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"Linux系统编程 第三章","slug":"Linux系统编程/Linux系统编程 第三章","date":"2022-10-24T12:50:01.248Z","updated":"2022-11-05T02:22:21.848Z","comments":true,"path":"2022/10/24/Linux系统编程/Linux系统编程 第三章/","link":"","permalink":"http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E4%B8%89%E7%AB%A0/","excerpt":"","text":"Linux系统编程 第三章 缓冲输入输出 所有的磁盘操作都是基于块进行的。 块操作效率随着系统调用次数的增多而急剧下降。 当请求以块大小整数倍对齐地址时，I/O 效率时最理想的。 3.1 用户——缓冲 I/O 轻量级 I/O 请求通常使用用户缓冲 I/O 。 用户缓冲 I/O 在用户空间完成，它可以在程序中设定，也可以调用标准库透明地执行。 3.1.1 块大小 实际应用中，块大小一般是512字节，1024字节，2048字节，或4096字节。 使用用户缓冲 I/O，使得程序能操作更小的单位并方便一次写出或读出。 3.1.2 标准 I/O C 标准库中提供了标准 I/O 库 stdio.h，其中实现了一个跨平台用户缓冲的解决方案。 3.1.3 文件指针 FILE 类型，流的概念 3.2 打开文件 12#include &lt;stdio.h&gt;FIFE* fopen(const char * path, const char * mode); 成功时，返回一个合法的 FILE 指针。失败时，返回 NULL，设置 errno。 3.2.1 模式 rwab + 3.2.2 通过文件描述符打开文件 12#include &lt;stdio.h&gt;FILE * fdopen (int fd, const char *mode); mode必须和原来打开文件描述符的模式匹配，且关闭流也会关闭相应的文件描述符。 成功时，返回一个合法的 FILE 指针。失败时，返回 NULL，设置 errno。 3.3 关闭流 12#include &lt;stdio.h&gt;int fclose (FILE *stream); 所有被缓冲但没写出的数据会先被写出。 成功时，返回 0。失败时返回 EOF 并设置 errno。 3.3.1 关闭所有的流 123#define _GNU_SOURCE#include &lt;stdio.h&gt;int fcloseall(void); 关闭之前,所有的流会被写出。 3.4 从流中读取数据 3.4.1 单字节读取 12#include &lt;stdio.h&gt;int fgetc(FILE *stream); 读取下一个字符并把该无符号字符强转为 int 返回，报错时返回 EOF。 3.4.2 把字符回放到流中 12#include &lt;stdio.h&gt;int ungetc (int c, FILE *stream); 每次调用把 c 强转为一个无符号字符并回放流中。成功时，返回 c；失败时返回 EOF。 3.4.3 按行的读取 12#include &lt;stdio.h&gt;char * fgets (char *str, int size, FILE *stream); 从流中读取 size - 1 个字节的数据，遇到 EOF 或 ‘\\n’ 结束读入，并把数组存入 str 中。 ‘\\n’ 会被存入 str 中。 3.4.4 读取任意字符串 读取 n-1 个字符到 str中，在任意分隔符 d 处停止读取。 123456789char *s;int c = 0;s = str; while (--n &gt; 0 &amp;&amp; (c = fgetc (stream)) != EOF &amp;&amp; (*s ++ = c) != d) ;if (c == d) *--s = &#x27;\\0&#x27;;else *s = &#x27;\\0&#x27;; 3.4.5 读取二进制文件 123#include &lt;stdio.h&gt;size_t fread (void *buf, size_t size, size_t nr, FILE *stream); 从输入流中读取 nr 个数据，每个数据有 size 个字节，并将数据放到 buf 所指向的缓冲区。 返回读入元素的个数，如果返回数小于 nr 说明读取失败或文件结束。 3.5 从流中写数据 3.5.1 对齐的讨论 3.5.2 写入单个字符 与 fgetc() 相对应 fputc() 12#include &lt;stdio.h&gt;int fputc (int c, FILE *stream); 3.5.3 写入字符串 12#include &lt;stdio.h&gt;int fputs (const char *str, FILE *stream); fputs() 的调用将 str 指向的字符串的所有非分隔符部分写入 stream 指向的流中。 成功时，fputs() 返回一个非负整数。失败时，返回 EOF。 3.5.4 写入二进制数据 与 fread() 对应 fwrite() 12345#include &lt;stdio.h&gt;size_t fwrite (void *buf, size_t size, size_t nr, FILE *stream); 3.5.5 缓冲 I/O 示例程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;int main (void) &#123; FILE *in, *out; struct pirate &#123; char name[100]; /* real name */ unsigned long booty; /* in pounds sterling */ unsigned int beard_len; /* in inches */ &#125; p, blackbeard = &#123; &quot;Edward Teach&quot;, 950, 48 &#125;; out = fopen (&quot;data&quot;, &quot;w&quot;); if (!out) &#123; perror (&quot;fopen&quot;); return 1; &#125; if (!fwrite (&amp;blackbeard, sizeof(struct pirate), 1, out)) &#123; perror (&quot;fwrite&quot;); return 1; &#125; if (fclose (out)) &#123; perror (&quot;fclose&quot;); return 1; &#125; in = fopen (&quot;data&quot;, &quot;r&quot;); if (!in) &#123; perror (&quot;fopen&quot;); return 1; &#125; if (!fread (&amp;p, sizeof(struct pirate), 1, in)) &#123; perror (&quot;fwrite&quot;); return 1; &#125; if (fclose (in)) &#123; perror (&quot;fclose&quot;); return 1; &#125; printf (&quot;name=\\&quot;%s\\&quot; booty=%lu beard_len=%u\\n&quot;, p.name, p.booty, p.beard_len); return 0;&#125; 由于变量长度、对齐等不同，不同程序——即使是不同机器上的同一程序——不一定能正确地读取 fwrite() 写入的数据。 3.6 定位流 fseek() 函数，标准 I/O 最常用的定位函数，操纵流指向文件中由 offset 和 whence 指定的位置。 12#include &lt;stdio.h&gt;int fseek (FILE *stream, long offset, int whence); whence 等价于 lseek() 中的 origin。 fseek() 不返回更新后的位置，返回 0 或 -1 表示成功与否。 fsetpos() 函数，将流的位置设置到 pos 处。 它和将 whence 设置为 SEEK_SET 时的 fseek() 功能一致。 12#include &lt;stdio.h&gt;int fsetpos (FILE *stream, fpos_t *pos); rewind() 函数将位置重置到流的初始位置，并清空错误标记。 12#include &lt;stdio.h&gt;void rewind (FILE *stream); 3.6.1 获得当前流位置 ftell() 函数返回当前流的位置。错误时，返回 -1，并设置 errno。 12#include &lt;stdio.h&gt;long ftell (FILE *stream); 选择性的，还有 fgetpos() 函数，用 pos 获取当前流的位置，成功时返回 0。 12#include &lt;stdio.h&gt;int fgetpos (FILE *stream, fpos_t *pos) 3.7 清洗一个流 fflush() 函数用来将用户缓冲区写入内核缓冲区，并保证数据都通过 write() 写出。 12#include &lt;stdio.h&gt;int fflush (FILE *stream); 成功时，返回 0 ，失败时，返回 EOF，并设置 errno。 如果需要的话，在调用 fflush() 之后调用 fsync()： ​ 先保证用户缓冲区被写入内核，然后保证内核缓冲区被写入到磁盘中。 3.8 错误和文件结束 一些标准的 I/O 接口无法区分错误和 EOF 机制，为此提供 ferror() 和 feof()。 ferror() 测试是否在流上设置了错误标志： 12#include &lt;stdio.h&gt;int ferror (FILE *stream); feof() 测试文件结尾标志是否被设置： 12#include &lt;stdio.h&gt;int feof (FILE *stream); clearerr() 清空流错误标志和文件结尾标志： 12#include &lt;stdio.h&gt;void clearerr (FILE *stream); 3.9 获得关联的文件描述符 为了获得流的文件描述符，可以使用 fileno() 12#include &lt;stdio.h&gt;int fileno (FILE *stream); 成功时，返回 fd，失败时，它返回 -1。 最好在执行获取文件描述符之前对流进行 flush。 最好永远不要混用 I/O 操作。 3.10 控制缓冲 不缓冲 数据直接提交内核 行缓冲 以行为单位执行，每当遇到换行符就提交到内核。（标准输出默认为行缓冲） 块缓冲 适用于文件，默认与文件相关的流都是块缓冲。在标准 I/O 中，称为全缓冲。 标准 I/O 提供一个用来控制使用缓冲类型的函数： 12345#include &lt;stdio.h&gt;int setvbuf (FILE *stream, char *buf, int mode, size_t size);/* _IONBF 无缓冲 *//* _IOLBF 行缓冲 *//* _IOFBF 块缓冲 */ 除了 _IONBF 情况下 buf 和 size 被忽略，buf 可以被用为指定缓冲区。若 buf 为空，缓冲区则由 glibc 自动分配。 setvbuf() 函数必须在打开流后，执行操作前被调用。 应注意，在流关闭时供其使用的缓冲区必须存在。 3.11 线程安全 标准 I/O 函数本质上是线程安全的，在单独一个函数调用的上下文中，其操作时原子的。 3.11.1 手动文件加锁 flockfile() 会等待流被解锁，然后获得锁，增加锁计数，成为流的所有者线程，然后返回： 12#include &lt;stdio.h&gt;void flockfile (FILE *stream); funlockfile() 减少与流相关的锁的计数： 12#include &lt;stdio.h&gt;void funlockfile (FILE *stream); 如果锁计数器达到了0，当前线程放弃流的所有权，另一个线程现在能获得锁。 ftrylockfile() 是 flockfile() 的非阻塞版本： 12#include &lt;stdio.h&gt;int ftrylockfile (FILE *stream); 如果流加了锁，返回非零值，否则进行相关操作且返回 0。 3.11.2 不加锁流操作 12345678910111213#define _GNU_SOURCE#include &lt;stdio.h&gt;int fgetc_unlocked (FILE *stream);char *fgets_unlocked (char *str, int size, FILE *stream);size_t fread_unlocked (void *buf, size_t size, size_t nr, FILE *stream);int fputc_unlocked (int c, FILE *stream);int fputs_unlocked (const char *str, FILE *stream);size_t fwrite_unlocked (void *buf, size_t size, size_t nr, FILE *stream);int fflush_unlocked (FILE *stream);int feof_unlocked (FILE *stream);int ferror_unlocked (FILE *stream);int fileno_unlocked (FILE *stream);void clearerr_unlocked (FILE *stream); 3.12 对标准 I/O的批评 fgets() 有时不能满足要求 gets() 太不安全 双副本的性能影响。 3.13 结论","categories":[{"name":"阅读","slug":"阅读","permalink":"http://aaaris.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"Linux系统编程 第二章","slug":"Linux系统编程/Linux系统编程 第二章","date":"2022-10-24T12:46:05.767Z","updated":"2024-03-14T08:35:49.797Z","comments":true,"path":"2022/10/24/Linux系统编程/Linux系统编程 第二章/","link":"","permalink":"http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/","excerpt":"","text":"Linux系统编程 第二章 文件 I/O 内核为每个进程维护 file table，该表由一些称作 file descriptors 的非负整数进行索引。 子进程默认会获得一份父进程的文件表拷贝。 每个进程按照惯例会至少有三个打开的文件描述符：0，1 和 2，即 stdin、stdout、stderr。 一切皆文件，任何能读写的东西都可以用文件描述符进行访问。 2.1 打开文件 2.1.1 open() 系统调用 123456#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(const char* name, int flags);int open(const char *name, int flags, mode_t mode); 2.1.1.1 open() 的 flags 参数 必须包含以下之一 O_RDONLY | O_WRONLY | O_RDWR 2.1.2 新文件所有者 文件所有者的用户 id 就是创建该文件的进程的有效用户 id 大多数 Linux 系统会采纳系统 V 的做法（新文件得到创建进程的组 ID），而保留 BSD 做法（新文件得到上级目录 id） 2.1.3 新文件权限 当文件创建时，mode 参数提供新建文件的权限。 实际上，最终写入磁盘的权限位由 mode 参数与 umask 进行按位与后确定。 umask 022 将使 mode 0666 变为 0644(0666 &amp; ~022) 2.1.4 creat() 函数 12345#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int creat (const char *name, mode_t mode); 大部分 Linux 架构上，creat() 是一个系统调用： 12345int creat (const char *name, int mode)&#123; return open (name, O_WRONLY | O_CREAT | O_TRUNC, mode);&#125; 2.1.5 返回值和错误码 成功 错误 返回 文件描述符 -1 errno / 设置 2.2 用 read() 读取文件 123#include &lt;unistd.h&gt;ssize_t read (int fd, void *buf, size_t len); 该系统调用从 fd 指向的文件的当前偏移量至多读 len 个字节到 buf 中。 2.2.1 返回值 成功时，将返回写入 buf 中的字节数。出错时返回 -1，并设置 errno。 2.2.2 读入所有的字节 123456789101112ssize_t ret;while (len != 0 &amp;&amp; (ret = read (fd, buf, len)) != 0) &#123; if (ret == -1) &#123; if (errno == EINTR) continue; perror(&quot;read&quot;); break; &#125; len -= ret; buf += ret;&#125; 2.2.3 非阻塞读 如果给出的文件描述符在非阻塞模式下打开且没有可读数据，read() 调用会返回 -1，且设置 errno 为 EAGAIN open() 中给定 O_NONBLOCK，在非阻塞模式下打开文件 2.2.4 其他错误码 2.2.5 read() 大小限制 ssize_t 类型是有符号的 size_t 类型（负值用来表示错误）。 size_t 的最大值为 SIZE_MAX；size_t 的最大值为 SSIZE_MAX。 在 32 位系统上，对应的 C 类型一般分别是 unsigned int 和 int。 2.3 用 write() 来写 123#include &lt;unistd.h&gt;ssize_t write (int fd, const void *buf, size_t count); 该系统调用从文件描述符 fd 引用文件的当前位置开始，将 buf 中至多 count 个字节写入文件中。 成功时，返回写入字节数，并更新文件位置。错误时，返回 -1，设置 errno。 2.3.1 部分写 对于普通文件，除非发生错误，否则 write() 将保证写入所有的请求。 对于其他类型——例如套接字——可以使用循环来保证写入完全。 代码参考 read() 2.3.2 追加模式 当 fd 在追加模式打开（通过指定 O_APPEND 参数），写操作从当前文件末尾开始。 追加模式避免了多进程同时写的竞争问题。 2.3.3 非阻塞写 当 fd 在非阻塞模式打开（通过指定 O_NONBLOCK 参数），写操作产生阻塞时， write() 系统调用返回 -1，并设置 errno 值为 EAGAIN。 2.3.4 其他错误码 2.3.5 write() 大小限制 count &lt;= SSIZE_MAX 2.3.6 write() 的行为 异步 I/O：write() -&gt; Linux 内核检查 -&gt; 数据拷贝至缓冲区 -&gt; 内核收集缓冲区并排序，写入磁盘（回写） 为保证数据适时写入，内核创立了一种缓存最大时效机制。 用户可以通过 /proc/sys/vm/dirty_expire_centiseconds 来配置该值。 2.4 同步 I/O 2.4.1 fsync() 和 fdatasync() 123#include &lt;unistd.h&gt;int fsync (int fd); 该调用回写数据以及建立的时间戳和 inode 中的其他属性等元数据。 fd 必须是以写方式打开的。 12#include &lt;unistd.h&gt;int fdatasync(int fd); 工作与 fsync() 类似，区别在于它仅写入数据，不保证元数据同步到磁盘上。 2.4.2 返回值和错误码 errno 描述 EBADF fd 非法 EINVAL fd 对象不支持同步 EIO 底层 I/O 错误 2.4.3 sync() 123#include &lt;unistd.h&gt;void sync(void); 调用总是成功返回，并确保所有的缓冲——包括数据和元数据——都能写入磁盘*。（磁盘可能撒谎） 对于Linux 来讲，sync() 一定要等到所有的缓冲区都写入才返回。 因此，调用一次 sync() 就够了。 2.4.4 O_SYNC 标志 O_SYNC 标志在 open() 中使用，使所有在文件上的 I/O 操作同步。（针对写操作，读操作总是同步的） O_SYNC 看起来就像在每个 write() 操作后都隐式执行 fsync()，但 Linux 内核实现的 O_SYNC 会更有效一点。 O_SYNC 会使写操作总耗时增加一到两个数量级。 一般情况下，使用 fsync() 或者 fdatasync() 开销更少。 2.4.5 O_DSYNC 和 O_RSYNC O_DSYNC ：指定在每次写操作后只有普通数据同步。 O_RSYNC ：要求读请求像写请求那样进行同步，配合 O_DSYNC 或 O_SYNC 一起使用 2.5 直接 I/O 在 open() 中使用 O_DIRECT 标志会使内核最小化 I/O 管理的影响。 当使用直接 I/O 时，请求长度，缓冲区对齐，和文件偏移必须是设备扇区大小的整数倍。 2.6 关闭文件 123#include &lt;unistd.h&gt;int close (int fd); close() 调用解除 fd 关联，并分离进程和文件的关联。 成功返回 0，错误时返回 -1 并设置 errno。 如果文件已经在磁盘上解除链接，但之前仍保持打开，那么它在 close() 之前不会被真的删除。 因此，对 close() 的调用可能会使某个已解除链接的文件最终从磁盘上被删除。 2.6.1 错误码 EBADF\\EIO 2.7 用 lseek() 查找 1234#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;off_t lseek(int fd, off_t pos, int origin); lseek() 能给 fd 引用的文件位置设定指定值。 调用成功返回新文件位置，错位返回 -1 并设置 errno。 2.7.1 文件末尾之后进行查找 读操作：返回 EOF 写操作：在新旧长度之间进行零填充（空洞） 空洞不占用任何物理上的磁盘空间。 带空洞的文件叫做“稀疏文件“。 2.7.2 错误码 2.7.3 限制 Linux 定义 off_t 为字长，内核将偏移量存储为 C 的 long long 类型。 32 位机器上查找可能产生 EOVERFLOW 错误。 2.8 定位读写 Linux 提供 pread() 和 pwrite() 来替代 lseek()。 12345#define _XOPEN_SOURCE 500#include &lt;unistd.h&gt;ssize_t pread (int fd, void *buf, size_t count, off_t pos); 12345#define _XOPEN_SOURCE 500#include &lt;unistd.h&gt;ssize_t pwrite (int fd, const void *buf, size_t count, off_t pos); 在调用完成时，他们不会修改文件位置。 如此，避免了任何在使用 lseek() 时可能出现的潜在竞争（线程）。 2.8.1 错误码 2.9截短文件 1234#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int ftruncate (int fd, off_t len); 1234#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int truncate (const char *path, off_t len); 两个系统调用都将文件截短到 len 指定的长度。 成功返回 0，错误返回 -1，并设置 errno。 他们也将文件”截短“到比原长度更长，扩展出的字节将全部填充为零。 2.10 I/O 多路复用 I/O 多路复用允许应用在多个文件描述符上同时阻塞，并在其中某个可以读写时收到通知。 Linux 提供三种 I/O 多路复用方案：select, poll 和 epoll。 2.10.1 select() 1234567891011121314#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);FD_CLR(int fd, fd_set *set); /* oops, remove &#x27;fd&#x27; from the set */FD_ISSET(int fd, fd_set *set); /* &#x27;fd&#x27; is readable without blocking! */FD_SET(int fd, fd_set *set); /* &#x27;add &#x27;fd&#x27; to the set */FD_ZERO(fd_set *set); /* remove all fd from the set */ 指定的集合可能为 NULL，相应的，select() 则不对此类时间进行监视。 如果没有文件描述符处于 I/O 就绪状态，select() 调用将在 tv_sec 秒 tv_usec 微秒后返回，每次调用前都必须重新初始化（还有集合中的文件描述符）。 2.10.2 返回值和错误码 成功时，返回三个集合中 I/O 就绪的文件描述符的数目；错误时返回-1，设置 errno 。 2.10.2.1 select() 示例程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#define TIMEOUT 5 /* select timeout in seconds */#define BUF_LEN 1024 /* read buffer in bytes */int main (void) &#123; strcut timeval v; fd_set readfds; int ret; /* Wait on stdin for input. */ FD_ZERO(&amp;readfds); FD_SET(STDIN_FILENO, &amp;readfds); /* Wait up to five seconds. */ tv.tv_sec = TIMEOUT; tv.tv_usec = 0; /* All right, now block! */ ret = select (STDIN_FILENO + 1, &amp;readfds, NULL, NULL, &amp;tv); if (ret == -1) &#123; perror (&quot;select&quot;); return 1; &#125; else if (!ret) &#123; printf (&quot;%d seconds elapsed.\\n&quot;, TIMEOUT); return 0; &#125; /* * Is our file descriptor ready to read? * (It must be, as it was the only fd that * we provided and the call returned * nonzero, but we will humor ourselves.) */ if (FD_ISSET(STDIN_FILENO, &amp;readfds)) &#123; char buf[BUF_LEN + 1]; int len; /* guaranteed to not block */ len = read (STDIN_FILENO, buf, BUF_LEN); if (len == -1) &#123; perror (&quot;read&quot;); return 1; &#125; if (len) &#123; buf[len] = &#x27;\\0&#x27;; printf (&quot;read: %s\\n&quot;, buf); &#125; return 0; &#125; fprintf (stderr, &quot;This should not happen!\\n&quot;); return 1;&#125; 2.10.2.2 用 select() 实现可移植的sleep() 1234567struct timeval tv;tv.tv_sec = 0;tv.tv_userc = 500;/* sleep for 500 microseconds */select (0, NULL, NULL, NULL, &amp;tv); select() 作为一种可移植的微秒级的睡眠机制。 2.10.2.3 pselect() 1234567891011121314#define _XOPEN_SOURCE 600#include &lt;sys/select.h&gt;int pselect (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timespec *timeout, const sigset_t *sigmask);FD_CLR(int fd, fd_set *set);FD_ISSET(int fd, fd_set *set);FD_SET(int fd, fd_set *set);FD_ZERO(fd_set *set); pselect() 和 select() 三点不同 timeout 参数采用 timespec 结构，包含秒和纳秒。 timeout 参数后续不用重新初始化 增加 sigmask 参数，当该参数设置为零时，pselect() 的行为等同于 select()。 sigmask 参数用来解决信号和等待文件描述符之间的竞争条件。 2.10.3 poll() 123#include &lt;sys/poll.h&gt;int poll (struct pollfd *fds, unsigned int nfds, int timeout); 2.10.3.1 返回值和错误码 成功时返回具有非零 revent 字段的文件描述符个数。 失败时返回 -1，errno 被设置。 2.10.3.2 poll() 的例子 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#define TIMEOUT 5 /* poll timeout, in seconds */int main (void)&#123; struct pollfd fds[2]; int ret; /* watch stdin for input */ fds[0].fd = STDIN_FILENO; fds[0].events = POLLIN; /* watch stdout for ability to write (almost always true) */ fds[1].fd = STDOUT_FILENO; fds[1].events = POLLLOUT; /* All set, block! */ ret = poll (fds, 2, TIMEOUT * 1000); if (ret == -1) &#123; perror (&quot;poll&quot;); return 1; &#125; if (!ret) &#123; printf (&quot;%d seconds elapsed.\\n&quot;, TIMEOUT); return 0; &#125; if (fds[0].revents &amp; POLLIN) printf (&quot;stdin is readable\\n&quot;); if (fds[1].revents &amp; POLLOUT) printf (&quot;stdout is writeable\\n&quot;); return 0;&#125; 无须重新构建 pollfd 结构体，必要时内核会把 revents 字段清空。 2.10.3.3 ppoll() Linux 提供了一个 poll() 的近似调用—— ppoll()，timeout 参数和 sigmask 参数参考 pselect()。 1234567#define _GNU_SOURCE#include &lt;sys/poll.h&gt;int ppoll (struct pollfd *fds, nfds_t nfds, const struct timespec *timeout, const sigset_t *sigmask); 2.10.4 poll() 与 select() poll() 在参数的处理更为方便。 (不用重新创建 timeout、fds，fds 处理效率高，不用计算n） select() 的可移植性更强。 epoll() 接口更好，一个 Linux 特有的 I/O 多路复用解决方案 2.11 内核内幕 2.11.1 虚拟文件系统 virtual file switch 是一种 Linux 内核的文件操作的抽象机制。 它允许内核在无需了解文件系统类型的情况下，使用文件系统函数和操作文件系统数据。 VFS 工作于 inode, superblock 和目录条目之上。 read() 系统调用 -&gt; 内核确认 fd 对象类型 -&gt; 内核调用该文件系统的 read() 2.11.2 页缓存 页缓存是一种在内存中保存最近在磁盘文件系统上访问过的数据的方式。 Linux 页缓存大小是动态的。一个动态变化的缓存允许 Linux 使用所有的系统内存，并缓存尽可能多的数据。 页缓存是内核寻找文件系统数据的第一目的地。 2.11.3 页回写 回写由一些叫做 pdflush 的内核线程操作，且具有并行性。 缓冲区在内核中使用 buffer_head 结构来表示，保存在页缓存中。 2.12 结论","categories":[{"name":"阅读","slug":"阅读","permalink":"http://aaaris.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"Linux系统编程 第一章","slug":"Linux系统编程/Linux系统编程 第一章","date":"2022-10-24T12:44:45.562Z","updated":"2022-11-05T02:22:03.317Z","comments":true,"path":"2022/10/24/Linux系统编程/Linux系统编程 第一章/","link":"","permalink":"http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E4%B8%80%E7%AB%A0/","excerpt":"","text":"Linux系统编程 第 1 章 简介和主要概念 1.1 系统编程 从传统角度讲，所有的 Unix 编程都是系统级别编程。 1.1.1 系统调用 系统调用（syscalls）是为了从操作系统获得服务或者资源而从用户空间向内核发起的函数调用。 1.1.2 调用系统调用 基于系统安全和稳定的考虑，用户空间程序禁止直接执行内核的代码或者操作内核数据。 在 i386 上，用户空间程序执行参数为 0x80 的中断指令 int，这个指令触发系统将当前运行环境换到内核的保护区域，内核执行终端处理函数的区域。 1.1.3 C库 C库由 GNU libc 提供，简称为 glibc。 除了标准的C库，glibc 还提供了系统调用封装，线程支持和基本应用工具。 1.1.4 C编译器 在 Linux 中，标准的C编译器是 gcc GCC——GNU C Compiler 1.2 API 和 ABI 1.2.1 API API定义了软件模块之间在源代码层交互的接口。 它通过提供一组标准接口的方式进行抽象：一个程序片段调用另一个程序片段。 API通过C标准来定义且通过C库实现 1.2.2 ABI ABI定义的是，在特定的架构上两个或多个软件模块之间的二进制接口。 它定义了一个应用如何和自己交互，如何和内核以及库进行交互。 ABI主要关注的问题有：调用约定、字节序、寄存器使用、系统调用、链接、库行为和二进制格式 1.3 标准 POSIX 和 SUS 定义了类 Unix 操作系统接口上的 C API，它们有为各种兼容的类 Unix 系统定义了系统编程 1.3.1 POSIX 和 SUS 的历史 1.3.2 C语言标准 1999年 ISO C99 1.3.3 Linux 和标准 Linux 基本规范（LSB） 扩展了 POSIX 和 SUS，添加了自己的标准。 1.3.4 本书和标准 本书仅设计在2.6内核、gcc 4.2编译器和C库（2.5）的 Linux 系统上的进行系统编程的相关知识。 1.4 Linux编程概念 1.4.1 文件和文件系统 Linux 遵循一切皆是文件的理念。 一个打开的文件通过唯一的文件描述符进行引用，该描述符是打开文件的元数据至其本身的映射。 在 Linux 内核中，这个描述符称为文件描述符，用一个整数表示。 文件描述符在用户程序中共享，允许用户程序用文件描述符直接访问文件。 1.4.2 普通文件 一个普通文件包括含以线性字节数组方式组织的数据——字节流。 文件的读写操作，开始于特定字节，指文件位置或者文件偏移量。 文件中间写入字节将覆盖位置偏移量上的值，因此不能以在中间写入内容的方式来扩展文件。 文件的大小通过字节计算，称为文件长度。 截断：通过删除文件结尾部分而截段为稍小的文件。 内核没有对并发文件访问强加限制。 文件通过 inode（信息节点）进行访问，本身不与文件名称关联。 inode 是 Unix 文件系统在磁盘上实际物理对象，也是 Linux 内核中的数据结构的概念实体 1.4.3 目录与链接 目录将易读的名字和 inode 编号进行映射，目录本身也有关联的 inode 以形成目录层次。 名字与 inode 的配对称为链接。 目录&gt;&gt;映射集合 链接&gt;&gt;映射 路径解析：用户请求-&gt;内核遍历目录项-&gt;获取下一项 inode 编号-&gt;找到对应 inode 1.4.4 硬链接 将不同名字映射到同一个 inode 信息节点的多个连接称为硬链接 inode 包含一个 link count 来跟踪文件系统中指向该文件的硬连接数目。 当 link count 归0后，inode 和它关联的数据才真正删除。 1.4.5 符号链接 符号链接（symlink）拥有自己的inode和包含被链接文件完整路径名的数据块。 与硬链接相比，符号链接解析需要更多开销（解析两个文件）。 1.4.6 特殊文件 Linux 支持四种类型的特殊文件： 块设备文件（字节数组） 字符设备文件（字节线性队列） 命名管道（通常叫 FIFOs）(进程间通信 IPC 机制) Unix 域套接字( IPC 机制) 1.4.7 文件系统和名字空间 Linux 提供全局统一的文件和目录的名字空间。 每个文件系统都要挂载在名字空间中特定的位置，这个位置称为挂载点。 文件系统的根目录可以通过挂载点访问。 1.4.8 进程 Linux 内核支持抢占式多任务和虚拟内存，它给进程提供了虚拟处理器和内存的虚拟视图。 通过虚拟内存和分页调度，内核允许多个进程共存在系统上，每个进程操作都有自己的地址空间。 1.4.9 线程 线程是进程中的活动单位，包括栈、处理器状态、目标代码的当前位置。 在用户空间，Linux 根据 POSIX1003.1c 实现线程(pthread) 1.4.10 进程体系 在 Linux 中，进程树以第一个进程（init）为根，新进程通过 fork() 系统调用创建。 进程终止，内核将在内存中保存进程的部分内容，允许父进程查询该进程终止的状态。 已终止，但父进程尚未获知其状态的进程，称为僵尸进程（zombie） 1.4.11 用户和组 在 Linux 内核中，uid是用户的唯一标识。用户名和对应 id 存储在 /etc/passwd 中。 登陆过程中，login(1)程序处理用户名和密码。若无误，login(1) 将根据 /etc/passwd 为用户生成 login shell uid 0 是 root 的用户 id。 1.4.12 权限 每一个文件都一个所有者，所属组以及权限位集。 文件所有者和权限信息存储在文件的inode中 1.4.13 信号 信号是一种单向异步通知机制，用于通知进程发生某种事件，如段错误或者用户输入 Ctrl + C Linux 内核实现了大约30个信号，如 SIGHUP 用于表示终端挂起 1.4.14 进程间通讯 Linux 支持的进程间通讯机制包括有 管道 命名管道 信号量 消息队列 共享内存 快速用户空间互斥体 1.4.15 头文件 1.4.16 错误处理 在系统编程中，错误通常通过函数的返回值表示，并通过特殊的变量 errno 描述。 glibc 对库函数和系统调用的 errno 提供透明支持。 在多线程中，每一个程序都保留了自己的 errno，因此是线程安全的。 1.5 开始系统编程","categories":[{"name":"阅读","slug":"阅读","permalink":"http://aaaris.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]}],"categories":[{"name":"工具","slug":"工具","permalink":"http://aaaris.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"阅读","slug":"阅读","permalink":"http://aaaris.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]}