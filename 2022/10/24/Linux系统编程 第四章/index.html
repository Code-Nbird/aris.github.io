<!DOCTYPE html>
<html lang="zn,en">
    <head prefix="og: https://ogp.me/ns#">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
  <meta name="color-scheme" content="light dark">
  
  <title>Linux系统编程 第四章 - aaaris&#39;s blog</title>
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
  
  
  <meta property="og:title" content="Linux系统编程 第四章 - aaaris&#39;s blog" />
  
  <meta property="og:type" content="article" />
  
  <meta property="og:url" content="http://aaaris.github.io/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E5%9B%9B%E7%AB%A0/index.html" />
  
  <meta property="og:image" content="/favicon.png" />
  
  <meta property="og:article:published_time" content="2022-10-24T12:51:23.602Z" />
  
  <meta property="og:article:author" content="aaaris" />
  
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
  
<link rel="stylesheet" href="/css/rainbow-banner.css">

  
  
  
<link rel="stylesheet" href="/css/toc.css">

  
  
  
  
  
<link rel="stylesheet" href="/css/post.css">

  
  
  
  
  

  
<meta name="generator" content="Hexo 6.3.0"></head>
    <body
        data-color-scheme="auto"
        data-uppercase-categories="true"
        
        data-rainbow-banner="true"
        data-rainbow-banner-shown="auto"
        data-rainbow-banner-month="6"
        data-rainbow-banner-colors="#e50000,#ff8d00,#ffee00,#008121,#004cff,#760188"
        
        data-config-root="/"
        
        data-toc="true"
        data-toc-max-depth="5"
        
        
    >
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">aaaris&#39;s blog</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">Home</a>
            
            
            <a class="nav-item" href="/archives">Archives</a>
            
            
            
            <a class="nav-item" href="/friends">Friends</a>
            
            
            
            <a class="nav-item" href="/projects">Projects</a>
            
            
            
            <a class="nav-item" href="/about">About</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/aaaris" target="_blank">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-search nav-item-icon" href="/search" target="_blank">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        
<article class="post">
    <div class="meta">
        

        
        <div class="date" id="date">
            <span>October</span>
            <span>24,</span>
            <span>2022</span>
        </div>
        

        <h2 class="title">Linux系统编程 第四章</h2>
    </div>

    <div class="divider"></div>

    <div class="content">
        <p>[TOC]</p>
<h1 id="Linux系统编程"><a href="#Linux系统编程" class="headerlink" title="Linux系统编程"></a>Linux系统编程</h1><h2 id="第四章-高级文件-I-x2F-O"><a href="#第四章-高级文件-I-x2F-O" class="headerlink" title="第四章 高级文件 I&#x2F;O"></a>第四章 高级文件 I&#x2F;O</h2><h3 id="4-1-散布-x2F-聚集-I-x2F-O"><a href="#4-1-散布-x2F-聚集-I-x2F-O" class="headerlink" title="4.1 散布 &#x2F; 聚集 I&#x2F;O"></a>4.1 散布 &#x2F; 聚集 I&#x2F;O</h3><p>散布聚集 I&#x2F;O 是一种可以在单次系统调用中操作多个缓冲区的 I&#x2F;O 方法。</p>
<p>又称向量 I&#x2F;O，第二章提到的可称作线性 I&#x2F;O。</p>
<h4 id="4-1-1-readv-和-writev"><a href="#4-1-1-readv-和-writev" class="headerlink" title="4.1.1 readv() 和 writev()"></a>4.1.1 readv() 和 writev()</h4><p>readv() 从 fd 读取 count 个 segment 到 iov 描述的缓冲区中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span> <span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>writev() 从 iov 描述的缓冲区中读取 count 个 segment 的数据并写入 fd 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span> <span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>每个 iovec 结构体描述一个独立的缓冲区，我们称其为 segment</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line">strcut iovec &#123;</span><br><span class="line">    <span class="type">void</span> *iov_base;</span><br><span class="line">    <span class="type">size_t</span> iov_len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一组 segment 的集合称为 vector。</p>
</blockquote>
<h5 id="4-1-1-1-返回值"><a href="#4-1-1-1-返回值" class="headerlink" title="4.1.1.1 返回值"></a>4.1.1.1 返回值</h5><p>成功时返回读写的字节数，出错时返回 -1，设置 errno。</p>
<p>除了返回任何 read() 和 write() 可能返回的错误之外，标准定义两种额外错误。</p>
<ul>
<li>EINVAL<ul>
<li>iov_len &gt; SSIZE_MAX</li>
</ul>
</li>
<li>EINVAL<ul>
<li>count &lt; 0 || count &gt; IOV_MAX &#x3D; 1024</li>
</ul>
</li>
</ul>
<h5 id="4-1-1-2-writev-示例"><a href="#4-1-1-2-writev-示例" class="headerlink" title="4.1.1.2 writev() 示例"></a>4.1.1.2 writev() 示例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[3];</span></span><br><span class="line">    <span class="type">ssize_t</span> nr;</span><br><span class="line">    <span class="type">int</span> fd, i;</span><br><span class="line">    <span class="type">char</span> *buf[] = &#123;<span class="string">&quot;The term buccaneer comes from the word boucan.\n&quot;</span>, </span><br><span class="line">                   <span class="string">&quot;A boucan is a wooden frame used for cooking meat.\n&quot;</span>, </span><br><span class="line">                   <span class="string">&quot;Buccaneer is the West Indies name for a pirate.\n&quot;</span> &#125;;</span><br><span class="line">	fd = open (<span class="string">&quot;buccaneer.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror (<span class="string">&quot;open&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/* fill out three iovec structures */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    	iov[i].iov_base = buf[i];</span><br><span class="line">    	iov[i].iov_len = <span class="built_in">strlen</span> (buf[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* with a single call, write them all out */</span></span><br><span class="line">    nr = writev (fd, iov, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (nr == <span class="number">-1</span>) &#123;</span><br><span class="line">    	perror (<span class="string">&quot;writev&quot;</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;wrote %d bytes\n&quot;</span>, nr);</span><br><span class="line">	<span class="keyword">if</span> (close (fd)) &#123;</span><br><span class="line">		perror (<span class="string">&quot;close&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-1-1-3-readv-示例"><a href="#4-1-1-3-readv-示例" class="headerlink" title="4.1.1.3 readv() 示例"></a>4.1.1.3 readv() 示例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> foo[<span class="number">48</span>], bar[<span class="number">51</span>], baz[<span class="number">49</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[3];</span></span><br><span class="line">    <span class="type">ssize_t</span> nr;</span><br><span class="line">    <span class="type">int</span> fd, i;</span><br><span class="line">    fd = open (<span class="string">&quot;buccaneer.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* set up our iovec structures */</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = foo;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span> (foo);</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = bar;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> (bar);</span><br><span class="line">    iov[<span class="number">2</span>].iov_base = baz;</span><br><span class="line">    iov[<span class="number">2</span>].iov_len = <span class="keyword">sizeof</span> (baz);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    	read into the structures with a single call</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    nr = readv (fd, iov, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (nr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;readv&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    	<span class="built_in">printf</span> (<span class="string">&quot;%d: %s&quot;</span>, i, (<span class="type">char</span> *)</span><br><span class="line">    iov[i].iov_base);</span><br><span class="line">    <span class="keyword">if</span> (close (fd)) &#123;</span><br><span class="line">        perror (<span class="string">&quot;close&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-1-1-4-实现"><a href="#4-1-1-4-实现" class="headerlink" title="4.1.1.4 实现"></a>4.1.1.4 实现</h5><p>简单的用户空间实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">naive_writev</span> <span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec</span></span><br><span class="line"><span class="params">*iov, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">ssize_t</span> nr;</span><br><span class="line">        nr = write (fd, iov[i].iov_base,</span><br><span class="line">        iov[i].iov_len);</span><br><span class="line">        <span class="keyword">if</span> (nr == <span class="number">-1</span>) &#123;</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret += nr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Linux 下readv() 和 writev() 作为系统调用实现，在内部使用散布 &#x2F; 聚集 I&#x2F;O。</p>
<p>实际上，内核里的所有 I&#x2F;O 都是向量 I&#x2F;O；read() 和 write() 是只有一个向量的向量 I&#x2F;O。</p>
</blockquote>
<h3 id="4-2-Event-Poll-接口"><a href="#4-2-Event-Poll-接口" class="headerlink" title="4.2 Event Poll 接口"></a>4.2 Event Poll 接口</h3><p>poll() 和 select() 调用必须遍历所有被监视的 fds，当 fds 数量增加时，性能就会出现瓶颈。</p>
<p>epoll() 使用三个系统调用解决这个问题：</p>
<ol>
<li>初始化 epoll 上下文</li>
<li>从上下文中加入或删除需要监视的 fds</li>
<li>执行时间等待。</li>
</ol>
<h4 id="4-2-1-创建一个新的-epoll-实例"><a href="#4-2-1-创建一个新的-epoll-实例" class="headerlink" title="4.2.1 创建一个新的 epoll 实例"></a>4.2.1 创建一个新的 epoll 实例</h4><p>使用 epoll_create() 创建一个 epoll 上下文：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span> <span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>调用成功返回一个与 epoll 实例关联的 fd（方便后续调用），size 表示一个大概监听 fds 的数目。</p>
<p>出错时，返回 -1，设置 errno：</p>
<table>
<thead>
<tr>
<th align="center">errno</th>
<th align="center">desc</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EINVAL</td>
<td align="center">size &lt;&#x3D; 0</td>
</tr>
<tr>
<td align="center">ENFILE</td>
<td align="center">系统达到打开文件数的上限</td>
</tr>
<tr>
<td align="center">ENOMEM</td>
<td align="center">内存不足</td>
</tr>
</tbody></table>
<h4 id="4-2-2-控制-epoll"><a href="#4-2-2-控制-epoll" class="headerlink" title="4.2.2 控制 epoll"></a>4.2.2 控制 epoll</h4><p>epoll_ctl()  可以向指定的 epoll 上下文中加入或删除文件描述符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span> <span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure>

<p>epoll event 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    __u32 events; <span class="comment">/* events */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *ptr;</span><br><span class="line">        <span class="type">int</span> fd;</span><br><span class="line">        __u32 u32;</span><br><span class="line">        __u64 u64;</span><br><span class="line">    &#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用成功后，将关联 epoll 实例和 epfd。</p>
<p>参数 op 指定对 fd 要进行的操作，op有效值：</p>
<table>
<thead>
<tr>
<th align="center">op</th>
<th align="center">desc</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EPOLL CTL ADD</td>
<td align="center">add</td>
</tr>
<tr>
<td align="center">EPOLL CTL DEL</td>
<td align="center">del</td>
</tr>
<tr>
<td align="center">EPOLL CTL MOD</td>
<td align="center">modify</td>
</tr>
</tbody></table>
<p>event 参数描述 epoll 更具体的行为，结构体中 events 有效值：</p>
<table>
<thead>
<tr>
<th align="center">events</th>
<th align="center">desc</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EPOLLERR</td>
<td align="center">文件出错（默认）</td>
</tr>
<tr>
<td align="center">EPOLLET</td>
<td align="center">边沿触发</td>
</tr>
<tr>
<td align="center">EPOLLHUP</td>
<td align="center">文件挂起（默认）</td>
</tr>
<tr>
<td align="center">EPOLLIN</td>
<td align="center">未阻塞，可读</td>
</tr>
<tr>
<td align="center">EPOLLONESHOT</td>
<td align="center">只监听一次操作</td>
</tr>
<tr>
<td align="center">EPOLLOUT</td>
<td align="center">未阻塞，可写</td>
</tr>
<tr>
<td align="center">EPOLLPRI</td>
<td align="center">高优带外可读</td>
</tr>
</tbody></table>
<p>event_poll 中的 data 字段由用户使用，通过访问 data.fd 可知触发事件的 fd。</p>
<p>成功返回 0，失败返回 -1，设置 errno：</p>
<table>
<thead>
<tr>
<th align="center">errno</th>
<th align="center">desc</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EBADF</td>
<td align="center">bad fd</td>
</tr>
<tr>
<td align="center">EEXIST</td>
<td align="center">epfd 已存在</td>
</tr>
<tr>
<td align="center">EINVAL</td>
<td align="center">epfd 不是一个epoll实例<br>epfd &#x3D; fd<br>op 无效</td>
</tr>
<tr>
<td align="center">ENOENT</td>
<td align="center">fd 与 epfd 未关联</td>
</tr>
<tr>
<td align="center">ENOMEM</td>
<td align="center">内存不足</td>
</tr>
<tr>
<td align="center">EPERM</td>
<td align="center">fd 不支持 epoll</td>
</tr>
</tbody></table>
<h4 id="4-2-3-等待-Epoll-事件"><a href="#4-2-3-等待-Epoll-事件" class="headerlink" title="4.2.3 等待 Epoll 事件"></a>4.2.3 等待 Epoll 事件</h4><p>epoll_wait() 等待给定 epoll 实例关联的文件描述符上的事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span> <span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, </span></span><br><span class="line"><span class="params">                <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">arg</th>
<th align="center">desc</th>
</tr>
</thead>
<tbody><tr>
<td align="center">epfd</td>
<td align="center">epoll 实例 epfd</td>
</tr>
<tr>
<td align="center">events</td>
<td align="center">触发事件</td>
</tr>
<tr>
<td align="center">maxevents</td>
<td align="center">最多触发事件个数</td>
</tr>
<tr>
<td align="center">timeout</td>
<td align="center">时限</td>
</tr>
</tbody></table>
<p>成功返回事件数目，出错返回 -1，并设置 errno</p>
<table>
<thead>
<tr>
<th align="center">errno</th>
<th align="center">desc</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EBADF</td>
<td align="center">epfd 无效</td>
</tr>
<tr>
<td align="center">EFAULT</td>
<td align="center">无权限操作 events 指向的内存</td>
</tr>
<tr>
<td align="center">EINTR</td>
<td align="center">信号中断</td>
</tr>
<tr>
<td align="center">EINVAL</td>
<td align="center">epfd 无效，或 maxevents 大于小于0</td>
</tr>
</tbody></table>
<h4 id="4-2-4-边沿触发时间和水平触发事件"><a href="#4-2-4-边沿触发时间和水平触发事件" class="headerlink" title="4.2.4 边沿触发时间和水平触发事件"></a>4.2.4 边沿触发时间和水平触发事件</h4><p>状态：可读</p>
<p>边沿触发：状态改变发生。（即使已经可读，仍等到有东西写入后返回）</p>
<p>水平触发：状态发生时触发。（可读就返回）</p>
<h3 id="4-3-存储映射"><a href="#4-3-存储映射" class="headerlink" title="4.3 存储映射"></a>4.3 存储映射</h3><p>将文件映射到内存中，通过内存操作文件。</p>
<h4 id="4-3-1-mmap"><a href="#4-3-1-mmap" class="headerlink" title="4.3.1 mmap()"></a>4.3.1 mmap()</h4><p>请求内核将 fd 从 offset 开始的 len 个字节数据映射到内存中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">mmap</span> <span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flags</span></span><br><span class="line"><span class="params">             <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">arg</th>
<th align="center">desc</th>
</tr>
</thead>
<tbody><tr>
<td align="center">addr</td>
<td align="center">内存映射文件最佳地址</td>
</tr>
<tr>
<td align="center">prot</td>
<td align="center">访问权限</td>
</tr>
<tr>
<td align="center">flags</td>
<td align="center">映射类型和行为</td>
</tr>
</tbody></table>
<blockquote>
<p>映射后，文件描述符引用计数会增加。</p>
</blockquote>
<h5 id="4-3-1-1-页大小"><a href="#4-3-1-1-页大小" class="headerlink" title="4.3.1.1 页大小"></a>4.3.1.1 页大小</h5><p>mmap() 调用操作页，addr 和 offset 必须按页大小对齐。</p>
<p>页大小可以通过三种方式获取：</p>
<ul>
<li>&lt;unistd.h&gt; 的 <code>sysconf (_SC_PAGESIZE)</code>（best choice）</li>
<li>&lt;unistd.h 的 <code>getpagesize()</code>（Linux 支持，移植性差）</li>
<li>&lt;asm&#x2F;pages.h&gt; 中 的宏定义 <code>PAGE_SIZE</code>（编译时确定，移植性差）</li>
</ul>
<h5 id="4-3-1-2-返回值和错误码"><a href="#4-3-1-2-返回值和错误码" class="headerlink" title="4.3.1.2 返回值和错误码"></a>4.3.1.2 返回值和错误码</h5><p>成功返回映射区地址；失败时，返回 MAP_FAILED，设置 errno。</p>
<h5 id="4-3-1-3-相关信号"><a href="#4-3-1-3-相关信号" class="headerlink" title="4.3.1.3 相关信号"></a>4.3.1.3 相关信号</h5><table>
<thead>
<tr>
<th align="center">signal</th>
<th align="center">desc</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SIGBUS</td>
<td align="center">访问映射区无效。如文件映射后截短</td>
</tr>
<tr>
<td align="center">SIGSEGV</td>
<td align="center">映射区只读不可写。</td>
</tr>
</tbody></table>
<h4 id="4-3-2-munmap"><a href="#4-3-2-munmap" class="headerlink" title="4.3.2 munmap()"></a>4.3.2 munmap()</h4><p>Linux 提供 munmap() 来取消 mmap() 的映射。</p>
<p>munmap() 移除从 addr 开始的进程地址，len 字节长的所有内存映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span> <span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span>;</span><br></pre></td></tr></table></figure>

<p>成功返回 0；失败返回 -1，设置 errno。</p>
<h4 id="4-3-3-存储映射例子"><a href="#4-3-3-存储映射例子" class="headerlink" title="4.3.3 存储映射例子"></a>4.3.3 存储映射例子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="type">off_t</span> len;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fd = open (argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fstat (fd, &amp;sb) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!S_ISREG (sb.st_mode)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;%s is not a file\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p = mmap (<span class="number">0</span>, sb.st_size, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == MAP_FAILED) &#123;</span><br><span class="line">        perror (<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (close (fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;close&quot;</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; sb.st_size; len++)</span><br><span class="line">    	<span class="built_in">putchar</span> (p[len]);</span><br><span class="line">    <span class="keyword">if</span> (munmap (p, sb.st_size) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-3-4-mmap-的优点"><a href="#4-3-4-mmap-的优点" class="headerlink" title="4.3.4 mmap() 的优点"></a>4.3.4 mmap() 的优点</h4><ul>
<li>避免用户缓冲区带来的多余的数据拷贝。</li>
<li>直接操作内存，开销小。</li>
<li>多进程映射同一对象到内存中时，数据共享。</li>
<li>用指针定位，无需 lseek()。</li>
</ul>
<h4 id="4-3-5-mmap-的缺陷"><a href="#4-3-5-mmap-的缺陷" class="headerlink" title="4.3.5 mmap() 的缺陷"></a>4.3.5 mmap() 的缺陷</h4><ul>
<li>由于映射页对齐带来的内存页空间浪费。</li>
<li>对于 32 位进程地址空间，大片连续的空内存少。</li>
<li>创建和维护映射以及相关内核数据结构有一定开销。</li>
</ul>
<blockquote>
<p>处理大文件、页对齐文件，mmap() 优势明显。</p>
</blockquote>
<h4 id="4-3-6-调整映射的大小"><a href="#4-3-6-调整映射的大小" class="headerlink" title="4.3.6 调整映射的大小"></a>4.3.6 调整映射的大小</h4><p>Linux （特有）提供 mremap() 来调整映射大小。</p>
<p>mremap() 将 [addr, addr + old_size) 的大小调整为 new_size。</p>
<p>根据大小和设置的 flags {0, MREMAP_MAYMOVE}，内核可以同时移动映射区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">mremap</span> <span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> old_size, <span class="type">size_t</span> new_size, </span></span><br><span class="line"><span class="params">               <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-6-1-返回值和错误码"><a href="#4-3-6-1-返回值和错误码" class="headerlink" title="4.3.6.1 返回值和错误码"></a>4.3.6.1 返回值和错误码</h5><p>成功返回新区域的指针，失败返回 MAP_FAILED，设置 errno。</p>
<blockquote>
<p>glibc 常用 mremap() 实现高效 realloc()，来调整 malloc() 分配的内存。</p>
</blockquote>
<h4 id="4-3-7-改变映射内存区域的权限"><a href="#4-3-7-改变映射内存区域的权限" class="headerlink" title="4.3.7 改变映射内存区域的权限"></a>4.3.7 改变映射内存区域的权限</h4><p>POSIX 定义了 mprotect()，允许程序改变内存区的权限：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mprotect</span> <span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>prot 值是非累积的。</p>
<p>如果一块可读区域将 mprotect 的 prot值设置为 PROT_WRITE，则调用后为只写。</p>
</blockquote>
<h5 id="4-3-7-1-返回值和错误码"><a href="#4-3-7-1-返回值和错误码" class="headerlink" title="4.3.7.1 返回值和错误码"></a>4.3.7.1 返回值和错误码</h5><p>成功返回 0；失败返回 -1，设置 errno。</p>
<h4 id="4-3-8-使用映射机制同步文件"><a href="#4-3-8-使用映射机制同步文件" class="headerlink" title="4.3.8 使用映射机制同步文件"></a>4.3.8 使用映射机制同步文件</h4><p>POSIX 提供一个使用存储映射机制并与 fsync() 等价的系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msync</span> <span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>调用 msync() 将映射内存修改回写到磁盘中，从而同步映射和被映射文件。 </p>
<blockquote>
<p>与 write() 不同，内存映射写入由进程直接修改内核页缓存，不经过内核。（待补充）</p>
</blockquote>
<h5 id="4-3-8-1-返回值和错误码"><a href="#4-3-8-1-返回值和错误码" class="headerlink" title="4.3.8.1 返回值和错误码"></a>4.3.8.1 返回值和错误码</h5><p>调用成功返回 0；失败返回 -1，设置 errno。</p>
<h4 id="4-3-9-映射提示"><a href="#4-3-9-映射提示" class="headerlink" title="4.3.9 映射提示"></a>4.3.9 映射提示</h4><p>为了更好利用映射区域，Linux 提供 madvise() 系统调用，指示内核如何进行操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">madvise</span> <span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> advice)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>程序可以通过 madvise() 来影响预读窗口的大小（设置连续访问或随机访问）。</p>
</blockquote>
<h5 id="4-3-9-1-返回值和错误码"><a href="#4-3-9-1-返回值和错误码" class="headerlink" title="4.3.9.1 返回值和错误码"></a>4.3.9.1 返回值和错误码</h5><p>成功返回 0，失败返回 -1 设置 errno。</p>
<h3 id="4-4-普通文件-I-x2F-O-提示"><a href="#4-4-普通文件-I-x2F-O-提示" class="headerlink" title="4.4 普通文件 I&#x2F;O 提示"></a>4.4 普通文件 I&#x2F;O 提示</h3><h4 id="4-4-1-posix-fadvise"><a href="#4-4-1-posix-fadvise" class="headerlink" title="4.4.1 posix_fadvise()"></a>4.4.1 posix_fadvise()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">posix_fadvise</span> <span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">off_t</span> len, <span class="type">int</span> advise)</span>;</span><br></pre></td></tr></table></figure>

<p>调用 posix_fadvise() 会给出内核在文件位置范围内操作提示。</p>
<blockquote>
<p>如果 len &#x3D; 0，则提示作用于区间 [offset, length of file]。</p>
<p>一般 len 和 offset 都置 0，从而使提示作用到整个文件。</p>
</blockquote>
<p>示例——要求内核随机、无序的访问 fd 代表的文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret;</span><br><span class="line">ret = posix_fadvise (fd, <span class="number">0</span>, <span class="number">0</span>, POSIX_FADV_RANDOM);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">	perror (”posix_fadvise”);</span><br></pre></td></tr></table></figure>

<h5 id="4-4-1-1-返回值和错误码"><a href="#4-4-1-1-返回值和错误码" class="headerlink" title="4.4.1.1 返回值和错误码"></a>4.4.1.1 返回值和错误码</h5><p>调用成功返回 0，失败返回 -1，设置 errno</p>
<h4 id="4-4-2-readahead-系统调用"><a href="#4-4-2-readahead-系统调用" class="headerlink" title="4.4.2 readahead() 系统调用"></a>4.4.2 readahead() 系统调用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readahead</span> <span class="params">(<span class="type">int</span> fd, <span class="type">off64_t</span> offset, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>readahead() 调用将读入 fd 的 [offset, offset + count) 区域到页缓存中。</p>
<h5 id="4-4-2-1-返回值和错误码"><a href="#4-4-2-1-返回值和错误码" class="headerlink" title="4.4.2.1 返回值和错误码"></a>4.4.2.1 返回值和错误码</h5><p>成功返回 0，失败返回 -1，设置 errno</p>
<h4 id="4-4-3-”经济实用“的操作提示"><a href="#4-4-3-”经济实用“的操作提示" class="headerlink" title="4.4.3 ”经济实用“的操作提示"></a>4.4.3 ”经济实用“的操作提示</h4><ul>
<li>读取文件的大部分内容，设置 POSIX_FADV_WILLNEED 要求内核预读文件。</li>
<li>读写了大量数据后，设置 POSIX_FADV_DONTNEED 要求内核丢弃缓冲内容。</li>
<li>进程试图读整个文件时，设置 POSIX_FADV_SEQUENTIAL 要求内核大量预读。</li>
<li>进程试图随机访问文件，设置 POSIX_FADV_RANDOM 告诉内核不进行预读。</li>
</ul>
<h3 id="4-5-同步，同步及异步操作"><a href="#4-5-同步，同步及异步操作" class="headerlink" title="4.5 同步，同步及异步操作"></a>4.5 同步，同步及异步操作</h3><ul>
<li><p>synchronous 和 asynchronous 指 I&#x2F;O 操作在返回前是否等待某些事件的返回。</p>
</li>
<li><p>synchronized 和 asynchronized 准确指定了某个事件必须发生（例如写回）。</p>
</li>
</ul>
<blockquote>
<p>一个 synchronized 操作要比 synchronous 操作的限制更多也更安全。</p>
</blockquote>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221020221109670.png" alt="image-20221020221109670"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221020221118585.png" alt="image-20221020221118585"></p>
<h4 id="4-5-1-异步-I-x2F-O"><a href="#4-5-1-异步-I-x2F-O" class="headerlink" title="4.5.1 异步 I&#x2F;O"></a>4.5.1 异步 I&#x2F;O</h4><p>Linux 实现了 aio，aio 库提供了一系列函数来实现异步 I&#x2F;O 提交以及在完成时收到提示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="comment">/* asynchronous I/O control block */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> aio_filedes; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">int</span> aio_lio_opcode; <span class="comment">/* operation to perform */</span></span><br><span class="line">    <span class="type">int</span> aio_reqprio; <span class="comment">/* request priority offset */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">void</span> *aio_buf; <span class="comment">/* pointer to buffer */</span></span><br><span class="line">    <span class="type">size_t</span> aio_nbytes; <span class="comment">/* length of operation */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">aio_sigevent</span>;</span> <span class="comment">/* signal number and value */</span></span><br><span class="line">    <span class="comment">/* internal, private members follow... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">aio_read</span> <span class="params">(<span class="keyword">struct</span> aiocb *aiocbp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">aio_write</span> <span class="params">(<span class="keyword">struct</span> aiocb *aiocbp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">aio_error</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> aiocb *aiocbp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">aio_return</span> <span class="params">(<span class="keyword">struct</span> aiocb *aiocbp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">aio_cancel</span> <span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> aiocb *aiocbp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">aio_fsync</span> <span class="params">(<span class="type">int</span> op, <span class="keyword">struct</span> aiocb *aiocbp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">aio_suspend</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> aiocb * <span class="type">const</span> cblist[], <span class="type">int</span> n, </span></span><br><span class="line"><span class="params">                 <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="4-5-1-1-基于线程的异步-I-x2F-O"><a href="#4-5-1-1-基于线程的异步-I-x2F-O" class="headerlink" title="4.5.1.1 基于线程的异步 I&#x2F;O"></a>4.5.1.1 基于线程的异步 I&#x2F;O</h5><p>Linux 只支持使用 O_DIRECT 标志打开的文件上的 aio。对于普通文件，需要自己实现异步。</p>
<p>以下是使用线程方法，所要完成的任务：</p>
<ol>
<li>创建一个线程池来处理所有的 I&#x2F;O。</li>
<li>实现将 I&#x2F;O 操作加入工作队列的一系列函数。</li>
<li>使这些函数返回唯一的 I&#x2F;O 描述符，来区分相关的 I&#x2F;O 操作。每个工作线程响应队列首的 I&#x2F;O 请求，提交到内核，等待他们完成。</li>
<li>完成后，把操作的结果加入到一个结果队列中。</li>
<li>实现一些列从结果队列中获取状态信息的函数，使用最初返回的 I&#x2F;O 描述符区分每个操作。</li>
</ol>
<blockquote>
<p>以上与 aio 相关函数行为相近，但增加了线程管理开销。</p>
</blockquote>
<h3 id="4-6-I-x2F-O-调度器和-I-x2F-O-性能"><a href="#4-6-I-x2F-O-调度器和-I-x2F-O-性能" class="headerlink" title="4.6 I&#x2F;O 调度器和 I&#x2F;O 性能"></a>4.6 I&#x2F;O 调度器和 I&#x2F;O 性能</h3><p>I&#x2F;O 调度器：通过管理请求的顺序和次数，使得磁盘寻道次数和移动距离最小化。</p>
<h4 id="4-6-1-磁盘寻址"><a href="#4-6-1-磁盘寻址" class="headerlink" title="4.6.1 磁盘寻址"></a>4.6.1 磁盘寻址</h4><p>CHS 寻址：柱面 （cylinders）（r），磁头（heads）（z）和扇区（section）（θ）</p>
<p>LBA 寻址：硬盘驱动转换<strong>块号</strong>（物理块）到正确的 <strong>CHS 地址</strong>。</p>
<blockquote>
<p>文件系统操作单元是逻辑块，逻辑块映射到一个或多个硬盘物理块。</p>
</blockquote>
<h4 id="4-6-2-调度器的功能"><a href="#4-6-2-调度器的功能" class="headerlink" title="4.6.2 调度器的功能"></a>4.6.2 调度器的功能</h4><p>I&#x2F;O 调度器实现两个基本操作：合并（两个或多个相邻请求）和排序（块号递增排序）。</p>
<h4 id="4-6-3-改进读请求"><a href="#4-6-3-改进读请求" class="headerlink" title="4.6.3 改进读请求"></a>4.6.3 改进读请求</h4><p>由于存在读延迟问题，简单地插入处理请求会使排位靠后的读请求出现”饿死“，极大影响性能。</p>
<h5 id="4-6-3-1-Deadline-I-x2F-O-调度器"><a href="#4-6-3-1-Deadline-I-x2F-O-调度器" class="headerlink" title="4.6.3.1 Deadline I&#x2F;O 调度器"></a>4.6.3.1 Deadline I&#x2F;O 调度器</h5><p>加入 FIFO 队列区分读写请求，并为读请求赋予更小的过期事件。</p>
<h5 id="4-6-3-2-Anticipatory-I-x2F-O-调度器"><a href="#4-6-3-2-Anticipatory-I-x2F-O-调度器" class="headerlink" title="4.6.3.2 Anticipatory I&#x2F;O 调度器"></a>4.6.3.2 Anticipatory I&#x2F;O 调度器</h5><p>在 Deadline I&#x2F;O 的基础上增加预测机制：</p>
<p>​	调度后等待 6ms ，若又产生了对磁盘同部分的读请求，则响应。</p>
<h5 id="4-6-3-3-CFQ-I-x2F-O-调度器"><a href="#4-6-3-3-CFQ-I-x2F-O-调度器" class="headerlink" title="4.6.3.3. CFQ I&#x2F;O 调度器"></a>4.6.3.3. CFQ I&#x2F;O 调度器</h5><p>为每个进程的队列分配时间片，使用轮转方式处理队列请求，直到时间片耗尽或所有请求处理完毕。</p>
<p>如果所有请求处理完了，调度器会空转一段时间，等待新请求。如果预测成功，则处理新请求；否则处理下个进程的队列请求。</p>
<blockquote>
<p>CFQ 调度器适合高负载情况，并且是第一选择。</p>
</blockquote>
<h5 id="4-6-3-4-Noop-I-x2F-O-调度器"><a href="#4-6-3-4-Noop-I-x2F-O-调度器" class="headerlink" title="4.6.3.4 Noop I&#x2F;O 调度器"></a>4.6.3.4 Noop I&#x2F;O 调度器</h5><p>最简单的调度器，一般用在无需对请求排队的特殊设备中。</p>
<h4 id="4-6-4-选择和配置你的-I-x2F-O-调度器"><a href="#4-6-4-选择和配置你的-I-x2F-O-调度器" class="headerlink" title="4.6.4 选择和配置你的 I&#x2F;O 调度器"></a>4.6.4 选择和配置你的 I&#x2F;O 调度器</h4><p>例如，设置设备 hda 的 I&#x2F;Q 调度程序为 CFQ</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> cfq &gt; /sys/block/hda/queue/scheduler</span></span><br></pre></td></tr></table></figure>

<h4 id="4-6-5-优化-I-x2F-O-性能"><a href="#4-6-5-优化-I-x2F-O-性能" class="headerlink" title="4.6.5 优化 I&#x2F;O 性能"></a>4.6.5 优化 I&#x2F;O 性能</h4><h5 id="4-6-5-1-用户空间-I-x2F-O-调度"><a href="#4-6-5-1-用户空间-I-x2F-O-调度" class="headerlink" title="4.6.5.1 用户空间 I&#x2F;O 调度"></a>4.6.5.1 用户空间 I&#x2F;O 调度</h5><p>如果应用会产生大量读写请求，最好在提交前进行排序，避免性能损耗。</p>
<p>可处理的排序方式：</p>
<ul>
<li><p>完整路径</p>
<p>简单，效率低。原理是同目录下文件在磁盘中相邻分布概率大。</p>
</li>
<li><p>inode 编号</p>
<p>比路径有效就，容易获取和排序，原理是 inode序号通常和物理块挂钩。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221021105854065.png" alt="image-20221021105854065"></p>
</li>
<li><p>文件的物理块</p>
<p>获取文件文件真实的物理块号，接近最优结果。缺点是需要 root 权限。</p>
</li>
</ul>
<h3 id="4-7-结论"><a href="#4-7-结论" class="headerlink" title="4.7 结论"></a>4.7 结论</h3>
    </div>

    
    <div class="about">
        <h1>About this Post</h1>
        <div class="details">
            <p>This post is written by aaaris, licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a>.</p>
        </div>
        
    </div>
    

    <div class="container post-prev-next">
        
        <a href="/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E4%BA%94%E7%AB%A0/" class="next">
            <div>
                <div class="text">
                    <p class="label">Next</p>
                    <h3 class="title">Linux系统编程 第五章</h3>
                </div>
            </div>
        </a>
        
        
        <a href="/2022/10/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%20%E7%AC%AC%E4%B8%89%E7%AB%A0/" class="prev">
            <div>
                <div class="text">
                    <p class="label">Previous</p>
                    <h3 class="title">Linux系统编程 第三章</>
                </div>
            </div>
        </a>
        
    </div>

    
        
        
    
</article>

        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h4 class="title">Blog</h4>
                
                <a href="/" class="item">Blog</a>
                
                <a href="/archives" class="item">Archives</a>
                
                <a href="/tags" class="item">Tags</a>
                
                <a href="/categories" class="item">Categories</a>
                
                <a href="/search" class="item">Search</a>
                
                <a href="/friends" class="item">Friends</a>
                
                <a href="/projects" class="item">Projects</a>
                
                <a href="/resume" class="item">Resume</a>
                
                <a href="/about" class="item">About</a>
                
                <a href="/atom.xml" class="item">RSS</a>
                
            </div>
            
            <div class="group">
                <h4 class="title">Projects</h4>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/rsa-cli" class="item">RSA CLI</a>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/hexo-theme-cupertino" class="item">Hexo Theme Cupertino</a>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/a-calendar" class="item">A Calendar</a>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/auto-mirroring-bucket" class="item">Auto Mirroring Bucket</a>
                
            </div>
            
            <div class="group">
                <h4 class="title">Me</h4>
                
                <a target="_blank" rel="noopener" href="https://github.com/aaaris" class="item">GitHub</a>
                
                <a href="2997600742@qq.com" class="item">Email</a>
                
            </div>
            
        </div>
        <span>&copy; 2022 aaaris<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> </span>
        
        
            <br>
            <div class="color-scheme-toggle" role="radiogroup" id="theme-color-scheme-toggle">
                <label>
                    <input type="radio" value="light">
                    <span>Light</span>
                </label>
                <label>
                    <input type="radio" value="dark">
                    <span>Dark</span>
                </label>
                <label>
                    <input type="radio" value="auto">
                    <span>Auto</span>
                </label>
            </div>
        
    </div>
</footer>


        
<script src="/js/main.js"></script>

        
        
        

        
        <script src="https://unpkg.com/scrollreveal"></script>
        <script>
            window.addEventListener('load', () => {
                ScrollReveal({ delay: 250, reset: true, easing: 'cubic-bezier(0, 0, 0, 1)' })
                ScrollReveal().reveal('.post-list-item .cover-img img')
                ScrollReveal().reveal('.post-list-item, .card, .content p img, .content .block-large img', { distance: '60px', origin: 'bottom', duration: 800 })
            })
        </script>
        
    </body>
</html>